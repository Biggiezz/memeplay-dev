<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MemePlay Arcade</title>
  <!-- Favicon files (desktop + mobile) -->
  <link rel="icon" type="image/svg+xml" href="assets/favicon.svg?v=2">
  <link rel="shortcut icon" href="assets/favicon.svg?v=2">
  <link rel="apple-touch-icon" href="assets/favicon.svg?v=2">
  <link rel="stylesheet" href="style.css">
  <link rel="preconnect" href="https://moonshot-bnb.lovable.app" crossorigin>
  <link rel="preconnect" href="https://bird-squash-dev.lovable.app" crossorigin>
  <link rel="preconnect" href="https://wojak-btc-blast.lovable.app" crossorigin>
  <link rel="preconnect" href="https://hodl-tower-stack.lovable.app" crossorigin>
  <link rel="preconnect" href="https://hook-pull-crypto.lovable.app" crossorigin>
  <link rel="preconnect" href="https://game-detective-clone.lovable.app" crossorigin>
  <link rel="preconnect" href="https://monkey-crypto-climb.lovable.app" crossorigin>
  <link rel="preconnect" href="https://crypto-arrow1.lovable.app" crossorigin>
  <link rel="preconnect" href="https://inverse-cramer.lovable.app" crossorigin>
  <link rel="preconnect" href="https://cryptomole-whack-meme.lovable.app" crossorigin>
  <link rel="preconnect" href="https://coin-catch1.lovable.app" crossorigin>
  <link rel="preconnect" href="https://xstarship-flap.lovable.app" crossorigin>
  <link rel="preconnect" href="https://pacman-memeplay.lovable.app" crossorigin>
  <link rel="preconnect" href="https://crypto-sky-jump.lovable.app" crossorigin>
  <link rel="preconnect" href="https://story-shape-studio.lovable.app" crossorigin>
  <link rel="preconnect" href="https://pixel-orb-escape.lovable.app" crossorigin>
  <link rel="preconnect" href="https://rosebud.ai" crossorigin>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Debug console for mobile - Remove sau khi fix xong -->
  <!-- DEBUG: Eruda console (DISABLED for performance) -->
  <!-- <script src="https://cdn.jsdelivr.net/npm/eruda"></script> -->
  <!-- <script>eruda.init();</script> -->
  <style>
    :root { --header-h: 60px; }
    /* ===== HEADER (Docs link left, actions right) ===== */
    .main-header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: var(--header-h);
      background: #111;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      box-sizing: border-box;
      z-index: 9999;
      border-bottom: 2px solid #222;
    }
    .logo {
      display: inline-flex;
      align-items: center;
      gap: 12px;
      position: relative;
    }
    .hamburger-wrapper {
      position: relative;
      display: inline-flex;
    }
    .hamburger-wrapper .nav-dropdown {
      left: 0;
      right: auto;
    }
    .docs-menu-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 8px;
      background: rgba(255, 182, 66, 0.08);
      transition: all 0.2s ease;
      text-decoration: none;
      cursor: pointer;
      border: none;
    }
    .docs-menu-btn:hover {
      background: rgba(255, 182, 66, 0.15);
      transform: translateY(-1px);
    }
    .docs-menu-btn:active {
      transform: translateY(0);
    }
    .hamburger-icon {
      width: 20px;
      height: 20px;
      display: block;
    }
    .logo-text {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 1.4px;
      color: #ffb642;
      text-shadow: 0 0 12px rgba(255, 182, 66, 0.45);
      user-select: none;
    }
    .header-flash {
      position: absolute;
      top: 0;
      left: 0;
      font-size: 13px;
      font-weight: 700;
      color: #fff;
      background: linear-gradient(135deg, #ffb642, #ff6b42);
      padding: 4px 10px;
      border-radius: 8px;
      border: 1.5px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 4px 12px rgba(255, 182, 66, 0.5);
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      white-space: nowrap;
      pointer-events: none;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      letter-spacing: 0.2px;
      line-height: 1.3;
    }
    .header-actions {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .search-wrapper {
      position: relative;
    }
    .icon-button {
      width: 44px;
      height: 44px;
      border-radius: 14px;
      border: 1px solid #2a2f38;
      background: #1b1f24;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.18s ease, transform 0.18s ease;
      padding: 0;
    }
    .icon-button[hidden] {
      display: none !important;
    }
    .icon-button:hover {
      background: #273040;
      transform: translateY(-1px);
    }
    .icon-button svg.header-icon {
      width: 22px;
      height: 22px;
      stroke: #ffb642;
      fill: none;
      stroke-width: 2.1;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.18s ease;
    }
    .icon-button:hover svg.header-icon,
    .icon-button:focus-visible svg.header-icon {
      stroke: #ffd678;
    }
    .icon-button img {
      width: 22px;
      height: 22px;
    }
    .icon-button .icon-plus {
      font-size: 24px;
      font-weight: 600;
      color: #ffb642;
      line-height: 1;
      transition: color 0.18s ease;
    }
    .icon-button:hover .icon-plus {
      color: #ffd678;
    }
    .nav-dropdown {
      position: absolute;
      top: calc(100% + 12px);
      right: 0;
      width: 210px;
      background: #1a1f28;
      color: #fff;
      border-radius: 16px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.6);
      display: none;
      flex-direction: column;
      padding: 10px 0;
      z-index: 10000;
      overflow: hidden; /* Fix: Prevent content from breaking rounded corners */
    }
    .nav-dropdown.open {
      display: flex;
      animation: fadeIn 0.18s ease;
    }
    .dropdown-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .dropdown-item {
      padding: 12px 22px;
      cursor: pointer;
      transition: background 0.18s ease;
      font-weight: 500;
      font-size: 16px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
    }
    .dropdown-item:hover,
    .dropdown-item.active {
      background: #273e66;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px);}
      to { opacity: 1; transform: none;}
    }
    .wallet-connect img {
      width: 26px;
      height: 24px;
    }
    .wallet-status-button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 0 14px;
      height: 44px;
      border-radius: 14px;
      border: 1px solid #2a2f38;
      background: #1b1f24;
      color: #0ff;
      font-weight: 600;
      letter-spacing: 0.3px;
      cursor: pointer;
      transition: background 0.18s ease, transform 0.18s ease;
    }
    .wallet-status-button[hidden] {
      display: none !important;
    }
    .wallet-status-button:hover {
      background: #273040;
      transform: translateY(-1px);
    }
    .wallet-status-icon {
      width: 22px;
      height: 18px;
    }

    /* ===== PAGE LAYOUT SPACING ===== */
    body {
      margin: 0;
      padding-top: calc(var(--header-h) + env(safe-area-inset-top));
      min-height: 100svh;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      scroll-behavior: smooth;
      overflow: hidden; /* scroll inside .game-container for snap */
    }
    /* Move the game container below the header */
    .game-container {
      margin-top: 0; /* Remove margin for precise centering */
    }

    .game-card {
      position: relative;
    }
    
    /* Ensure html and body also hide scrollbar */
    html {
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
    }
    html::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
    body {
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    body::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
    .allow-text-select,
    .allow-text-select * {
      user-select: text !important;
      -webkit-user-select: text !important;
      -webkit-touch-callout: default !important;
    }
    textarea,
    input,
    .comments-input,
    .comments-input * {
      user-select: text !important;
      -webkit-user-select: text !important;
      -webkit-touch-callout: default !important;
    }
    .game-container {
      height: calc(100svh - var(--header-h) - env(safe-area-inset-top));
      overflow-y: auto;
      overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
      scroll-snap-type: y mandatory;
      scroll-padding-top: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 2px 0 28px;
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
    }
    .game-container::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
    .game-card {
      width: min(calc(100vw - 8px), 720px);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      margin: 0 auto 6px;
      padding: 0 3px 6px;
      box-sizing: border-box;
      scroll-snap-align: center;
      scroll-snap-stop: always;
      contain: layout;
    }
    .game-card.is-playing {
      will-change: contents;
    }
    .game-card.is-playing .game-footer *,
    .game-card.is-playing .focus-toggle {
      transition: none !important;
      animation: none !important;
    }
    .game-card iframe {
      touch-action: pan-y;
    }
    .game-stage {
      position: relative;
      width: 100%;
      aspect-ratio: 720 / 1000 !important;  /* ← FORCE TABLE VERSION! */
      border-radius: 28px;
      background: linear-gradient(145deg, rgba(14,19,30,0.92), rgba(6,9,15,0.92));
      border: 1px solid rgba(40,58,90,0.35);
      overflow: hidden;
      box-shadow: 0 20px 55px rgba(0,0,0,0.6);
      user-select: none;
      -webkit-user-select: none;
      contain: layout style paint;
      content-visibility: auto;
    }
    .game-stage iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
      will-change: transform;
      transform: translateZ(0);
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      pointer-events: auto;
    }
    .focus-toggle {
      position: absolute;
      top: 14px;
      right: 14px;
      width: 44px;
      height: 44px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(6, 9, 15, 0.3);
      color: #eef4ff;
      font-size: 22px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0.32;
      transition: background 0.18s ease, transform 0.18s ease, opacity 0.18s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      user-select: none;
      -webkit-user-select: none;
    }
    .focus-toggle:hover,
    .focus-toggle:focus-visible {
      background: rgba(6, 9, 15, 0.72);
      opacity: 0.95;
      transform: translateY(-1px);
      outline: none;
    }
    .game-footer {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 4px 10px 6px;
      background: rgba(9, 14, 22, 0.94);
      border: 1px solid rgba(40,58,90,0.25);
      border-radius: 14px;
      box-shadow: 0 5px 16px rgba(0,0,0,0.35);
      color: #e3ecff;
      font-size: 9.8px;
      user-select: none;
      -webkit-user-select: none;
      text-align: center;
    }
    .game-icons {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: nowrap;
      gap: 14px;
    }
    .game-icons-left {
      display: flex;
      align-items: center;
      gap: 14px;
    }
    .game-icons-right {
      display: flex;
      align-items: center;
      gap: 14px;
    }
    .icon-wrapper {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }
    .icon-wrapper button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      border: none;
      background: none;
      padding: 0;
      cursor: pointer;
      transition: transform 0.18s ease, opacity 0.18s ease;
    }
    .icon-wrapper button:hover {
      transform: translateY(-2px);
    }
    .icon-wrapper button:focus-visible {
      outline: 2px solid rgba(255,182,66,0.45);
      outline-offset: 3px;
    }
    .icon-wrapper[data-role="marketcap"] {
      margin-right: -10px;
    }
    .icon-wrapper[data-role="marketcap"] button {
      width: auto;
      min-width: 26px;
      padding: 0;
    }
    .icon-wrapper[data-role="marketcap"] button::before {
      content: 'MC';
      font-size: 20px;
      font-weight: 700;
      color: #ffffff;
      line-height: 1;
    }
    .icon-wrapper[data-role="marketcap"] button span {
      white-space: nowrap;
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.5px;
      line-height: 1;
      color: #ffffff;
      display: inline !important; /* Show MC number after "MC" text */
      margin-left: 4px; /* Add space between "MC" and number */
    }
    .icon-wrapper[data-role="donate"] svg {
      stroke: #ffffff;
      stroke-width: 3.5;
      width: 20px;
      height: 20px;
    }
    .icon-wrapper[data-role="donate"] .icon-count {
      color: #ffffff;
      font-weight: 700;
    }
    @media (max-width: 768px) {
      .icon-wrapper[data-role="marketcap"] {
        transform: translateX(-30px);
      }
      .icon-wrapper[data-role="marketcap"] button::before {
        font-size: 14px;
      }
      .icon-wrapper[data-role="marketcap"] button span {
        font-size: 8.5px;
        letter-spacing: 0.1px;
        display: inline !important; /* Show MC number on mobile */
        margin-left: 2px; /* Add space between "MC" and number on mobile */
      }
      .game-footer {
        padding: 4px 14px 6px 14px !important;
        position: relative;
      }
      .creator-text {
        font-size: 8.25px !important;
        margin-left: 0px !important;
        padding-right: 36px !important;
        text-align: left !important;
        display: block !important;
        width: 100%;
      }
      .creator-text strong {
        font-size: 8.25px !important;
        font-weight: 600;
      }
      .icon-wrapper[data-role="leaderboard"] {
        position: absolute !important;
        bottom: 6px !important;
        right: 14px !important;
        transform: scale(1) !important;
      }
    }
    .icon-wrapper svg {
      width: 22px;
      height: 22px;
      stroke: #ffb642;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.18s ease, fill 0.18s ease;
    }
    .icon-wrapper:hover svg,
    .icon-wrapper:active svg {
      stroke: #ffd678;
    }
    .icon-wrapper.liked svg {
      stroke: #ffb642;
      fill: #ffb642;
    }
    .icon-count {
      color: #ffb642;
      font-size: 11px;
      font-weight: 600;
      line-height: 1;
      min-width: 20px;
      text-align: right;
    }
    .creator-text {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      color: #d4def5;
      font-size: 11px;
      letter-spacing: 0.2px;
      line-height: 1.2;
    }
    .creator-box {
      max-width: 540px;
      padding: 36px 32px;
      gap: 0;
      background: #0b0b0b;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }
    .creator-box .wallet-header {
      border-bottom: none;
      margin-bottom: 16px;
      padding-bottom: 0;
    }
    .creator-hero {
      color: #ffb642;
      font-size: 34px;
      font-weight: 700;
      line-height: 1.2;
      text-align: left;
      margin-bottom: 32px;
      border-bottom: none;
    }
    .creator-points {
      display: flex;
      flex-direction: column;
      gap: 18px;
      margin-bottom: 32px;
      color: #f3c978;
      font-size: 18px;
      line-height: 1.5;
    }
    .creator-point {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .creator-point-icon {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 2px solid #ffb642;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: 700;
    }
    .creator-cta {
      margin-top: auto;
      border: 2px solid #ffb642;
      border-radius: 16px;
      padding: 18px 24px;
      text-align: center;
      color: #ffb642;
      font-size: 22px;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      opacity: 0.45;
      transition: opacity 0.2s ease;
    }
    .creator-cta span {
      display: block;
      font-size: 14px;
      font-weight: 500;
      color: #e5c37a;
      letter-spacing: 0;
      text-transform: none;
      opacity: 0.75;
    }
    .leaderboard-box {
      max-width: 520px;
      padding: 20px 24px;
      background: #0b0b0b;
      border: 1px solid rgba(255,182,66,0.35);
    }
    .leaderboard-header {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .leaderboard-tabs {
      display: flex;
      gap: 10px;
      background: rgba(255,182,66,0.08);
      padding: 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,182,66,0.25);
    }
    .leaderboard-tab {
      background: transparent;
      border: none;
      color: #ffce7a;
      font-weight: 700;
      font-size: 16px;
      padding: 8px 18px;
      border-radius: 999px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.1s ease;
      letter-spacing: 0.5px;
    }
    .leaderboard-tab:hover {
      background: rgba(255,182,66,0.12);
      transform: scale(1.02);
    }
    .leaderboard-tab.active {
      background: rgba(255,182,66,0.35);
      color: #ffffff;
      text-shadow: 0 0 12px rgba(255,182,66,0.6);
      font-weight: 700;
    }
    .leaderboard-panels {
      margin-top: 18px;
    }
    .leaderboard-panel {
      display: none;
    }
    .leaderboard-panel.active {
      display: block;
    }
    .leaderboard-list {
      max-height: 65vh;
      overflow-y: auto;
      padding: 12px 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .leaderboard-list::-webkit-scrollbar {
      display: none;
    }
    .leaderboard-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #15191f;
      border: 1px solid rgba(255,182,66,0.15);
      border-radius: 10px;
      padding: 12px 16px;
      gap: 12px;
      transition: background 0.2s ease;
    }
    .leaderboard-item:hover {
      background: #1a1f28;
    }
    .leaderboard-item.user-highlight {
      background: linear-gradient(135deg, rgba(255,182,66,0.2), rgba(255,206,122,0.15));
      border: 2px solid #ffb642;
      margin-bottom: 12px;
    }
    .leaderboard-rank {
      font-size: 18px;
      font-weight: 700;
      color: #ffb642;
      min-width: 48px;
      text-align: center;
    }
    .leaderboard-user {
      flex: 1;
      color: #d5d9e6;
      font-size: 15px;
      font-weight: 500;
    }
    .leaderboard-score {
      font-size: 17px;
      font-weight: 700;
      color: #ffb642;
      min-width: 60px;
      text-align: right;
    }
    .leaderboard-divider {
      text-align: center;
      color: #f0c67a;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin: 20px 0 6px;
    }
    .leaderboard-reward-summary {
      text-align: center;
      color: #f0c67a;
      margin-bottom: 18px;
    }
    .leaderboard-reward-summary .reward-total {
      font-size: 30px;
      font-weight: 700;
      color: #ffb642;
      margin-top: 6px;
    }
    .leaderboard-reward-progress {
      width: 100%;
      height: 8px;
      background: rgba(255,182,66,0.2);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 12px;
    }
    .leaderboard-reward-progress span {
      display: block;
      height: 100%;
      background: #ffb642;
      transition: width 0.3s ease;
    }
    .leaderboard-reward-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .leaderboard-reward-card {
      padding: 16px 20px;
      border-radius: 12px;
      border: 1px solid rgba(60, 90, 138, 0.4);
      background: rgba(39, 62, 102, 0.3);
      display: flex;
      align-items: center;
      gap: 12px;
      transition: border 0.2s ease, background 0.2s ease;
    }
    .leaderboard-reward-card.unlocked {
      background: rgba(255, 182, 66, 0.15);
      border-color: rgba(255, 182, 66, 0.4);
    }
    .leaderboard-reward-card .reward-name {
      font-size: 18px;
      font-weight: 700;
      color: #999;
    }
    .leaderboard-reward-card.unlocked .reward-name {
      color: #ffb642;
    }
    .leaderboard-reward-card .reward-status {
      font-size: 14px;
      color: #bbb;
      margin-top: 4px;
    }
    .leaderboard-reward-card .reward-amount {
      font-size: 18px;
      font-weight: 700;
      color: #666;
    }
    .leaderboard-reward-card.unlocked .reward-amount {
      color: #ffb642;
    }
    /* Share Modal Buttons */
    .share-option-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: rgba(39, 62, 102, 0.4);
      border: 1px solid rgba(60, 90, 138, 0.5);
      border-radius: 12px;
      color: #fff;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      width: 100%;
      box-sizing: border-box;
    }
    .share-option-btn:hover {
      background: rgba(39, 62, 102, 0.7);
      border-color: rgba(60, 90, 138, 0.8);
      transform: translateY(-2px);
    }
    .share-option-btn:active {
      transform: translateY(0);
    }
    .share-option-btn svg {
      flex-shrink: 0;
    }
    .share-option-btn span {
      flex: 1;
      text-align: left;
    }
    #shareCopyBtn svg {
      stroke: #ffb642;
    }
    #shareTelegramBtn svg {
      fill: #0088cc;
    }
    #shareXBtn svg {
      fill: #fff;
    }
    /* Achievement Toast Center */
    .achievement-toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 999999 !important; /* Higher than focus-mode (90000) */
      background: linear-gradient(135deg, rgba(255, 182, 66, 1) 0%, rgba(255, 144, 0, 1) 100%); /* Full opacity */
      border: 4px solid #ffb642;
      border-radius: 24px;
      padding: 24px 32px;
      text-align: center;
      box-shadow: 0 20px 80px rgba(255, 182, 66, 0.9), 0 0 100px rgba(255, 144, 0, 0.7);
      opacity: 0;
      transform-origin: center;
      transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      pointer-events: none;
      backdrop-filter: blur(10px);
      max-width: 90%; /* Responsive width */
      min-width: 280px; /* Smaller minimum for mobile */
    }
    .achievement-toast-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      border: none;
      background: rgba(0, 0, 0, 0.2);
      color: #fff;
      font-size: 28px;
      font-weight: 700;
      line-height: 1;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
      pointer-events: all !important; /* ✅ Always clickable, even when parent has pointer-events: none */
      z-index: 10; /* ✅ Above all other elements in toast */
    }
    .achievement-toast-close:hover {
      background: rgba(0, 0, 0, 0.4);
    }
    .achievement-toast.show {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
      animation: bounceIn 0.6s ease-out;
      pointer-events: all !important; /* Allow user to interact with toast */
    }
    .achievement-toast-title {
      font-size: 36px;
      font-weight: 800;
      color: #000;
      margin-bottom: 16px;
      text-shadow: 0 3px 8px rgba(255,255,255,0.5);
      letter-spacing: 1px;
    }
    .achievement-toast-subtitle {
      font-size: 24px;
      font-weight: 700;
      color: #1a1a1a;
      margin-bottom: 12px;
    }
    .achievement-toast-reward {
      font-size: 48px;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 4px 12px rgba(0,0,0,0.7), 0 0 20px rgba(255,255,255,0.3);
      letter-spacing: 2px;
    }
    /* Mobile responsive toast */
    @media (max-width: 480px) {
      .achievement-toast {
        padding: 20px 24px;
        min-width: 260px;
        max-width: 85%;
        border-radius: 16px;
      }
      .achievement-toast-title {
        font-size: 28px;
        margin-bottom: 12px;
    }
    .achievement-toast-subtitle {
        font-size: 18px;
      margin-bottom: 8px;
    }
    .achievement-toast-reward {
        font-size: 36px;
        letter-spacing: 1px;
      }
    }
    /* Daily Check-in Toast */
    .daily-checkin-toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 999999;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: 4px solid #8b5cf6;
      border-radius: 24px;
      padding: 32px 40px;
      text-align: center;
      box-shadow: 0 20px 80px rgba(102, 126, 234, 0.6), 0 0 100px rgba(118, 75, 162, 0.5);
      opacity: 0;
      transform-origin: center;
      transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      pointer-events: none;
      backdrop-filter: blur(15px);
      max-width: 90%;
      min-width: 320px;
    }
    .daily-checkin-toast.show {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
      animation: dailyBounceIn 0.8s ease-out;
    }
    .daily-checkin-icon {
      font-size: 64px;
      margin-bottom: 16px;
      animation: dailyPulse 2s ease-in-out infinite;
    }
    .daily-checkin-title {
      font-size: 32px;
      font-weight: 800;
      color: #fff;
      margin-bottom: 20px;
      text-shadow: 0 3px 8px rgba(0,0,0,0.3);
      letter-spacing: 1px;
    }
    .daily-checkin-stats {
      display: flex;
      justify-content: center;
      gap: 32px;
      margin-bottom: 20px;
    }
    .daily-checkin-stat {
      text-align: center;
    }
    .daily-checkin-stat-value {
      font-size: 40px;
      font-weight: 900;
      color: #fbbf24;
      text-shadow: 0 3px 10px rgba(0,0,0,0.5);
      display: block;
      margin-bottom: 4px;
    }
    .daily-checkin-stat-label {
      font-size: 14px;
      font-weight: 600;
      color: rgba(255,255,255,0.9);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .daily-checkin-reward {
      font-size: 44px;
      font-weight: 900;
      color: #10b981;
      background: rgba(16, 185, 129, 0.2);
      border: 2px solid #10b981;
      border-radius: 16px;
      padding: 16px 32px;
      text-shadow: 0 4px 12px rgba(16, 185, 129, 0.5);
      letter-spacing: 2px;
      margin-top: 12px;
      white-space: nowrap; /* Force single line */
    }
    @media (max-width: 480px) {
      .daily-checkin-toast {
        padding: 24px 28px;
        min-width: 280px;
        max-width: 90%;
      }
      .daily-checkin-icon {
        font-size: 48px;
      }
      .daily-checkin-title {
        font-size: 24px;
        margin-bottom: 16px;
      }
      .daily-checkin-stats {
        gap: 20px;
      }
      .daily-checkin-stat-value {
        font-size: 32px;
      }
      .daily-checkin-stat-label {
        font-size: 12px;
      }
      .daily-checkin-reward {
        font-size: 28px;
        padding: 12px 20px;
        letter-spacing: 1px;
      }
    }
    @keyframes dailyBounceIn {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    @keyframes dailyPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.15); }
    }
    @keyframes bounceIn {
      0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.05); }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    /* Achievement Icon Shake */
    @keyframes shakeIcon {
      0%, 100% { transform: rotate(0deg); }
      10%, 30%, 50%, 70%, 90% { transform: rotate(-15deg); }
      20%, 40%, 60%, 80% { transform: rotate(15deg); }
    }
    .icon-wrapper[data-role="leaderboard"].shake {
      animation: shakeIcon 0.8s ease-in-out;
    }
    .icon-wrapper[data-role="leaderboard"] svg {
      transform: scale(1); /* Same size as heart icon */
    }
    .icon-wrapper[data-role="leaderboard"].shake svg {
      fill: #ffb642;
      filter: drop-shadow(0 0 8px rgba(255, 182, 66, 0.8));
    }
    /* Confetti Canvas */
    .confetti-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100001;
    }
    body.focus-mode {
      padding-top: env(safe-area-inset-top);
      overscroll-behavior: none;
      overflow: hidden;
      height: 100svh;
      position: fixed;
      inset: 0;
      width: 100%;
    }
    body.focus-mode .main-header,
    body.focus-mode .page-footer {
      display: none !important;
    }
    body.focus-mode .game-container {
      height: calc(100svh - env(safe-area-inset-top));
      padding: 0;
      overflow: hidden;
      scroll-snap-type: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: fixed;
      top: env(safe-area-inset-top);
      left: 50%;
      transform: translateX(-50%);
      width: min(calc(100vw - 4px), 780px);
    }
    body.focus-mode .game-card {
      width: 100%;
      max-width: 720px;  /* ← FORCE TABLE VERSION! */
      margin: 0;
      padding: 0;
    }
    body.focus-mode .game-stage {
      border-radius: 18px;
      box-shadow: 0 12px 48px rgba(0,0,0,0.7);
      touch-action: none !important;
      -ms-touch-action: none !important;
      overscroll-behavior: contain;
    }
    body.focus-mode .game-card:not(.is-focus-active) {
      display: none !important;
    }
    body.focus-mode .game-footer {
      display: none !important;
    }
    body.focus-mode .focus-toggle {
      background: rgba(0, 0, 0, 0.55);
      opacity: 0.55;
    }
    body.focus-mode .game-card:not(.is-focus-active) {
      display: none !important;
    }

    @media (max-width: 800px) {
      /* MOBILE: pixel-space-shooter handles its own scaling internally */
      /* Override common CSS to allow game 14 to control its own iframe */
      .game-card[data-game-id="pixel-space-shooter"] .game-stage {
        /* Keep aspect-ratio but allow game to scale internally */
        aspect-ratio: 720 / 1000 !important;
        width: min(100vw, 720px) !important;
        max-width: 720px !important;
      }
      .game-card[data-game-id="pixel-space-shooter"] .game-stage iframe {
        /* Keep absolute positioning but let game scale internally */
        position: absolute !important;
        inset: 0 !important;
        width: 100% !important;
        height: 100% !important;
      }
      
      /* HEADER - Reduce by 25% */
      :root { --header-h: 39px; } /* Reduced from 52px */
      .main-header {
        height: var(--header-h);
        padding: 0 14px;
      }
      .logo {
        gap: 8px;
      }
      .docs-menu-btn {
        width: 30px;
        height: 30px;
        border-radius: 6px;
      }
      .hamburger-icon {
        width: 16px;
        height: 16px;
      }
      .logo-text {
        font-size: 17px; /* Reduced 25% from 22px */
        letter-spacing: 0.8px;
      }
      .header-actions {
        gap: 8px;
      }
      .icon-button {
        width: 30px; /* Reduced 25% from 40px */
        height: 30px; /* Reduced 25% from 40px */
        border-radius: 9px;
      }
      .icon-button svg.header-icon {
        width: 16px; /* Reduced accordingly */
        height: 16px;
      }
      .wallet-status-button {
        height: 30px; /* Reduced 25% from 40px */
        padding: 0 10px;
        font-size: 12px;
      }
      .wallet-status-icon {
        width: 14px;
        height: 12px;
      }
      .nav-dropdown {
        width: 180px;
        right: 0;
      }
      
      /* FOOTER - Increase by 25% */
      .game-footer {
        gap: 5px; /* Increased from 4px */
        padding: 5px 12px 8px; /* Increased from 4px 10px 6px */
      }
      .game-icons {
        padding: 0; /* Remove padding to align to edge */
      }
      .game-icons-left {
        gap: 8px;
        margin-left: -8px; /* Pull closer to left edge by 50% */
      }
      .game-icons-right {
        gap: 8px;
        margin-right: -8px; /* Pull closer to right edge by 50% */
      }
      .icon-wrapper {
        gap: 6px; /* Reduced from 8px for tighter icon+text */
      }
      .icon-wrapper button {
        width: 25px; /* Reduced 25% from 33px */
        height: 25px;
      }
      .icon-wrapper svg {
        width: 21px; /* Reduced 25% from 28px */
        height: 21px;
        stroke-width: 2.2;
      }
      .icon-wrapper button span {
        font-size: 19px !important; /* MC text reduced 25% from 25px */
      }
      .icon-count {
        font-size: 11px; /* Reduced 25% from 14px */
        min-width: 20px;
      }
      .creator-text {
        font-size: 11px; /* Keep compact size on mobile */
      }
    }

    /* Like button active state */
    .game-icons button.liked {
      color: #ff4d4d;
      transform: scale(1.08);
    }
    /* Comments overlay */
    .comments-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:100000}
    .comments-overlay.open{display:flex}
    .comments-box{width:720px;max-width:95vw;background:#0b0b0b;border:1px solid #1f1f1f;border-radius:12px;box-shadow:0 10px 30px #000a;display:flex;flex-direction:column}
    .comments-header{display:flex;align-items:center;justify-content:flex-end;padding:10px 14px;border-bottom:1px solid #1f1f1f}
    .comments-title{display:none}
    .comments-list{height:50vh;overflow:auto;padding:10px 14px;display:flex;flex-direction:column;gap:10px;scrollbar-width:none;-ms-overflow-style:none}
    .comments-list::-webkit-scrollbar{display:none}
    .comment-item{background:#101010;border:1px solid #1f1f1f;border-radius:10px;padding:10px}
    .comment-meta{color:#8aa; font-size:24px;margin-bottom:8px}
    .comment-text{font-size:28px;line-height:1.6;white-space:pre-wrap}
    .comments-input{display:flex;gap:8px;padding:10px 14px;border-top:1px solid #1f1f1f}
    .comments-input textarea{flex:1;min-height:60px;max-height:160px;background:#0e0e0e;color:#fff;border:1px solid #2a2a2a;border-radius:8px;padding:10px;font-size:20px;resize:vertical}
    .comments-input button{height:56px;background:#273e66;color:#fff;border:1px solid #3c5a8a;border-radius:8px;padding:0 16px;cursor:pointer;font-size:32px}
    .comments-footer{display:flex;justify-content:center;padding:10px 14px}
    .comments-footer button{background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:8px;padding:8px 16px;cursor:pointer;font-size:16px}
    #statsOverlay .comments-box{max-width:460px;padding:24px 28px;background:#0b0b0b;border:1px solid rgba(255,182,66,0.35)}
    .stats-header{display:flex;align-items:center;justify-content:space-between;padding-bottom:12px;margin-bottom:12px;border-bottom:1px solid rgba(255,182,66,0.25)}
    .stats-title{font-size:20px;font-weight:600;color:#ffb642;letter-spacing:1px;text-transform:uppercase}
    .stats-content{display:flex;flex-direction:column;gap:18px;align-items:center;text-align:center;padding:12px 0 8px}
    .stats-item{display:flex;flex-direction:column;gap:6px;align-items:center}
    .stats-label{font-size:16px;color:#f0c67a;letter-spacing:1px;text-transform:uppercase}
    .stats-metric{font-size:42px;font-weight:700;color:#ffb642;text-shadow:0 0 18px rgba(255,182,66,0.35)}
    .stats-divider{width:80%;height:1px;background:rgba(255,182,66,0.2)}
    .stats-note{font-size:14px;color:#bfa36a}
    .stats-data-cache {
      position: absolute;
      width: 0;
      height: 0;
      overflow: hidden;
      opacity: 0;
    }
    #walletOverlay .comments-box{max-width:520px;padding:20px 24px;gap:0}
    .wallet-sheet{display:flex;flex-direction:column;gap:16px}
    .wallet-header{display:flex;align-items:center;justify-content:space-between;padding-bottom:12px;border-bottom:1px solid #1f1f1f}
    .wallet-title{font-size:20px;font-weight:600;color:#0ff;letter-spacing:0.8px;text-transform:uppercase}
    .wallet-body{display:flex;flex-direction:column;gap:12px;color:#d5d9e6}
    .wallet-row{display:flex;align-items:center;justify-content:space-between;background:#15191f;border:1px solid #1f242c;border-radius:12px;padding:12px 16px}
    .wallet-row span:first-child{font-size:14px;color:#9aa}
    .wallet-row span:last-child{font-size:16px;font-weight:600;color:#0ff}
    .wallet-actions{display:flex;justify-content:flex-end;gap:12px;margin-top:8px}
    .wallet-actions button{background:#273e66;color:#fff;border:1px solid #3c5a8a;border-radius:10px;padding:10px 18px;font-size:15px;font-weight:600;cursor:pointer}
    .wallet-actions button.secondary{background:none;border:1px solid #2a2f38;color:#bbb}
    @media (min-width: 1024px) {
      /* DESKTOP: Ensure all games maintain 720px width (original size) */
      .game-card {
        width: 720px !important;
        max-width: 720px !important;
      }
      .game-card .game-stage {
        width: 100% !important;
        aspect-ratio: 720 / 1000 !important;
      }
      .game-card .game-stage iframe {
        width: 100% !important;
        height: 100% !important;
      }
      
      /* DESKTOP: pixel-space-shooter handles its own scaling */
      .game-card[data-game-id="pixel-space-shooter"] .game-stage {
        aspect-ratio: none !important;
        width: auto !important;
        height: auto !important;
      }
      .game-card[data-game-id="pixel-space-shooter"] .game-stage iframe {
        position: relative !important;
        inset: auto !important;
        width: 720px !important;
        height: 1000px !important;
      }
      
      .game-footer {
        gap: 10px;
        padding: 8px 16px 12px;
        font-size: 15.5px;
      }
      .game-icons {
        gap: 22px;
      }
      .icon-wrapper button {
        width: 42px;
        height: 42px;
      }
      .icon-wrapper svg {
        width: 36px;
        height: 36px;
        stroke-width: 2.6;
      }
      .icon-count {
        font-size: 17px;
        min-width: 28px;
      }
      .creator-text {
        font-size: 17px;
        line-height: 1.4;
        letter-spacing: 0.25px;
      }
    }
  </style>
</head>
<body>
  <!-- HEADER: Logo left, Dropdown right, single row -->
  <div class="main-header">
    <div class="logo">
      <div class="hamburger-wrapper">
        <button id="hamburgerButton" class="docs-menu-btn" aria-haspopup="true" aria-expanded="false" title="Menu">
          <svg class="hamburger-icon" viewBox="0 0 24 24" aria-hidden="true">
            <line x1="3" y1="6" x2="21" y2="6" stroke="#ffb642" stroke-width="2.5" stroke-linecap="round"/>
            <line x1="3" y1="12" x2="21" y2="12" stroke="#ffb642" stroke-width="2.5" stroke-linecap="round"/>
            <line x1="3" y1="18" x2="21" y2="18" stroke="#ffb642" stroke-width="2.5" stroke-linecap="round"/>
          </svg>
        </button>
        <div class="nav-dropdown" id="hamburgerDropdown" role="menu" aria-hidden="true">
          <div class="dropdown-list" id="hamburgerList">
            <div class="dropdown-item" data-action="docs">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; stroke: #ffb642; fill: none; stroke-width: 2; margin-right: 8px;">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
              </svg>
              Docs
            </div>
            <div class="dropdown-item" data-action="stats">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; stroke: #ffb642; fill: none; stroke-width: 2; margin-right: 8px;">
                <rect x="3" y="3" width="7" height="7"></rect>
                <rect x="14" y="3" width="7" height="7"></rect>
                <rect x="14" y="14" width="7" height="7"></rect>
                <rect x="3" y="14" width="7" height="7"></rect>
              </svg>
              Stats
            </div>
          </div>
        </div>
      </div>
      <span class="logo-text" id="memeplayLogo" style="cursor:pointer;">MEMEPLAY</span>
      <span id="headerEarnedFlash" class="header-flash"></span>
    </div>
    <div class="header-actions">
      <div class="search-wrapper">
        <button id="searchToggleButton" class="icon-button search-button" aria-haspopup="true" aria-expanded="false" title="Browse categories">
          <svg class="header-icon" viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="10.5" cy="10.5" r="6.5"></circle>
            <path d="M15.5 15.5L21 21"></path>
          </svg>
        </button>
        <div class="nav-dropdown" id="navDropdown" role="menu" aria-hidden="true">
          <div class="dropdown-list" id="dropdownList">
            <div class="dropdown-item active" data-category="Recommended">Recommended</div>
            <div class="dropdown-item" data-category="Liked">Liked</div>
            <div class="dropdown-item" data-category="Trending">Trending</div>
            <div class="dropdown-item" data-category="Popular">Popular</div>
          </div>
        </div>
      </div>
      <button id="creatorButton" class="icon-button" title="Creator">
        <svg class="header-icon" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
          <circle cx="12" cy="7" r="4"></circle>
        </svg>
        </button>
      <button id="walletConnectBtn" class="icon-button wallet-connect" aria-label="Connect MetaMask">
        <img src="assets/icons/metamask.svg" alt="MetaMask" />
      </button>
      <button id="walletStatusBtn" class="wallet-status-button" hidden aria-label="Wallet details">
        <img src="assets/icons/wallet.svg" alt="Wallet" class="wallet-status-icon" />
        <span id="walletStatusText"></span>
      </button>
    </div>
    <div class="stats-data-cache" aria-hidden="true">
      <span id="streakCount">0</span>
      <span id="headerEarned">0</span>
    </div>
  </div>

  

  <div class="game-container"></div>
    

  
  <div id="commentsOverlay" class="comments-overlay">
    <div class="comments-box">
      <div class="comments-header">
        <div class="comments-title"></div>
        <button id="commentsCloseBtn" style="background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:6px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:42px;line-height:1;font-weight:700;">×</button>
      </div>
      <div id="commentsList" class="comments-list"></div>
      <div class="comments-footer">
        <button id="commentsLoadMore">Load more</button>
      </div>
      <div class="comments-input">
        <textarea id="commentsTextarea" placeholder="Write a comment..."></textarea>
        <button id="commentsPostBtn">Post</button>
      </div>
    </div>
  </div>
  
  <div id="walletOverlay" class="comments-overlay">
    <div class="comments-box wallet-sheet">
      <div class="wallet-header">
        <div class="wallet-title">Wallet</div>
        <button id="walletCloseBtn" style="background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:6px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:42px;line-height:1;font-weight:700;">×</button>
      </div>
      <div class="wallet-body">
        <div class="wallet-row">
          <span>Address</span>
          <span id="walletOverlayAddress">-</span>
        </div>
        <div class="wallet-row">
          <span>Streak</span>
          <span id="walletOverlayStreak">0</span>
        </div>
        <div class="wallet-row">
          <span>PLAY points</span>
          <span id="walletOverlayPlays">0</span>
        </div>
      </div>
      <div class="wallet-actions">
        <button class="secondary" id="walletCopyBtn">Copy address</button>
        <button id="walletDisconnectBtn">Disconnect</button>
      </div>
    </div>
  </div>
  
  <div id="creatorOverlay" class="comments-overlay">
    <div class="comments-box creator-box">
      <div class="wallet-header" style="justify-content:flex-end;">
        <button id="creatorCloseBtn" style="background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:6px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:42px;line-height:1;font-weight:700;">×</button>
      </div>
      <div class="creator-hero">Build your game with MemePlay AI studio.</div>
      <div class="creator-points">
        <div class="creator-point">
          <div class="creator-point-icon">↑</div>
          <div>Instantly public + meme coin exposure for featured drops.</div>
        </div>
        <div class="creator-point">
          <div class="creator-point-icon">$</div>
          <div>Earn additional airdrop tokens every time players engage.</div>
        </div>
      </div>
      <div class="creator-cta">
        Create game
        <span>(coming soon)</span>
      </div>
    </div>
  </div>

  <div id="statsOverlay" class="comments-overlay">
    <div class="comments-box">
      <div class="stats-header">
        <div class="stats-title">MemePlay Stats</div>
        <button id="statsCloseBtn" style="background:none;border:1px solid rgba(255,182,66,0.4);color:#ffce7a;border-radius:8px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:36px;line-height:1;font-weight:700;">×</button>
      </div>
      <div class="stats-content">
        <div class="stats-item">
          <div class="stats-label">Current Streak</div>
          <div class="stats-metric" id="statsStreak">0</div>
        </div>
        <div class="stats-divider"></div>
        <div class="stats-item">
          <div class="stats-label">Play Points</div>
          <div class="stats-metric" id="statsPlays">0</div>
        </div>
        <div class="stats-note">Lifetime PLAY points keep growing — keep gaming daily!</div>
      </div>
    </div>
  </div>

  <div id="leaderboardOverlay" class="comments-overlay">
    <div class="comments-box leaderboard-box">
      <div class="stats-header leaderboard-header">
        <div class="leaderboard-tabs">
          <button class="leaderboard-tab active" data-panel="scores">🏆 SCORES</button>
          <button class="leaderboard-tab" data-panel="rewards">🎖 REWARDS</button>
        </div>
        <button id="leaderboardCloseBtn" style="background:none;border:1px solid rgba(255,182,66,0.4);color:#ffce7a;border-radius:8px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:36px;line-height:1;font-weight:700;margin-left:auto;">×</button>
      </div>
      <div class="leaderboard-panels">
        <div id="leaderboardPanelScores" class="leaderboard-panel active">
          <div id="leaderboardList" class="leaderboard-list"></div>
        </div>
        <div id="leaderboardPanelRewards" class="leaderboard-panel">
          <div id="leaderboardRewardSummary" class="leaderboard-reward-summary"></div>
          <div id="leaderboardRewardList" class="leaderboard-reward-list"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="shareOverlay" class="comments-overlay">
    <div class="comments-box" style="max-width:420px;padding:28px 32px;">
      <div class="stats-header">
        <div class="stats-title">Share Game</div>
        <button id="shareCloseBtn" style="background:none;border:1px solid rgba(255,182,66,0.4);color:#ffce7a;border-radius:8px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:36px;line-height:1;font-weight:700;">×</button>
      </div>
      <div style="display:flex;flex-direction:column;gap:14px;padding:20px 0 10px;">
        <button id="shareCopyBtn" class="share-option-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
          </svg>
          <span>Copy Link</span>
        </button>
        <button id="shareTelegramBtn" class="share-option-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.64 6.8c-.15 1.58-.8 5.42-1.13 7.19-.14.75-.42 1-.68 1.03-.58.05-1.02-.38-1.58-.75-.88-.58-1.38-.94-2.23-1.5-.99-.65-.35-1.01.22-1.59.15-.15 2.71-2.48 2.76-2.69a.2.2 0 00-.05-.18c-.06-.05-.14-.03-.21-.02-.09.02-1.49.95-4.22 2.79-.4.27-.76.41-1.08.4-.36-.01-1.04-.2-1.55-.37-.63-.2-1.12-.31-1.08-.66.02-.18.27-.36.74-.55 2.92-1.27 4.86-2.11 5.83-2.51 2.78-1.16 3.35-1.36 3.73-1.36.08 0 .27.02.39.12.1.08.13.19.14.27-.01.06.01.24 0 .38z"/>
          </svg>
          <span>Share on Telegram</span>
        </button>
        <button id="shareXBtn" class="share-option-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
          </svg>
          <span>Share on X</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Achievement Toast -->
  <div id="achievementToast" class="achievement-toast">
    <button id="achievementToastClose" class="achievement-toast-close" aria-label="Close">×</button>
    <div class="achievement-toast-title">🎉 Reward Earned!</div>
    <div class="achievement-toast-subtitle" id="achievementName">⭐ 10s Play Reward</div>
    <div class="achievement-toast-reward" id="achievementReward">+100 PLAY</div>
  </div>

  <!-- Confetti Canvas -->
  <canvas id="confettiCanvas" class="confetti-canvas"></canvas>

  <script>
    // Game management system (auto-activate visible card)
    let currentActiveGame = null;
    const preloadedGames = new Set(); // Track preloaded games
    
    // Centralized game states (foundation for active/wait/hidden slots)
    const GAME_STATES = Object.freeze({
      HIDDEN: 'hidden',
      WAITING: 'waiting',
      ACTIVE: 'active'
    });
    const gameStateStore = new Map();
    window.MEMEPLAY_GAME_STATES = GAME_STATES;
    
    function getGameCardElement(gameId) {
      if (!gameId) return null;
      return document.getElementById(gameId) ||
             document.querySelector(`.game-card[data-game-id="${gameId}"]`);
    }
    
    function setGameState(gameId, nextState, cardRef = null) {
      if (!gameId) return;
      const validStates = GAME_STATES;
      const normalizedState = Object.values(validStates).includes(nextState)
        ? nextState
        : validStates.HIDDEN;
      const card = cardRef || getGameCardElement(gameId);
      if (!card) return;
      if (card.dataset.gameState === normalizedState) {
        gameStateStore.set(gameId, normalizedState);
        return;
      }
      card.dataset.gameState = normalizedState;
      gameStateStore.set(gameId, normalizedState);
      card.classList.toggle('state-active', normalizedState === validStates.ACTIVE);
      card.classList.toggle('state-waiting', normalizedState === validStates.WAITING);
      card.classList.toggle('state-hidden', normalizedState === validStates.HIDDEN);
    }
    
    function getGameState(gameId) {
      if (!gameId) return GAME_STATES.HIDDEN;
      return gameStateStore.get(gameId) || GAME_STATES.HIDDEN;
    }
    
    function initializeGameStates(cards = []) {
      cards.forEach((card) => {
        const gid = card?.id || card?.dataset?.gameId;
        if (gid) {
          setGameState(gid, GAME_STATES.HIDDEN, card);
        }
      });
    }
    window.setGameState = setGameState;
    window.getGameState = getGameState;
    window.initializeGameStates = initializeGameStates;
    
    // Game URLs mapping (active games only)
    const gameUrls = {
      'bird-squash': 'https://bird-squash-dev.lovable.app',
      'wojak-btc-blast': 'https://wojak-btc-blast.lovable.app',
      'moonshot-bnb': 'https://moonshot-bnb.lovable.app',
      'game-detective': 'https://game-detective-clone.lovable.app',
      'monkey-crypto-climb': 'https://monkey-crypto-climb.lovable.app',
      'crypto-arrow': 'https://crypto-arrow1.lovable.app',
      'inverse-cramer': 'https://inverse-cramer.lovable.app',
      'brick-fallen-crypto': 'games/brick-fallen-crypto/index.html',
      'pacman-memeplay': 'https://pacman-memeplay.lovable.app',
      'story-shape-studio': 'https://story-shape-studio.lovable.app',
      'pixel-space-shooter': 'games/pixel-space-shooter/index.html',
      'rocket-bnb': 'games/rocket-bnb/index.html',
      'crypto-blocks': 'games/crypto-blocks/index.html'
    };
  
    // Get all game cards in order
    function getAllGameCards() {
      const cards = Array.from(document.querySelectorAll('.game-card'))
      if (cards.length === 0) {
        console.warn('⚠️ No game cards found in DOM')
        return []
      }
      return cards
        .map(card => ({
          id: card.id || card.dataset?.gameId,
          element: card
        }))
        .filter(item => item.id)
    }
    
    // Load game iframe (helper function) - simple and fast
    function loadGameIframe(gameId) {
      const card = getGameCardElement(gameId)
      if (!card) {
        console.warn(`⚠️ loadGameIframe: Card not found for ${gameId}`)
        return false
      }
      const iframe = card.querySelector('iframe')
      if (!iframe) {
        console.warn(`⚠️ loadGameIframe: Iframe not found for ${gameId}`)
        return false
      }
      
      const targetUrl = iframe.getAttribute('data-game-url') || gameUrls[gameId]
      if (!targetUrl) {
        console.warn(`⚠️ loadGameIframe: No URL for ${gameId}`)
        return false
      }
      
      const currentSrc = iframe.src || ''
      const baseUrl = targetUrl.split('?')[0]
      const needsLoad = !currentSrc || currentSrc === '' || currentSrc.includes('about:blank') ||
                       (!currentSrc.includes(baseUrl))
      
      if (needsLoad) {
        const sep = targetUrl.includes('?') ? '&' : '?'
        const newSrc = targetUrl + sep + 'v=' + Date.now()
        iframe.src = newSrc
        console.log(`✅ [loadGameIframe] Loading iframe for ${gameId} | URL: ${newSrc.substring(0, 80)}...`)
        return true
      } else {
        // Game already loaded - this is OK, but log it for debugging
        console.log(`ℹ️ [loadGameIframe] Game ${gameId} already loaded (src: ${currentSrc.substring(0, 60)}...)`)
        return true
      }
    }
    
    // Unload game iframe
    function unloadGameIframe(gameId) {
      const card = getGameCardElement(gameId)
      if (!card) return
      const iframe = card.querySelector('iframe')
      if (iframe) {
        iframe.src = 'about:blank'
        setGameState(gameId, GAME_STATES.HIDDEN, card)
      }
    }
    
    function activateGame(gameId, isPreload = false) {
      console.log(`🚀 [activateGame] CALLED with gameId: ${gameId}, isPreload: ${isPreload}`)
      if (!gameId) {
        console.warn(`⚠️ [activateGame] gameId is null/undefined, returning early`)
        return
      }
      
      const allGames = getAllGameCards()
      console.log(`📋 [activateGame] Found ${allGames.length} total games`)
      const currentIndex = allGames.findIndex(g => g.id === gameId)
      if (currentIndex === -1) {
        console.error(`❌ [activateGame] Game ${gameId} not found in allGames (available: ${allGames.map(g => g.id).join(', ')})`)
        return
      }
      
      const totalGames = allGames.length
      
      // Calculate prev/next with circular logic
      const prevIndex = currentIndex === 0 ? totalGames - 1 : currentIndex - 1
      const nextIndex = currentIndex === totalGames - 1 ? 0 : currentIndex + 1
      
      const prevGameId = allGames[prevIndex]?.id
      const nextGameId = allGames[nextIndex]?.id
      
      // If already active, just ensure prev/next are loaded (don't reload active game)
      if (!isPreload && currentActiveGame === gameId) {
        console.log(`🔄 Game ${gameId} already active (currentActiveGame: ${currentActiveGame}), ensuring prev/next are loaded...`)
        // Ensure prev/next are loaded
        if (prevGameId) {
          const prevCard = getGameCardElement(prevGameId)
          if (prevCard) {
            setGameState(prevGameId, GAME_STATES.WAITING)
            const prevLoaded = loadGameIframe(prevGameId)
            console.log(`📦 [Already Active] Preloaded prev game: ${prevGameId} (WAITING) - Loading: ${prevLoaded}`)
          } else {
            console.error(`❌ [Already Active] Prev game card not found: ${prevGameId}`)
          }
        }
        if (nextGameId) {
          const nextCard = getGameCardElement(nextGameId)
          if (nextCard) {
            setGameState(nextGameId, GAME_STATES.WAITING)
            const nextLoaded = loadGameIframe(nextGameId)
            console.log(`📦 [Already Active] Preloaded next game: ${nextGameId} (WAITING) - Loading: ${nextLoaded}`)
          } else {
            console.error(`❌ [Already Active] Next game card not found: ${nextGameId}`)
          }
        }
        // Still log that this game is active
        console.log(`🎮 [Already Active] Game ${gameId} is ACTIVE | Prev: ${prevGameId || 'none'} | Next: ${nextGameId || 'none'}`)
        return
      }
      
      // If we reach here, this is a NEW game being activated (different from currentActiveGame)
      if (currentActiveGame && currentActiveGame !== gameId) {
        console.log(`🔄 Switching active game: ${currentActiveGame} → ${gameId}`)
      }
      
      // Games to keep loaded: active + prev + next (always 3 games)
      const gamesToKeep = [gameId, prevGameId, nextGameId].filter(Boolean)
      console.log(`🔍 [activateGame] Game ${gameId} | Index: ${currentIndex}/${totalGames} | Prev: ${prevGameId || 'none'} | Next: ${nextGameId || 'none'}`)
      console.log(`🔍 Games to keep loaded: ${gamesToKeep.join(', ')}`)
      
      // CRITICAL: Load prev and next games IMMEDIATELY and set to WAITING state
      // This ensures when user scrolls to them, they're already loaded and ready to play
      
      // Load prev game FIRST (user might scroll back)
      if (prevGameId) {
        const prevCard = getGameCardElement(prevGameId)
        if (!prevCard) {
          console.error(`❌ Prev game card not found: ${prevGameId}`)
        } else {
          // Set state FIRST, then load (so UI shows WAITING state immediately)
          setGameState(prevGameId, GAME_STATES.WAITING)
          const prevLoaded = loadGameIframe(prevGameId)
          const prevState = getGameState(prevGameId)
          console.log(`📦 [IMMEDIATE] Preloaded prev game: ${prevGameId} (WAITING state: ${prevState}) - Loading: ${prevLoaded}`)
          
          // Verify iframe is actually loading
          const prevIframe = prevCard.querySelector('iframe')
          if (prevIframe) {
            const iframeSrc = prevIframe.src || 'not set'
            console.log(`   → Prev game iframe src: ${iframeSrc.substring(0, 80)}...`)
          }
        }
      } else {
        console.warn(`⚠️ No prev game for ${gameId}`)
      }
      
      // Load next game (user will scroll to it)
      if (nextGameId) {
        const nextCard = getGameCardElement(nextGameId)
        if (!nextCard) {
          console.error(`❌ Next game card not found: ${nextGameId}`)
        } else {
          // Set state FIRST, then load (so UI shows WAITING state immediately)
          setGameState(nextGameId, GAME_STATES.WAITING)
          const nextLoaded = loadGameIframe(nextGameId)
          const nextState = getGameState(nextGameId)
          console.log(`📦 [IMMEDIATE] Preloaded next game: ${nextGameId} (WAITING state: ${nextState}) - Loading: ${nextLoaded}`)
          
          // Verify iframe is actually loading
          const nextIframe = nextCard.querySelector('iframe')
          if (nextIframe) {
            const iframeSrc = nextIframe.src || 'not set'
            console.log(`   → Next game iframe src: ${iframeSrc.substring(0, 80)}...`)
          }
        }
      } else {
        console.warn(`⚠️ No next game for ${gameId}`)
      }
      
      // Load active game
      const activeLoaded = loadGameIframe(gameId)
      setGameState(gameId, GAME_STATES.ACTIVE)
      currentActiveGame = gameId
      try { window.__memeplayActiveGame = gameId } catch {}
      document.dispatchEvent(new CustomEvent('memeplay:active-game-changed', { detail: { gameId } }))
      console.log(`🎮 Activated game: ${gameId} (ACTIVE) | Prev: ${prevGameId || 'none'} | Next: ${nextGameId || 'none'}`)
      
      // Unload all other games AFTER loading the 3 games (to prevent race condition)
      // Double-check: only unload games NOT in gamesToKeep
      // IMPORTANT: Use the same allGames array from the beginning of the function
      const allGamesToCheck = getAllGameCards()
      allGamesToCheck.forEach(game => {
        if (game.id && !gamesToKeep.includes(game.id)) {
          console.log(`🗑️ Unloading game: ${game.id} (not in keep list: ${gamesToKeep.join(', ')})`)
          unloadGameIframe(game.id)
        } else if (game.id && gamesToKeep.includes(game.id)) {
          console.log(`✅ Keeping game loaded: ${game.id} (in keep list)`)
        }
      })
    }

    // Observe which game card is visible and activate early for snappier switching
  function initGameObserver() {
    // Use more thresholds for better detection
    const thresholds = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
    const gameContainer = document.querySelector('.game-container');
    const observer = new IntersectionObserver((entries) => {
        const visible = entries.filter(e => e.isIntersecting);
        if (!visible.length) {
          console.log('👁️ Observer: No visible games')
          return
        }
        
        // Deduplicate: Keep only the entry with highest intersection ratio for each game
        const gameMap = new Map()
        visible.forEach(entry => {
          const gameId = entry.target.id
          if (!gameId) return
          
          const existing = gameMap.get(gameId)
          if (!existing || entry.intersectionRatio > existing.intersectionRatio) {
            gameMap.set(gameId, entry)
          }
        })
        
        // Convert back to array (now deduplicated)
        const visibleDeduped = Array.from(gameMap.values())

        // IMPROVED: Find the game card closest to the center of the viewport
        // This is more accurate than just using intersection ratio
        let best = null;
        let minDistanceToCenter = Infinity;
        let bestInViewport = false;
        
        // Calculate viewport center - use window center if no container
        const viewportCenter = window.innerHeight / 2;
        
        // Log all visible games with their positions for debugging (use deduplicated list)
        const visibleGamesDebug = visibleDeduped.map(e => {
          const cardRect = e.target.getBoundingClientRect();
          const cardTop = cardRect.top;
          const cardBottom = cardRect.bottom;
          const cardCenter = cardRect.top + cardRect.height / 2;
          const distanceToCenter = Math.abs(cardCenter - viewportCenter);
          const isInViewport = cardTop >= 0 && cardBottom <= window.innerHeight;
          return {
            id: e.target.id,
            ratio: (e.intersectionRatio * 100).toFixed(1) + '%',
            top: Math.round(cardTop),
            bottom: Math.round(cardBottom),
            center: Math.round(cardCenter),
            viewportCenter: Math.round(viewportCenter),
            distToCenter: Math.round(distanceToCenter) + 'px',
            isInViewport: isInViewport
          };
        });
        // Log each game on separate lines for easier reading
        console.log(`👁️ [DEBUG] Viewport center: ${Math.round(viewportCenter)}px, Found ${visibleDeduped.length} unique visible game(s) (${visible.length} total entries):`);
        visibleGamesDebug.forEach((game, idx) => {
          console.log(`   ${idx + 1}. ${game.id}: ratio=${game.ratio}, dist=${game.distToCenter}, inViewport=${game.isInViewport}, top=${game.top}, bottom=${game.bottom}`);
        });
        
        visibleDeduped.forEach(entry => {
          const cardRect = entry.target.getBoundingClientRect();
          const cardTop = cardRect.top;
          const cardBottom = cardRect.bottom;
          const cardCenter = cardRect.top + cardRect.height / 2;
          const distanceToCenter = Math.abs(cardCenter - viewportCenter);
          
          // Check if game is in viewport (fully or partially visible)
          const isInViewport = cardTop >= 0 && cardBottom <= window.innerHeight;
          const isPartiallyInViewport = cardTop < window.innerHeight && cardBottom > 0; // Any part visible
          const isMostlyInViewport = cardTop >= -100 && cardBottom <= window.innerHeight + 100;
          
          // Calculate visible height (how much of the game is actually visible)
          const visibleTop = Math.max(cardTop, 0);
          const visibleBottom = Math.min(cardBottom, window.innerHeight);
          const visibleHeight = Math.max(0, visibleBottom - visibleTop);
          const visibleRatio = visibleHeight / cardRect.height;
          
          // Prefer game with good intersection ratio
          if (entry.intersectionRatio > 0.3) {
            // CRITICAL: Prioritize distance to center FIRST, then intersection ratio
            // A game closer to center is more likely to be the one user is playing
            // Even if it has slightly lower intersection ratio
            
            if (best === null) {
              minDistanceToCenter = distanceToCenter;
              best = entry;
              bestInViewport = isInViewport;
            } else {
              // Calculate distance for current best
              const bestRect = best.target.getBoundingClientRect();
              const bestCenter = bestRect.top + bestRect.height / 2;
              const bestDistance = Math.abs(bestCenter - viewportCenter);
              
              // PRIORITY 1: If one game is MUCH closer to center (difference > 200px), choose it
              // This handles cases where a game is partially visible but closer to center
              if (distanceToCenter < bestDistance - 200) {
                // This game is significantly closer to center
                minDistanceToCenter = distanceToCenter;
                best = entry;
                bestInViewport = isInViewport;
              } else if (bestDistance < distanceToCenter - 200) {
                // Current best is significantly closer, keep it
                // Do nothing
              } else {
                // Games are similarly close to center (within 200px), prefer higher intersection ratio
                if (entry.intersectionRatio > best.intersectionRatio + 0.1) {
                  // This game has significantly higher intersection ratio
                  minDistanceToCenter = distanceToCenter;
                  best = entry;
                  bestInViewport = isInViewport;
                } else if (best.intersectionRatio > entry.intersectionRatio + 0.1) {
                  // Current best has significantly higher intersection ratio, keep it
                  // Do nothing
                } else {
                  // Similar intersection ratio, prefer one closer to center
                  if (distanceToCenter < bestDistance) {
                    minDistanceToCenter = distanceToCenter;
                    best = entry;
                    bestInViewport = isInViewport;
                  }
                }
              }
            }
          }
        });
        
        // Fallback: if no game found with good intersection, use highest intersection ratio
        if (!best) {
          best = visibleDeduped.reduce((a, b) => a.intersectionRatio >= b.intersectionRatio ? a : b);
        }
        
        const gameId = best.target.id;
        
        if (!gameId) {
          console.warn('⚠️ Observer: Game card has no ID', best.target)
          return
        }
        
        // Log all visible games for debugging (use deduplicated list)
        const visibleGames = visibleDeduped.map(e => {
          const rect = e.target.getBoundingClientRect();
          const center = rect.top + rect.height / 2;
          const dist = Math.abs(center - viewportCenter);
          return { 
            id: e.target.id, 
            ratio: (e.intersectionRatio * 100).toFixed(1) + '%',
            distToCenter: Math.round(dist) + 'px'
          };
        });
        console.log(`👁️ Observer detected ${visibleDeduped.length} unique visible game(s) (${visible.length} total entries):`, visibleGames)
        
        // Calculate final distance for logging (avoid Infinity)
        const finalDistance = isFinite(minDistanceToCenter) ? Math.round(minDistanceToCenter) : 'N/A'
        console.log(`👁️ Observer activating game: ${gameId} (intersection: ${(best.intersectionRatio * 100).toFixed(1)}%, distance to center: ${finalDistance}px, currentActiveGame: ${currentActiveGame})`)
        
        // WARNING: If rocket-bnb is not in visible list but is being played, scroll check should handle it
        if (gameId !== 'rocket-bnb' && currentActiveGame === 'rocket-bnb') {
          console.warn(`⚠️ Observer detected ${gameId} but currentActiveGame is rocket-bnb - scroll check fallback should activate rocket-bnb`)
        }
        
        // Only activate if scroll check hasn't already activated a better game
        // Scroll check runs every 200ms and is more reliable, so we only use observer as secondary
        // Check if currentActiveGame is different - if scroll check already activated a game, don't override
        if (currentActiveGame && currentActiveGame !== gameId) {
          // Scroll check may have already activated the correct game, so check distance first
          const currentGameCard = getGameCardElement(currentActiveGame)
          if (currentGameCard) {
            const currentRect = currentGameCard.getBoundingClientRect()
            const currentCenter = currentRect.top + currentRect.height / 2
            const currentDistance = Math.abs(currentCenter - (window.innerHeight / 2))
            
            const bestRect = best.target.getBoundingClientRect()
            const bestCenter = bestRect.top + bestRect.height / 2
            const bestDistance = Math.abs(bestCenter - (window.innerHeight / 2))
            
            // Only activate if observer's game is significantly closer (within 100px difference)
            if (bestDistance < currentDistance - 100) {
              console.log(`👁️ Observer overriding scroll check: ${currentActiveGame} → ${gameId} (distances: ${Math.round(currentDistance)}px vs ${Math.round(bestDistance)}px)`)
              activateGame(gameId)
            } else {
              console.log(`👁️ Observer skipping (scroll check already activated closer game: ${currentActiveGame}, distance: ${Math.round(currentDistance)}px)`)
            }
          } else {
            activateGame(gameId)
          }
        } else {
          activateGame(gameId)
        }
    }, {
        // Observe inside the snapping container (relative to container, not viewport)
        // This is important because game cards scroll within the container
        root: gameContainer || null, // Use container as root for proper intersection calculation
        rootMargin: '500px 0px 500px 0px', // Preload games 500px above/below visible area
        threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0] // More thresholds for better detection
      });

    const cards = document.querySelectorAll('.game-card')
    cards.forEach(card => {
      observer.observe(card)
      console.log(`👁️ Observing game card: ${card.id || card.dataset?.gameId}`)
    })
    console.log('✅ Game observer initialized for', cards.length, 'games')
    
    // FALLBACK: Also check scroll position to find game at center
    // This helps when IntersectionObserver misses the game
    let scrollCheckTimeout = null
    const checkScrollPosition = () => {
      try {
        if (scrollCheckTimeout) clearTimeout(scrollCheckTimeout)
        scrollCheckTimeout = setTimeout(() => {
          try {
            const viewportCenter = window.innerHeight / 2
            const allCards = Array.from(document.querySelectorAll('.game-card'))
            if (!allCards.length) return // No cards yet
            
            let closestGame = null
            let minDistance = Infinity
            
            allCards.forEach(card => {
              try {
                const rect = card.getBoundingClientRect()
                const cardCenter = rect.top + rect.height / 2
                const distance = Math.abs(cardCenter - viewportCenter)
                
                // Check if game is visible (any part in viewport)
                const isVisible = rect.top < window.innerHeight && rect.bottom > 0
                
                if (isVisible && distance < minDistance) {
                  minDistance = distance
                  closestGame = card
                }
              } catch (e) {
                console.warn('Error checking card:', e)
              }
            })
            
            if (closestGame && closestGame.id && typeof activateGame === 'function') {
              const gameId = closestGame.id
              // Only activate if different from current active game
              if (gameId !== currentActiveGame) {
                const rect = closestGame.getBoundingClientRect()
                const cardCenter = rect.top + rect.height / 2
                const distance = Math.abs(cardCenter - viewportCenter)
                console.log(`📍 [SCROLL CHECK] Found game at center: ${gameId} (distance: ${Math.round(distance)}px, currentActiveGame: ${currentActiveGame})`)
                activateGame(gameId)
              }
            }
          } catch (e) {
            console.warn('Error in scroll check:', e)
          }
        }, 100) // Debounce 100ms
      } catch (e) {
        console.warn('Error setting up scroll check:', e)
      }
    }
    
    // Check on scroll (only if container exists)
    try {
      const gameContainer = document.querySelector('.game-container')
      if (gameContainer) {
        gameContainer.addEventListener('scroll', checkScrollPosition, { passive: true })
      }
      window.addEventListener('scroll', checkScrollPosition, { passive: true })
      
      // Also check periodically (every 200ms) as PRIMARY method
      // IntersectionObserver may miss games, so this is more reliable
      setInterval(checkScrollPosition, 200)
    } catch (e) {
      console.warn('Error setting up scroll listeners:', e)
    }
  }
    
    // Dropdown nav logic
    const navDropdown = document.getElementById('navDropdown');
    const dropdownList = document.getElementById('dropdownList');
    const items = dropdownList ? dropdownList.querySelectorAll('.dropdown-item') : [];
    const searchToggleButton = document.getElementById('searchToggleButton');
    
    // Hamburger menu dropdown
    const hamburgerButton = document.getElementById('hamburgerButton');
    const hamburgerDropdown = document.getElementById('hamburgerDropdown');
    const hamburgerItems = hamburgerDropdown ? hamburgerDropdown.querySelectorAll('.dropdown-item') : [];
    
    // Creator button (direct click - no dropdown)
    const creatorButton = document.getElementById('creatorButton');

    function closeNavDropdown() {
      navDropdown.classList.remove('open');
      navDropdown.setAttribute('aria-hidden', 'true');
      searchToggleButton?.setAttribute('aria-expanded', 'false');
    }

    function closeHamburgerDropdown() {
      hamburgerDropdown?.classList.remove('open');
      hamburgerDropdown?.setAttribute('aria-hidden', 'true');
      hamburgerButton?.setAttribute('aria-expanded', 'false');
    }

    // Hamburger button click
    hamburgerButton?.addEventListener('click', (event) => {
      event.stopPropagation();
      closeNavDropdown();
      const willOpen = !hamburgerDropdown.classList.contains('open');
      if (willOpen) {
        hamburgerDropdown.classList.add('open');
        hamburgerDropdown.setAttribute('aria-hidden', 'false');
        hamburgerButton.setAttribute('aria-expanded', 'true');
      } else {
        closeHamburgerDropdown();
    }
    });

    searchToggleButton?.addEventListener('click', (event) => {
      event.stopPropagation();
      closeHamburgerDropdown();
      const willOpen = !navDropdown.classList.contains('open');
      if (willOpen) {
        navDropdown.classList.add('open');
        navDropdown.setAttribute('aria-hidden', 'false');
        searchToggleButton.setAttribute('aria-expanded', 'true');
      } else {
        closeNavDropdown();
      }
    });

    items.forEach(item => {
      item.addEventListener('click', function(e) {
        items.forEach(i => i.classList.remove('active'));
        this.classList.add('active');
        const category = this.getAttribute('data-category');
        closeNavDropdown();
        e.stopPropagation();
        
        // Apply filter based on category
        if (category) {
          // Use window.applyGameFilter since it's defined in a module
          if (typeof window.applyGameFilter === 'function') {
            window.applyGameFilter(category);
          } else {
            console.error('applyGameFilter is not available yet. Please wait for the page to load.');
          }
        }
      });
    });

    // Hamburger dropdown items
    hamburgerItems.forEach(item => {
      item.addEventListener('click', (event) => {
        event.stopPropagation();
        const action = item.getAttribute('data-action');
        switch(action) {
          case 'docs':
            window.open('docs.html', '_blank', 'noopener,noreferrer');
            break;
          case 'stats':
            if (typeof window.__openStatsOverlay === 'function') {
              window.__openStatsOverlay();
            }
            break;
        }
        closeHamburgerDropdown();
      });
    });

    // Creator button - direct click to open overlay
    creatorButton?.addEventListener('click', (event) => {
      event.stopPropagation();
      closeNavDropdown();
      closeHamburgerDropdown();
            if (typeof window.__openCreatorOverlay === 'function') {
              window.__openCreatorOverlay();
            }
    });

    document.addEventListener('click', function(e) {
      // Close dropdowns when clicking outside
      if (navDropdown.contains(e.target) || searchToggleButton.contains(e.target)) {
        closeHamburgerDropdown();
        return;
      }
      if (hamburgerDropdown?.contains(e.target) || hamburgerButton?.contains(e.target)) {
      closeNavDropdown();
        return;
      }
      // Click outside - close all
      closeNavDropdown();
      closeHamburgerDropdown();
    });
  </script>

  <!-- main.js disabled (conflicts with embedded iframes) -->

  <!-- === SUPABASE DAILY CHECK-IN & REWARD === -->

<script type="module">
  // 1️⃣ Import Supabase SDK (library for connecting to Supabase directly on web)
  import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

  // 2️⃣ Declare connection info (URL & Anon Key of your project)
  const SUPABASE_URL = 'https://iikckrcdrvnqctzacxgx.supabase.co'
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlpa2NrcmNkcnZucWN0emFjeGd4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE3Mzc3NDgsImV4cCI6MjA3NzMxMzc0OH0.nIPvf11YfFlWH0XHDZdxI496zaP431QOJCuQ-5XX4DQ'

  // 3️⃣ Create "supabase" object for using RPC, queries, insert, etc.
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

  // Global state for current filter
  let currentFilter = 'Recommended' // 'Recommended', 'Liked', 'Trending', 'Popular'
  
  // Sort games by likes (descending - highest likes first)
  async function sortGamesByLikes(cards) {
    if (!cards || cards.length === 0) return cards
    
    // Get like counts for all games in parallel
    const likeCounts = await Promise.all(
      cards.map(async (card) => {
        const gameId = card.id || card.getAttribute('data-game-id')
        if (!gameId) return { gameId: null, likes: 0 }
        
        try {
          const { data, error } = await supabase.rpc('get_social_counts', { p_game_id: gameId })
          if (error) {
            console.warn(`Failed to get likes for ${gameId}:`, error.message)
            return { gameId, likes: 0 }
          }
          return { gameId, likes: (data?.likes || 0) }
        } catch (e) {
          console.warn(`Error getting likes for ${gameId}:`, e)
          return { gameId, likes: 0 }
        }
      })
    )
    
    // Create map for quick lookup
    const likesMap = new Map(likeCounts.map(item => [item.gameId, item.likes]))
    
    // Sort cards by likes (descending)
    const sorted = [...cards].sort((a, b) => {
      const aId = a.id || a.getAttribute('data-game-id')
      const bId = b.id || b.getAttribute('data-game-id')
      const aLikes = likesMap.get(aId) || 0
      const bLikes = likesMap.get(bId) || 0
      return bLikes - aLikes // Descending order
    })
    
    console.log(`📊 Sorted ${sorted.length} games by likes (highest first)`)
    return sorted
  }
  
  // Filter games by "Liked" (user's liked games)
  // CRITICAL: Only return games that are LIKED (localStorage = '1')
  // Games that are UNLIKED or NEVER LIKED will be filtered out (hidden)
  function filterLikedGames(cards) {
    if (!cards || cards.length === 0) return cards
    
    const likedGames = cards.filter(card => {
      const gameId = card.id || card.getAttribute('data-game-id')
      if (!gameId) return false
      
      // CRITICAL: Only show games where localStorage has '1' (liked)
      // If localStorage is '0' (unliked) or null/undefined (never liked) → HIDE
      const likeStatus = localStorage.getItem('mp_like_' + gameId)
      const isLiked = likeStatus === '1'
      
      if (!isLiked) {
        console.log(`   ❌ Game ${gameId} is NOT liked (status: ${likeStatus || 'null'}) → Will be HIDDEN`)
      }
      
      return isLiked
    })
    
    console.log(`❤️ Filtered to ${likedGames.length} liked game(s) (${cards.length - likedGames.length} games will be HIDDEN)`)
    return likedGames
  }
  
  // Apply filter and reorder games
  // Make it globally accessible (for event listeners in non-module scripts)
  window.applyGameFilter = async function applyGameFilter(category) {
    const container = document.querySelector('.game-container')
    if (!container) return
    
    currentFilter = category
    console.log(`🔍 Applying filter: ${category}`)
    
    // Get all game cards
    const allCards = Array.from(container.querySelectorAll('.game-card'))
    if (allCards.length === 0) return
    
    let filteredCards = allCards
    
    // Apply filter based on category
    if (category === 'Liked') {
      // STEP 1: First, hide ALL games
      allCards.forEach(card => {
        card.style.display = 'none'
      })
      
      // STEP 2: Filter to get only liked games
      filteredCards = filterLikedGames(allCards)
      
      // STEP 3: Show ONLY liked games
      filteredCards.forEach(card => {
        const gameId = card.id || card.getAttribute('data-game-id')
        card.style.display = '' // Show liked games
        console.log(`   ✅ Game ${gameId} is LIKED → SHOW`)
      })
      
      // STEP 4: Double-check: Hide any remaining games that are NOT liked
      allCards.forEach(card => {
        const gameId = card.id || card.getAttribute('data-game-id')
        if (!gameId) {
          card.style.display = 'none'
          return
        }
        
        const likeStatus = localStorage.getItem('mp_like_' + gameId)
        const isLiked = likeStatus === '1'
        
        if (!isLiked) {
          card.style.display = 'none' // Hide unliked/never-liked games
          console.log(`   ❌ Game ${gameId} is NOT liked (status: ${likeStatus || 'null'}) → HIDE`)
        }
      })
      
      if (filteredCards.length === 0) {
        console.log('⚠️ No liked games found - all games will be HIDDEN')
      } else {
        console.log(`❤️ Showing ${filteredCards.length} liked game(s)`)
      }
    } else {
      // Show all games for other filters
      allCards.forEach(card => card.style.display = '')
    }
    
    // Sort by likes (for Recommended, Trending, Popular, and Liked)
    if (category === 'Recommended' || category === 'Trending' || category === 'Popular' || category === 'Liked') {
      // Only sort visible games (for 'Liked', this is already filteredCards)
      const cardsToSort = category === 'Liked' ? filteredCards : allCards.filter(card => card.style.display !== 'none')
      filteredCards = await sortGamesByLikes(cardsToSort)
    }
    
    // Reorder DOM elements (only visible/liked games)
    // CRITICAL: Deduplicate by gameId to prevent duplicate games
    const seenGameIds = new Set()
    const visibleCards = filteredCards.filter(card => {
      const gameId = card.id || card.getAttribute('data-game-id')
      if (!gameId) return false
      
      // Skip if we've already seen this gameId
      if (seenGameIds.has(gameId)) {
        console.warn(`⚠️ Duplicate game detected: ${gameId} - skipping`)
        return false
      }
      seenGameIds.add(gameId)
      
      // For 'Liked' filter, double-check localStorage
      if (category === 'Liked') {
        const likeStatus = localStorage.getItem('mp_like_' + gameId)
        return likeStatus === '1'
      }
      
      return card.style.display !== 'none'
    })
    
    console.log(`📋 Reordering ${visibleCards.length} unique games (${seenGameIds.size} unique gameIds)`)
    
    visibleCards.forEach((card) => {
      container.appendChild(card) // Move to end (will reorder)
    })
    
    // Reinitialize after reordering
    const newAllCards = Array.from(container.querySelectorAll('.game-card'))
    
    // CRITICAL: Remove any duplicate games by gameId (keep only the first occurrence)
    const gameIdMap = new Map()
    const duplicatesToRemove = []
    
    newAllCards.forEach((card, index) => {
      const gameId = card.id || card.getAttribute('data-game-id')
      if (!gameId) return
      
      if (gameIdMap.has(gameId)) {
        // This is a duplicate - mark for removal
        duplicatesToRemove.push(card)
        console.warn(`⚠️ Found duplicate game in DOM: ${gameId} at index ${index} - will be removed`)
      } else {
        gameIdMap.set(gameId, card)
      }
    })
    
    // Remove duplicates from DOM
    duplicatesToRemove.forEach(card => {
      card.remove()
      console.log(`🗑️ Removed duplicate game: ${card.id || card.getAttribute('data-game-id')}`)
    })
    
    // Get updated list after removing duplicates
    const finalAllCards = Array.from(container.querySelectorAll('.game-card'))
    
    // Final check: Ensure only liked games are visible when filter is 'Liked'
    if (category === 'Liked') {
      finalAllCards.forEach(card => {
        const gameId = card.id || card.getAttribute('data-game-id')
        if (!gameId) {
          card.style.display = 'none'
          return
        }
        
        const likeStatus = localStorage.getItem('mp_like_' + gameId)
        if (likeStatus !== '1') {
          card.style.display = 'none'
        }
      })
    }
    
    const visibleAllCards = finalAllCards.filter(card => card.style.display !== 'none')
    
    if (typeof window.initializeGameStates === 'function') {
      window.initializeGameStates(finalAllCards)
    }
    
    // Reinitialize observer (cards order changed)
    initGameObserver()
    
    // Auto load first game (after filter/sort) - only if there are visible games
    if (visibleAllCards.length > 0 && visibleAllCards[0]?.id) {
      const game1Id = visibleAllCards[0].id
      const game2Id = visibleAllCards[1]?.id
      
      const game1Card = getGameCardElement(game1Id)
      if (game1Card) {
        loadGameIframe(game1Id)
        setGameState(game1Id, GAME_STATES.ACTIVE)
        currentActiveGame = game1Id
        try { window.__memeplayActiveGame = game1Id } catch {}
        document.dispatchEvent(new CustomEvent('memeplay:active-game-changed', { detail: { gameId: game1Id } }))
        console.log(`🚀 Filter applied: Game 1 (${game1Id}) loaded`)
      }
      
      if (game2Id) {
        const game2Card = getGameCardElement(game2Id)
        if (game2Card) {
          setGameState(game2Id, GAME_STATES.WAITING)
          loadGameIframe(game2Id)
          console.log(`📦 Filter applied: Game 2 (${game2Id}) preloaded`)
        }
      }
      
      // Scroll to first game
      const gameContainer = document.querySelector('.game-container')
      if (game1Card && gameContainer) {
        gameContainer.style.scrollSnapType = 'none'
        gameContainer.scrollTop = 0
        game1Card.scrollIntoView({ behavior: 'smooth', block: 'start' })
        setTimeout(() => {
          gameContainer.style.scrollSnapType = 'y mandatory'
        }, 1000)
      }
    }
  }

  async function loadGameCards() {
    const container = document.querySelector('.game-container')
    if (!container) return
    try {
      const response = await fetch('games/game-list.html', { cache: 'no-cache' })
      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      const markup = await response.text()
      const parser = new DOMParser()
      const doc = parser.parseFromString(markup, 'text/html')
      const wrapper = doc.querySelector('[data-game-list]')
      container.innerHTML = wrapper ? wrapper.innerHTML : markup
      console.log('✅ Game cards loaded:', document.querySelectorAll('.game-card').length)
      initFocusControls()
      
      // 🚀 CRITICAL: Load game 1 IMMEDIATELY (don't wait for sort)
      // Get all games first (before sorting)
      const allCards = Array.from(document.querySelectorAll('.game-card'))
      
      // STEP 1: Load game 1 IMMEDIATELY (first game in DOM, before sorting)
      // This ensures user sees game immediately without waiting for sort
      const firstCardBeforeSort = allCards[0]
      const gameContainer = document.querySelector('.game-container')
      
      if (firstCardBeforeSort && firstCardBeforeSort.id) {
        const game1IdBeforeSort = firstCardBeforeSort.id
        const game2IdBeforeSort = allCards[1]?.id
        
        console.log(`🚀 [INITIAL] Loading game 1 IMMEDIATELY (before sort): ${game1IdBeforeSort}`)
        
        // Load game 1 immediately
        const game1Card = getGameCardElement(game1IdBeforeSort)
        if (game1Card) {
          loadGameIframe(game1IdBeforeSort)
          setGameState(game1IdBeforeSort, GAME_STATES.ACTIVE)
          currentActiveGame = game1IdBeforeSort
          try { window.__memeplayActiveGame = game1IdBeforeSort } catch {}
          document.dispatchEvent(new CustomEvent('memeplay:active-game-changed', { detail: { gameId: game1IdBeforeSort } }))
        }
        
        // Load game 2 (waiting)
        if (game2IdBeforeSort) {
          const game2Card = getGameCardElement(game2IdBeforeSort)
          if (game2Card) {
            setGameState(game2IdBeforeSort, GAME_STATES.WAITING)
            loadGameIframe(game2IdBeforeSort)
            console.log(`📦 [INITIAL] Game 2 preloaded: ${game2IdBeforeSort}`)
          }
        }
        
        // Scroll to first game
        if (gameContainer) {
          gameContainer.style.scrollSnapType = 'none'
          gameContainer.style.scrollBehavior = 'auto'
          gameContainer.scrollTop = 0
          requestAnimationFrame(() => {
            firstCardBeforeSort.scrollIntoView({ block: 'start' })
            setTimeout(() => {
              gameContainer.style.scrollSnapType = 'y mandatory'
              gameContainer.style.scrollBehavior = 'smooth'
            }, 500)
          })
        }
      }
      
      // STEP 2: Initialize game states
      if (typeof window.initializeGameStates === 'function') {
        window.initializeGameStates(allCards)
      } else {
        allCards.forEach(card => {
          const gid = card?.id || card?.dataset?.gameId
          if (gid) {
            card.dataset.gameState = card.dataset.gameState || 'hidden'
          }
        })
      }
      
      // STEP 3: Init observers (before sorting)
      initGameObserver()
      initSocialHandlers()
      
      // STEP 4: Handle hash navigation (from share links)
      const hash = window.location.hash.slice(1)
      if (hash && allCards.some(c => c.id === hash)) {
        console.log('🔗 Hash detected:', hash)
        setTimeout(() => {
          const targetCard = document.getElementById(hash)
          if (targetCard) {
            gameContainer.style.scrollSnapType = 'none'
            targetCard.scrollIntoView({ behavior: 'smooth', block: 'start' })
            activateGame(hash)
            setTimeout(() => {
              gameContainer.style.scrollSnapType = 'y mandatory'
            }, 1000)
          }
        }, 1000)
      }
      
      // STEP 5: MEMEPLAY logo click → Home (Game #1)
      const logoEl = document.getElementById('memeplayLogo')
      if (logoEl) {
        logoEl.addEventListener('click', () => {
          console.log('🏠 MEMEPLAY logo clicked → Go to Game #1')
          window.location.hash = ''
          const firstCard = Array.from(document.querySelectorAll('.game-card'))[0]
          if (firstCard && gameContainer) {
            gameContainer.style.scrollSnapType = 'none'
            gameContainer.scrollTop = 0
            firstCard.scrollIntoView({ behavior: 'smooth', block: 'start' })
            if (firstCard.id) activateGame(firstCard.id)
            setTimeout(() => {
              gameContainer.style.scrollSnapType = 'y mandatory'
            }, 1000)
          }
        })
      }
      
      // STEP 6: Sort games by likes in BACKGROUND (non-blocking)
      // This will reorder games, but won't interrupt user if they're already playing
      console.log('📊 [INITIAL] Starting background sort by likes...')
      sortGamesByLikes(allCards).then(sortedCards => {
        console.log('📊 [INITIAL] Sort completed, reordering games...')
        
        // Only reorder if user hasn't scrolled away from first game
        // (to avoid interrupting user experience)
        const currentActive = currentActiveGame || window.__memeplayActiveGame
        const firstAfterSort = sortedCards[0]?.id || sortedCards[0]?.getAttribute('data-game-id')
        
        // Reorder DOM
        sortedCards.forEach(card => {
          container.appendChild(card)
        })
        
        // If first game changed and user is still on first game, switch to new first
        if (firstAfterSort && firstAfterSort !== currentActive && currentActive === allCards[0]?.id) {
          console.log(`📊 [INITIAL] First game changed after sort: ${allCards[0]?.id} → ${firstAfterSort}`)
          console.log(`📊 [INITIAL] User still on first game, switching to new first...`)
          
          // Switch to new first game
          const newFirstCard = getGameCardElement(firstAfterSort)
          if (newFirstCard) {
            // Unload old first game
            if (allCards[0]?.id) {
              unloadGameIframe(allCards[0].id)
              setGameState(allCards[0].id, GAME_STATES.HIDDEN)
            }
            
            // Load new first game
            loadGameIframe(firstAfterSort)
            setGameState(firstAfterSort, GAME_STATES.ACTIVE)
            currentActiveGame = firstAfterSort
            try { window.__memeplayActiveGame = firstAfterSort } catch {}
            document.dispatchEvent(new CustomEvent('memeplay:active-game-changed', { detail: { gameId: firstAfterSort } }))
            
            // Scroll to new first game
            if (gameContainer) {
              gameContainer.style.scrollSnapType = 'none'
              gameContainer.scrollTop = 0
              newFirstCard.scrollIntoView({ behavior: 'smooth', block: 'start' })
              setTimeout(() => {
                gameContainer.style.scrollSnapType = 'y mandatory'
              }, 1000)
            }
          }
        } else {
          console.log(`📊 [INITIAL] Sort completed, but user already moved or first game unchanged`)
        }
        
        // Reinitialize after reordering
        const allCardsReordered = Array.from(document.querySelectorAll('.game-card'))
        if (typeof window.initializeGameStates === 'function') {
          window.initializeGameStates(allCardsReordered)
        }
        
        // Reinitialize observer
        initGameObserver()
      }).catch(error => {
        console.error('📊 [INITIAL] Sort failed:', error)
        // Continue with original order if sort fails
      })
      
      // Unload all other games (except game 1 and 2)
      allCards.forEach((card, idx) => {
        if (idx > 1) {
          const gid = card.id || card.dataset?.gameId
          if (gid) unloadGameIframe(gid)
        }
      })
      
    } catch (error) {
      console.error('Load game list failed:', error)
      container.innerHTML = '<div style="padding:24px;text-align:center;color:#bbb;">Unable to load games. Please refresh.</div>'
    }
  }
  
  // Load games on page load
  loadGameCards()

  function updateFocusButtons() {
    const active = document.body.classList.contains('focus-mode')
    document.querySelectorAll('.focus-toggle').forEach(btn => {
      btn.setAttribute('aria-pressed', active ? 'true' : 'false')
      btn.textContent = active ? '⤡' : '⤢'
    })
  }

  const focusState = { scrollTop: 0, gameId: null }

  function toggleFocusMode(force) {
    const next = typeof force === 'boolean' ? force : !document.body.classList.contains('focus-mode')
    document.body.classList.toggle('focus-mode', !!next)
    const container = document.querySelector('.game-container')
    if (!next) {
      if (container) {
        container.style.scrollBehavior = 'auto'
        if (focusState.gameId) {
          const card = document.getElementById(focusState.gameId)
          if (card) {
            container.scrollTop = Math.max(0, card.offsetTop - container.offsetTop)
          } else {
            container.scrollTop = Math.max(0, focusState.scrollTop)
          }
        } else {
          container.scrollTop = Math.max(0, focusState.scrollTop)
        }
        container.style.scrollBehavior = ''
      }
      clearFocusActiveCard()
    } else {
      if (container) {
        focusState.scrollTop = container.scrollTop
      }
      const fallbackId = currentActiveGame || document.querySelector('.game-card')?.id
      let focusId = window.__memeplayActiveGame || fallbackId
      if (!focusId && fallbackId) focusId = fallbackId
      if (focusId) {
        focusState.gameId = focusId
        if (!window.__memeplayActiveGame) {
          try { window.__memeplayActiveGame = focusId } catch {}
        }
        applyFocusActiveCard(focusId)
      }
      requestAnimationFrame(scrollActiveGameIntoView)
    }
    updateFocusButtons()
    
    // Notify iframes about focus mode change
    const isFocus = document.body.classList.contains('focus-mode');
    document.querySelectorAll('iframe[data-game-url*="pixel-space-shooter"]').forEach(iframe => {
      if (iframe.contentWindow) {
        iframe.contentWindow.postMessage({
          type: 'FOCUS_MODE_CHANGED',
          isFocus: isFocus
        }, '*');
      }
    });
  }

  function initFocusControls() {
    const buttons = document.querySelectorAll('.focus-toggle')
    buttons.forEach(btn => {
      if (btn.dataset.bound === '1') return
      btn.dataset.bound = '1'
      btn.addEventListener('click', (event) => {
        event.preventDefault()
        event.stopPropagation()
        const ownerCard = btn.closest('.game-card')
        if (ownerCard) {
          const gid = ownerCard.getAttribute('data-game-id') || ownerCard.id
          if (gid) {
            try { window.__memeplayActiveGame = gid } catch {}
            focusState.gameId = gid
          }
        }
        toggleFocusMode()
      })
    })
    updateFocusButtons()
  }

  function scrollActiveGameIntoView() {
    const container = document.querySelector('.game-container')
    if (!container) return
    const targetId = window.__memeplayActiveGame || currentActiveGame || container.querySelector('.game-card')?.id
    if (!targetId) return
    const card = document.getElementById(targetId)
    if (!card) return
    container.style.scrollBehavior = 'auto'
    container.scrollTop = Math.max(0, card.offsetTop - container.offsetTop)
    container.style.scrollBehavior = ''
  }

  function clearFocusActiveCard() {
    document.querySelectorAll('.game-card.is-focus-active').forEach(card => card.classList.remove('is-focus-active'))
  }

  function applyFocusActiveCard(gameId) {
    if (!gameId) return
    const card = document.getElementById(gameId)
    if (!card) return
    clearFocusActiveCard()
    card.classList.add('is-focus-active')
  }

  function lockGameTouch(gameId) {
    const stage = document.querySelector(`.game-card[data-game-id="${gameId}"] .game-stage`)
    if (!stage || stage.dataset.touchLocked === '1') return
    stage.dataset.touchLocked = '1'
    const prevent = (event) => { if (event.cancelable) event.preventDefault() }
    // Only prevent touchmove to stop scrolling, don't interfere with touchstart
    stage.addEventListener('touchmove', prevent, { passive: false, capture: true })
  }

  document.addEventListener('memeplay:active-game-changed', (event) => {
    const gameId = event?.detail?.gameId
    if (gameId) {
      try { window.__memeplayActiveGame = gameId } catch {}
      focusState.gameId = gameId
      lockGameTouch(gameId)
      if (document.body.classList.contains('focus-mode')) {
        applyFocusActiveCard(gameId)
        requestAnimationFrame(scrollActiveGameIntoView)
      }
    }
  })

  window.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && document.body.classList.contains('focus-mode')) {
      toggleFocusMode(false)
    }
  })

  await loadGameCards()
  lockGameTouch('wojak-btc-blast')

  // ✅ Supabase already initialized at top of script (before loadGameCards)

  // 🚀 Helper: Send RPC with keepalive (prevents data loss on F5/close)
  async function rpcWithKeepalive(functionName, params) {
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/${functionName}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Prefer': 'return=representation'
        },
        body: JSON.stringify(params),
        keepalive: true  // ← Ensures delivery even if page closes!
      })
      
      if (!response.ok) {
        throw new Error(`RPC ${functionName} failed: ${response.statusText}`)
      }
      
      const data = await response.json()
      return { data, error: null }
    } catch (error) {
      console.error(`rpcWithKeepalive(${functionName}) error:`, error.message)
      return { data: null, error }
    }
  }

  // =========================================================
  // 🔹 CREATE UNIQUE USER ID (stored in localStorage)
  // =========================================================
  // User identifier prefers wallet address if connected; falls back to random local id
  function generateLocalUuid() {
    try {
      const cryptoObj = globalThis.crypto || globalThis.msCrypto
      if (cryptoObj?.randomUUID) return cryptoObj.randomUUID()
      if (cryptoObj?.getRandomValues) {
        const buf = cryptoObj.getRandomValues(new Uint8Array(16))
        buf[6] = (buf[6] & 0x0f) | 0x40
        buf[8] = (buf[8] & 0x3f) | 0x80
        const hex = Array.from(buf, b => b.toString(16).padStart(2, '0')).join('')
        return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`
      }
    } catch (err) {
      console.warn('generateLocalUuid fallback', err)
    }
    const fallback = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0
      const v = c === 'x' ? r : ((r & 0x3) | 0x8)
      return v.toString(16)
    })
    return fallback
  }

  function getLocalUserId() {
    let id = localStorage.getItem('mp_user_id')
    if (!id) {
      id = 'u_' + generateLocalUuid()
      localStorage.setItem('mp_user_id', id)
    }
    return id
  }
  function getWalletAddress() {
    return localStorage.getItem('mp_user_wallet') || ''
  }
  let userId = getWalletAddress() || getLocalUserId()
  console.log('👤 Current user identifier:', userId)

  // =========================================================
  // 🔹 UI HELPERS (PLAY points header only)
  // =========================================================
  const els = {
    headerEarned: document.getElementById('headerEarned'),
    headerEarnedFlash: document.getElementById('headerEarnedFlash'),
    streak: document.getElementById('streakCount'),
    connectBtn: document.getElementById('walletConnectBtn'),
    walletBadge: document.getElementById('walletStatusBtn'),
    walletStatus: document.getElementById('walletStatusText')
  }

  function lsGetInt(key, fallback = 0) {
    const raw = localStorage.getItem(key)
    const num = raw == null ? NaN : Number(raw)
    return Number.isFinite(num) ? num : fallback
  }
  function lsSetInt(key, value) {
    localStorage.setItem(key, String(Math.max(0, Math.trunc(value))))
  }
  // No status bar counters

  function updateHeaderEarned() {
    const totalEarned = lsGetInt('mp_total_earned_plays')
    els.headerEarned && (els.headerEarned.textContent = String(totalEarned))
    if (typeof window.__updateStatsOverlay === 'function') window.__updateStatsOverlay()
  }

  // Show inline banner near PLAY points and apply increment after 3s
  // Confetti Engine
  function createConfetti() {
    const canvas = document.getElementById('confettiCanvas')
    if (!canvas) return
    const ctx = canvas.getContext('2d')
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    
    const particles = []
    const colors = ['#ffb642', '#ff9000', '#ffd700', '#ff6b6b', '#4ecdc4']
    
    for (let i = 0; i < 100; i++) {
      particles.push({
        x: canvas.width / 2,
        y: (canvas.height * 0.5) - 50, // 50px higher than toast (toast at 50%)
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 1) * 15,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: Math.random() * 8 + 4,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10
      })
    }
    
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      let active = false
      
      particles.forEach(p => {
        p.vy += 0.3 // Gravity
        p.x += p.vx
        p.y += p.vy
        p.rotation += p.rotationSpeed
        
        if (p.y < canvas.height + 50) {
          active = true
          ctx.save()
          ctx.translate(p.x, p.y)
          ctx.rotate(p.rotation * Math.PI / 180)
          ctx.fillStyle = p.color
          ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size)
          ctx.restore()
        }
      })
      
      if (active) requestAnimationFrame(animate)
      else canvas.style.opacity = '0'
    }
    
    canvas.style.opacity = '1'
    animate()
    
    setTimeout(() => {
      canvas.style.opacity = '0'
    }, 3000)
  }

  function showAchievementToast(achievementName, count, total, reward) {
    const toast = document.getElementById('achievementToast')
    const nameEl = document.getElementById('achievementName')
    const rewardEl = document.getElementById('achievementReward')
    
    if (!toast) return
    
    // ✅ "10s Play Reward" doesn't show (x/3) because it's not a 1-time achievement
    // ❌ 60s, 300s still show (x/3)
    const showProgress = achievementName !== '10s Play Reward'
    nameEl.textContent = showProgress ? `⭐ ${achievementName} (${count}/${total})` : `⭐ ${achievementName}`
    rewardEl.textContent = `+${reward} PLAY`
    
    toast.classList.add('show')
    
    // Auto-dismiss after 5s
    const autoHideTimeout = setTimeout(() => {
      toast.classList.remove('show')
    }, 5000)
    
    // Store timeout ID so X button can cancel it
    toast.dataset.autoHideTimeout = autoHideTimeout
  }
  
  // Achievement toast X button handler (close immediately)
  document.addEventListener('DOMContentLoaded', () => {
    const closeBtn = document.getElementById('achievementToastClose')
    const toast = document.getElementById('achievementToast')
    
    if (closeBtn && toast) {
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        console.log('✅ Close button clicked!');
        
        // Cancel auto-hide timeout
        if (toast.dataset.autoHideTimeout) {
          clearTimeout(parseInt(toast.dataset.autoHideTimeout))
        }
        // Hide immediately
        toast.classList.remove('show')
      }, { capture: true });
      
      // Also add touchend for mobile
      closeBtn.addEventListener('touchend', (e) => {
        e.stopPropagation();
        e.preventDefault();
        console.log('✅ Close button touched!');
        
        if (toast.dataset.autoHideTimeout) {
          clearTimeout(parseInt(toast.dataset.autoHideTimeout))
        }
        toast.classList.remove('show')
      }, { capture: true, passive: false });
    }
  })

  function celebrateAchievement(gameId, achievementName, count, reward) {
    console.log('🎯 [DEBUG] celebrateAchievement called!', { gameId, achievementName, count, reward })
    
    // 1. Fireworks explosion
    console.log('🎆 [DEBUG] Creating confetti...')
    createConfetti()
    
    // 2. Toast center
    console.log('🍞 [DEBUG] Showing achievement toast...')
    showAchievementToast(achievementName, count, 3, reward)
    
    // 3. Icon rung
    const card = document.querySelector(`.game-card[data-game-id="${gameId}"]`)
    const achievementIcon = card?.querySelector('.icon-wrapper[data-role="leaderboard"]')
    if (achievementIcon) {
      console.log('📍 [DEBUG] Shaking achievement icon...')
      achievementIcon.classList.add('shake')
      setTimeout(() => achievementIcon.classList.remove('shake'), 800)
      
    }

    const leaderboardOverlayEl = document.getElementById('leaderboardOverlay')
    if (leaderboardOverlayEl?.classList.contains('open')) {
      console.log('🏆 [DEBUG] Rendering rewards panel...')
      renderRewardsPanel(gameId)
    }
  }

  // Queue achievements to show after game over
  const pendingAchievements = {}
  let isGameOver = false // Flag to prevent showing rewards during gameplay
  
  // Show all pending achievements for a game
  // CRITICAL: Only show after game over, not during gameplay
  function showPendingAchievements(gameId) {
    // SECURITY: Only allow showing achievements after game over
    if (!isGameOver) {
      console.warn('⚠️ [SECURITY] showPendingAchievements called during gameplay - BLOCKED! Must wait for game over.')
      return
    }
    
    console.log('🔔 [DEBUG] showPendingAchievements called for:', gameId)
    console.log('🔔 [DEBUG] pendingAchievements object:', pendingAchievements)
    
    const achievements = pendingAchievements[gameId]
    console.log('🔔 [DEBUG] achievements for', gameId, ':', achievements)
    
    if (!achievements || achievements.length === 0) {
      console.log('❌ [DEBUG] No achievements to show!')
      return
    }
    
    console.log(`🎉 Showing ${achievements.length} pending achievement(s) for ${gameId}`)
    
    // Sort by threshold (10 → 60 → 300)
    achievements.sort((a, b) => a.threshold - b.threshold)
    
    // Show each achievement with delay
    achievements.forEach((ach, index) => {
      console.log(`🎊 [DEBUG] Scheduling achievement ${index + 1}:`, ach)
      setTimeout(() => {
        console.log(`🎊 [DEBUG] NOW showing achievement:`, ach.name)
        celebrateAchievement(gameId, ach.name, ach.count, ach.reward)
      }, index * 2500) // Each achievement 2.5s apart
    })
    
    // Clear queue after showing
    delete pendingAchievements[gameId]
    
    // Reset flag after showing (for next game)
    setTimeout(() => {
      isGameOver = false
    }, achievements.length * 2500 + 1000)
  }
  
  // Expose globally but with protection - games should NOT call this directly
  // Only game over handler should call this
  window.__showPendingAchievements = showPendingAchievements
  
  function showPlayAward(amount, label, isNewAchievement = false) {
    if (!amount || amount <= 0) return
    
    // Update total
    const newTotal = lsGetInt('mp_total_earned_plays') + amount
    lsSetInt('mp_total_earned_plays', newTotal)
    updateHeaderEarned()
    
    // If new achievement, QUEUE to show after game over
    if (isNewAchievement && activeGame) {
      const achievedCount = Object.values(getGameAwards(activeGame)).filter(Boolean).length
      // ✅ Rename: "Starter" → "10s Play Reward" (repeatable every time)
      const achievementNames = { 10: '10s Play Reward', 60: 'Engaged', 300: 'Champion' }
      const threshold = parseInt(label.replace('s', ''))
      
      // Add to pending queue
      if (!pendingAchievements[activeGame]) {
        pendingAchievements[activeGame] = []
      }
      pendingAchievements[activeGame].push({
        name: achievementNames[threshold],
        count: achievedCount,
        reward: amount,
        threshold
      })
      
      console.log(`🎖️ Achievement queued: ${achievementNames[threshold]} (+${amount} PLAY)`)
      console.log('   → Will show Toast after game over + Header flash NOW')
      console.log('   🔑 Queued for activeGame:', activeGame)
      console.log('   📦 Current queue:', pendingAchievements)
      // DON'T return - continue showing header flash!
    }
    
    // Header flash - ALWAYS SHOW for all rewards!
    const el = els.headerEarnedFlash
    if (!el) return
    el.textContent = `+${amount} PLAY${label ? ` for ${label}` : ''}`
    el.style.opacity = '1'
    setTimeout(() => {
      el.style.opacity = '0'
    }, 10000)
  }

  function updateStreak() {
    const streak = lsGetInt('mp_streak_count')
    els.streak && (els.streak.textContent = String(streak))
    if (typeof window.__updateStatsOverlay === 'function') window.__updateStatsOverlay()
  }

  // Initialize UI from localStorage
  updateHeaderEarned()
  updateStreak()

  // Load initial real play counts for all cards
  document.querySelectorAll('.game-card').forEach(card => {
    const gid = card.getAttribute('data-game-id') || card.id
    if (gid) {
      loadPlayCount(gid)
    }
  })

  // ==============================
  // Wallet Connect (MetaMask)
  // ==============================
  function shortAddr(addr) {
    if (!addr) return ''
    const lower = String(addr).toLowerCase()
    if (lower.length <= 6) return lower
    return `${lower.slice(0, 3)}...${lower.slice(-3)}`
  }
  function setWalletStatus(addr) {
    if (!els.walletStatus) return
    els.walletStatus.textContent = addr ? `connected :${shortAddr(addr)}` : ''
    if (typeof window.__updateWalletOverlay === 'function') window.__updateWalletOverlay()
  }
  setWalletStatus(getWalletAddress())

  async function connectWallet() {
    if (!window.ethereum) {
      const ua = navigator.userAgent || ''
      const isMobile = /iphone|ipad|ipod|android/i.test(ua)
      if (isMobile) {
        const rawUrl = window.location.href.split('#')[0]
        const cleaned = rawUrl.replace(/^https?:\/\//i, '')
        const deepLink = `https://metamask.app.link/dapp/${cleaned}`
        const proceed = confirm('MetaMask mobile not opened. Open MetaMask app to connect?')
        if (proceed) {
          window.location.href = deepLink
        }
      } else {
        alert('Please install MetaMask to connect your wallet.')
      }
      return
    }
    try {
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })
      const address = (accounts && accounts[0]) ? String(accounts[0]) : ''
      if (!address) return
      localStorage.setItem('mp_user_wallet', address)
      userId = address // prefer wallet as identifier
      setWalletStatus(address)
      setConnectButtonState()
      // Do not auto re-checkin on wallet switch; guard by daily window
      if (!hasCheckedInToday()) {
        try { await dailyCheckin() } catch {}
      }
    } catch (e) {
      console.warn('Wallet connect failed:', e?.message || e)
    }
  }
  function disconnectWallet() {
    localStorage.removeItem('mp_user_wallet')
    userId = getLocalUserId()
    setWalletStatus('')
    setConnectButtonState()
  }
  function ensureWalletBindings() {
    const connectBtn = els.connectBtn
    const statusBtn = els.walletBadge
    if (connectBtn && !connectBtn.__memeplayBound) {
      connectBtn.addEventListener('click', (event) => {
        event.preventDefault()
        connectWallet()
      })
      connectBtn.__memeplayBound = true
    }
    if (statusBtn && !statusBtn.__memeplayBound) {
      statusBtn.addEventListener('click', () => {
        if (typeof window.__openWalletOverlay === 'function') {
          window.__openWalletOverlay()
        }
      })
      statusBtn.__memeplayBound = true
    }
  }
  function setConnectButtonState() {
    if (!els.connectBtn || !els.walletBadge) return
    const address = getWalletAddress()
    const isConnected = !!address

    if (isConnected) {
      els.connectBtn.hidden = true
      els.walletBadge.hidden = false
      els.walletStatus.textContent = `connected :${shortAddr(address)}`
      ensureWalletBindings()
    } else {
      els.connectBtn.hidden = false
      els.walletBadge.hidden = true
      ensureWalletBindings()
    }
  }
  const walletApi = {
    connect: () => connectWallet(),
    disconnect: () => disconnectWallet(),
    isConnected: () => !!getWalletAddress(),
    getAddress: () => getWalletAddress(),
    getStreak: () => lsGetInt('mp_streak_count'),
    getPlayPoints: () => lsGetInt('mp_total_earned_plays'),
    openOverlay: () => {
        if (typeof window.__openWalletOverlay === 'function') {
          window.__openWalletOverlay()
        }
      }
    }
  try {
    const existing = (globalThis.memeplayWallet && typeof globalThis.memeplayWallet === 'object') ? globalThis.memeplayWallet : {}
    globalThis.memeplayWallet = Object.assign({}, existing, walletApi)
  } catch {
    globalThis.memeplayWallet = walletApi
  }
  ensureWalletBindings()
  els.connectBtn && setConnectButtonState()
  if (window.ethereum) {
    window.ethereum.on?.('accountsChanged', (accs) => {
      const addr = (accs && accs[0]) ? String(accs[0]) : ''
      if (addr) {
        localStorage.setItem('mp_user_wallet', addr)
        userId = addr
        setWalletStatus(addr)
      } else {
        localStorage.removeItem('mp_user_wallet')
        userId = getLocalUserId()
        setWalletStatus('')
      }
      setConnectButtonState()
    })
  }

  // =========================================================
  // 🔹 PER-GAME ACCUMULATED PLAYTIME & ONE-TIME REWARDS
  // =========================================================
  const REWARD_THRESHOLDS = [10, 60, 300] // seconds (10s so user quickly understands rewards)
  const REWARD_VALUES = { 10: 100, 60: 300, 300: 1000 }
  const MAX_ACCUM_SECONDS = 300

  function getGameSeconds(gameId) {
    return lsGetInt(`mp_game_seconds_${gameId}`)
  }
  function setGameSeconds(gameId, seconds) {
    lsSetInt(`mp_game_seconds_${gameId}`, Math.min(seconds, MAX_ACCUM_SECONDS))
  }
  function getGameAwards(gameId) {
    try {
      const raw = localStorage.getItem(`mp_game_awards_${gameId}`)
      return raw ? JSON.parse(raw) : {}
    } catch {
      return {}
    }
  }
  function setGameAwards(gameId, awardsObj) {
    localStorage.setItem(`mp_game_awards_${gameId}`, JSON.stringify(awardsObj || {}))
  }
  // Console helpers
  function listAllGameSeconds() {
    const cards = Array.from(document.querySelectorAll('.game-card'))
    const rows = cards.map(c => {
      const id = c.getAttribute('data-game-id') || c.id || 'unknown'
      return { gameId: id, seconds: getGameSeconds(id) }
    })
    console.table(rows)
    return rows
  }
  function resetGameProgress(gameId) {
    if (!gameId) return false
    lsSetInt(`mp_game_seconds_${gameId}`, 0)
    localStorage.removeItem(`mp_game_awards_${gameId}`)
    console.log(`🔄 Reset progress for ${gameId}`)
    return true
  }
  // Expose to window for activation script and dev console usage
  const helpers = Object.freeze({
    // inspectors
    getGameSeconds,
    listAllGameSeconds,
    resetGameProgress,
    // controls
    startGame,
    stopGame,
    forceStart
  })
  try { window.memeplay = helpers } catch {}
  try { self.memeplay = helpers } catch {}
  try { globalThis.memeplay = helpers } catch {}
  console.log('🧩 memeplay helpers ready:', Object.keys(helpers))
  function grantPlays(amount) {
    if (!amount || amount <= 0) return 0
    const newTotal = lsGetInt('mp_total_earned_plays') + amount
    lsSetInt('mp_total_earned_plays', newTotal)
    updateHeaderEarned()
    return amount
  }

  // ===== Real play counts (per game) =====
  function setPlaysLabelForCard(gameId, totalPlays) {
    const card = document.querySelector(`.game-card[data-game-id="${gameId}"]`) || document.getElementById(gameId)
    if (!card) return
    const creator = card.querySelector('.creator-text')
    if (!creator) return
    let span = creator.querySelector('[data-plays-count]')
    if (!span) {
      // insert separator dot and span once
      const sep = document.createTextNode(' • ')
      span = document.createElement('span')
      span.setAttribute('data-plays-count', gameId)
      creator.appendChild(sep)
      creator.appendChild(span)
    }
    span.textContent = `${totalPlays} plays`

    const statsCount = card.querySelector('.icon-wrapper[data-role="stats"] .icon-count')
    if (statsCount) statsCount.textContent = String(Math.max(0, totalPlays|0))
  }
  async function loadPlayCount(gameId) {
    try {
      console.log('📥 [PLAYS] loadPlayCount →', gameId)
      const { data, error } = await supabase.rpc('get_game_play_count', { p_game_id: gameId })
      if (error) { console.error('get_game_play_count error:', error.message); return }
      const val = (data && typeof data.total_plays === 'number') ? data.total_plays : 0
      setPlaysLabelForCard(gameId, val)
      console.log(`[plays] ${gameId}:`, val)
    } catch (e) { console.error('get_game_play_count error:', e?.message || e) }
  }
  async function incrementPlayCountIfEligible(gameId, seconds) {
    if (!gameId || !seconds || seconds < 5) return
    try {
      const { data, error } = await supabase.rpc('increment_play_count', {
        p_user_id: userId,
        p_game_id: gameId,
        p_seconds: seconds
      })
      if (error) { console.error('increment_play_count error:', error.message); return }
      const val = (data && typeof data.total_plays === 'number') ? data.total_plays : undefined
      if (val != null) {
        setPlaysLabelForCard(gameId, val)
        console.log(`[plays +1] ${gameId}:`, val)
      }
    } catch (e) {
      console.error('increment_play_count error:', e?.message || e)
    }
  }

  // =========================================================
  // 🔹 DAILY CHECK-IN (guarded once per day per device)
  // =========================================================
  function todayKey() {
    const d = new Date()
    return d.toISOString().slice(0,10)
  }
  function hasCheckedInToday() {
    return localStorage.getItem('mp_checkin_'+todayKey()) === '1'
  }
  function markCheckedInToday() {
    localStorage.setItem('mp_checkin_'+todayKey(), '1')
  }
  // Show daily check-in toast with stats
  function showDailyCheckInToast(streak, reward, totalDays = null) {
    // Remove old toast if exists
    const oldToast = document.querySelector('.daily-checkin-toast');
    if (oldToast) oldToast.remove();
    
    // Create toast element
    const toast = document.createElement('div');
    toast.className = 'daily-checkin-toast';
    
    // Build stats HTML
    let statsHTML = `
      <div class="daily-checkin-stat">
        <span class="daily-checkin-stat-value">${streak}</span>
        <span class="daily-checkin-stat-label">🔥 Day Streak</span>
      </div>
    `;
    
    // Add total days if available
    if (totalDays && totalDays > 0) {
      statsHTML += `
        <div class="daily-checkin-stat">
          <span class="daily-checkin-stat-value">${totalDays}</span>
          <span class="daily-checkin-stat-label">📅 Total Days</span>
        </div>
      `;
    }
    
    toast.innerHTML = `
      <div class="daily-checkin-icon">🎁</div>
      <div class="daily-checkin-title">Daily Check-in!</div>
      <div class="daily-checkin-stats">
        ${statsHTML}
      </div>
      <div class="daily-checkin-reward">+${reward} PLAY</div>
    `;
    
    document.body.appendChild(toast);
    
    // Show toast
    setTimeout(() => toast.classList.add('show'), 100);
    
    // Hide after 5 seconds
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 500);
    }, 5000);
  }

  async function dailyCheckin() {
    const { data, error } = await supabase.rpc('daily_checkin', { p_user_id: userId })
    if (error) {
      console.error('❌ Daily check-in error:', error.message)
      return
    }
    console.log('✅ Daily check-in result:', data)
    if (data?.awarded > 0) {
      // Show new daily check-in toast
      const streak = Number(data.streak) || 1;
      const totalDays = Number(data.total_days) || null; // If backend provides it
      showDailyCheckInToast(streak, Number(data.awarded), totalDays);
      
      // Still update header (small notification)
      showPlayAward(Number(data.awarded), 'daily login')
      markCheckedInToday()
    }
    if (Number.isFinite(data?.streak)) {
      lsSetInt('mp_streak_count', Number(data.streak))
      updateStreak()
    }
  }

  // Only run on first load if not already checked in today (prevents wallet-switch abuse)
  if (!hasCheckedInToday()) dailyCheckin()
// ==============================
//  AUTO-TRACK PLAYTIME + FOCUS DELAY
// ==============================

// Global variable to track running game
let activeGame = null;
let activeStartTime = 0;
let progressInterval = null;

// Start timer
function startGame(gameId) {
  // If another game is running, stop it; if same game, reset ticker/time
  if (activeGame && activeGame !== gameId) stopGame();

  // Reset ticker before starting (even for same game)
  clearInterval(progressInterval);
  progressInterval = null;

  activeGame = gameId;
  activeStartTime = Date.now();
  console.log(`▶️ Game ${gameId} started`);
  
  // Mark game card as playing to disable animations/transitions
  document.querySelectorAll('.game-card').forEach(card => card.classList.remove('is-playing'));
  const activeCard = document.querySelector(`.game-card[data-game-id="${gameId}"]`);
  if (activeCard) activeCard.classList.add('is-playing');

  // Live progress ticker: log session and cumulative totals every 5 seconds (optimized for performance)
  clearInterval(progressInterval);
  progressInterval = setInterval(() => {
    if (!activeGame || !activeStartTime) return;
    
    // Use requestIdleCallback to avoid interrupting game
    if (window.requestIdleCallback) {
      window.requestIdleCallback(() => {
        updateProgress();
      }, { timeout: 1000 });
    } else {
      updateProgress();
    }
  }, 5000);
  
  function updateProgress() {
    if (!activeGame || !activeStartTime) return;
    const sessionSeconds = Math.max(0, Math.floor((Date.now() - activeStartTime) / 1000));
    const prevTotal = getGameSeconds(activeGame);
    const previewTotal = Math.min(prevTotal + sessionSeconds, MAX_ACCUM_SECONDS);

    // Early reward grant when crossing thresholds during play
    const awardedMap = getGameAwards(activeGame);
    const crossedNow = [];
    for (const t of REWARD_THRESHOLDS) {
      if (prevTotal < t && previewTotal >= t && !awardedMap[t]) {
        awardedMap[t] = true;
        crossedNow.push(t);
      }
    }
    if (crossedNow.length) {
      setGameAwards(activeGame, awardedMap);
      let grant = 0;
      for (const t of crossedNow) grant += REWARD_VALUES[t];
      if (grant > 0) {
        const last = crossedNow[crossedNow.length - 1]
        showPlayAward(grant, `${last}s`, true) // ← true = NEW achievement!
      }
    }

    console.log(`⏳ ${activeGame}: session ${sessionSeconds}s · total ${previewTotal}/${MAX_ACCUM_SECONDS}s`);
  }
}

// Force safe start when switching games
function forceStart(gameId) {
  try { stopGame(); } catch {}
  clearInterval(progressInterval);
  progressInterval = null;
  activeGame = null;
  activeStartTime = 0;
  startGame(gameId);
}

  // Stop timer + send data to Supabase
async function stopGame() {
  if (!activeGame || !activeStartTime) return;

    const seconds = Math.floor((Date.now() - activeStartTime) / 1000);
  if (seconds > 0) {
      // Optimistic UI bump (visible immediately), will be corrected after server refresh
      try {
        if (seconds >= 3) {
          const card = document.querySelector(`.game-card[data-game-id="${activeGame}"]`) || document.getElementById(activeGame)
          const creator = card?.querySelector('.creator-text')
          if (creator) {
            const span = creator.querySelector('[data-plays-count]')
            if (span && /\d+/.test(span.textContent || '')) {
              const cur = parseInt((span.textContent || '0').replace(/\D/g, ''), 10) || 0
              span.textContent = `${cur + 1} plays`
            }
          }
          const statsCount = card?.querySelector('.icon-wrapper[data-role="stats"] .icon-count')
          if (statsCount && /\d+/.test(statsCount.textContent || '')) {
            const cur = parseInt((statsCount.textContent || '0').replace(/\D/g, ''), 10) || 0
            statsCount.textContent = String(cur + 1)
          }
        }
      } catch {}
    console.log(`⏱ Played ${seconds}s on ${activeGame}`);

    // Calculate per-game accumulated time and threshold rewards
    const prevTotal = getGameSeconds(activeGame)
    const nextTotalRaw = prevTotal + seconds
    const prevCapped = Math.min(prevTotal, MAX_ACCUM_SECONDS)
    const nextCapped = Math.min(nextTotalRaw, MAX_ACCUM_SECONDS)
    setGameSeconds(activeGame, nextCapped)

    const awardedMap = getGameAwards(activeGame)
    const newlyAwarded = []
    for (const t of REWARD_THRESHOLDS) {
      if (prevCapped < t && nextCapped >= t && !awardedMap[t]) {
        awardedMap[t] = true
        newlyAwarded.push(t)
      }
    }
    console.log(`📈 Accumulated for ${activeGame}: ${nextCapped}s (was ${prevCapped}s)`) 
    if (newlyAwarded.length) {
      let totalGrant = 0
      for (const t of newlyAwarded) totalGrant += REWARD_VALUES[t]
      setGameAwards(activeGame, awardedMap)
      if (totalGrant > 0) {
        const last = newlyAwarded[newlyAwarded.length - 1]
        showPlayAward(totalGrant, `${last}s`, true) // ← true = NEW achievement!
      }
    }

    // Use keepalive to prevent data loss on F5/close tab
    try {
      const { data, error } = await rpcWithKeepalive('track_playtime_and_reward', {
        p_user_id: userId,
        p_game_id: activeGame,
        p_seconds: seconds
      });
      if (error) throw error;
      console.log(`🎮 [${activeGame}] reward result:`, data);
      
      // ❌ REMOVED: Backend reward display (duplicate with frontend achievement system!)
      // Frontend already handles rewards via threshold checking (line ~2356)
      // Backend RPC just saves to DB, no need to show notification again!
      // if (data?.awarded > 0) showPlayAward(Number(data.awarded))
    } catch (err) {
      console.error('Playtime tracking error:', err.message);
    }

    // Increment real play count if eligible with keepalive
    if (seconds >= 3) {
      try {
        // 🔁 Legacy games: always send a fixed 3s to ensure exactly +1 play per full session
        // (backend may derive plays from seconds, e.g. floor(seconds / 3))
        const secondsForRpc = isLegacyGame(activeGame) ? 3 : seconds;
        const payload = {
          p_user_id: userId,
          p_game_id: activeGame,
          p_seconds: secondsForRpc
        };
        console.log('📈 [PLAYS] increment_play_count (stopGame) →', payload);
        let { data, error } = await rpcWithKeepalive('increment_play_count', payload);
        if (error) throw error;
        
        // Update UI after server confirms (accurate count)
        if (data && typeof data.total_plays === 'number') {
          setPlaysLabelForCard(activeGame, data.total_plays)
          console.log(`📊 [plays +1] ${activeGame}: ${data.total_plays}`)
          try { loadPlayCount(activeGame) } catch {}
        }
      } catch (err) {
        console.error('Play count increment error:', err.message);
        // If backend already counted (409 Conflict), just refresh UI from server
        const msg = String(err?.message || '');
        if (msg.includes('409') || msg.toLowerCase().includes('conflict')) {
          try { await loadPlayCount(activeGame) } catch {}
        } else {
          // Retry once after a short delay
          try {
            await new Promise(r => setTimeout(r, 800));
            const retryPayload = {
              p_user_id: userId,
              p_game_id: activeGame,
              p_seconds: seconds
            };
            console.log('📈 [PLAYS] increment_play_count RETRY →', retryPayload);
            const { data, error } = await rpcWithKeepalive('increment_play_count', retryPayload);
            if (!error && data && typeof data.total_plays === 'number') {
              setPlaysLabelForCard(activeGame, data.total_plays)
              console.log(`📊 [plays +1 retry] ${activeGame}: ${data.total_plays}`)
              try { loadPlayCount(activeGame) } catch {}
            } else {
              try { await loadPlayCount(activeGame) } catch {}
            }
          } catch (e2) {
            console.error('Play count retry failed:', e2.message);
            try { await loadPlayCount(activeGame) } catch {}
          }
        }
      }
    }
  }

  // Remove any stray global refresh (handled inside stopGame now)

  // Remove is-playing class to re-enable animations
  document.querySelectorAll('.game-card').forEach(card => card.classList.remove('is-playing'));
  
  activeGame = null;
  activeStartTime = 0;
  clearInterval(progressInterval);
  progressInterval = null;
}

// When iframe finishes loading game → start tracking with delay
const iframes = document.querySelectorAll(".game-card iframe");
const fallbackTimers = {} // Track fallback timers for games without postMessage
window.fallbackTimers = fallbackTimers // Expose globally for GAME_SCORE handler

if (iframes && iframes.length) {
iframes.forEach((iframe) => {
  const gameId = iframe.closest(".game-card")?.dataset.gameId;
  if (!gameId) {
    console.warn("⚠️ Missing data-game-id for an iframe, tracking skipped.");
    return;
  }

  iframe.addEventListener("load", () => {
    // DON'T auto-start timer when iframe loads!
    // Timer only starts when user ACTUALLY plays (via GAME_SCORE message)
    console.log(`✅ Iframe loaded: ${gameId} (timer will start when user plays)`);
  });
  
  // 🔧 FALLBACK: Detect click on .game-stage (iframe wrapper)
  const gameStage = iframe.closest('.game-stage')
  if (gameStage) {
    gameStage.addEventListener('click', () => {
      console.log(`🖱️ [FALLBACK] User clicked game: ${gameId}`)
      
      // Clear previous fallback timer
      if (fallbackTimers[gameId]) {
        clearTimeout(fallbackTimers[gameId])
      }
      
      // If timer already running → skip
      if (activeGame === gameId && activeStartTime) {
        console.log(`⏭️ [FALLBACK] Timer already running for ${gameId}`)
        return
      }
      
      // Wait 2 seconds, if no GAME_SCORE → start timer
      fallbackTimers[gameId] = setTimeout(() => {
        if (activeGame !== gameId || !activeStartTime) {
          console.log(`⚠️ [FALLBACK] No GAME_SCORE after 2s → Auto-starting timer for ${gameId}`)
          startGame(gameId)
      }
      }, 2000)
    }, { passive: true })
  }
});
}

// Stop when tab hidden
document.addEventListener("visibilitychange", () => {
  if (document.hidden) {
    stopGame();
  } else if (activeGame && gameStartTime) {
    // ✅ ONLY resume timer if game IS PLAYING (has gameStartTime)
    // ❌ DON'T auto-start if only activeGame exists (haven't clicked play)
    startGame(activeGame);
  }
});

// Stop when leaving page
window.addEventListener("beforeunload", stopGame);

  // ==============================
  // Likes & Comments (Supabase RPC)
  // ==============================
  function initSocialHandlers() {
    // Global overlay controller (single instance handlers)
    const overlay = document.getElementById('commentsOverlay')
    const listEl = document.getElementById('commentsList')
    const loadMoreBtn = document.getElementById('commentsLoadMore')
    const closeBtn = document.getElementById('commentsCloseBtn')
    const ta = document.getElementById('commentsTextarea')
    const postBtn = document.getElementById('commentsPostBtn')

    const paging = { gameId: null, offset: 0, limit: 10, loading: false, done: false }
    function shortAddr10(addr){ if(!addr) return ''; return addr.slice(0,6) + '…' + addr.slice(-3) }
    async function fetchMore(){
      if (paging.loading || paging.done || !paging.gameId) return
      paging.loading = true
      try {
        const { data, error } = await supabase.rpc('list_comments', {
          p_game_id: paging.gameId,
          p_limit: paging.limit,
          p_offset: paging.offset
        })
        if (error) throw error
        const rows = Array.isArray(data) ? data : []
        if (rows.length === 0) { paging.done = true; return }
        rows.forEach(r => {
          const item = document.createElement('div')
          item.className = 'comment-item'
          const meta = document.createElement('div')
          meta.className = 'comment-meta'
          const when = new Date(r.created_at).toLocaleString()
          meta.textContent = `${shortAddr10(r.user_id)} • ${when}`
          const text = document.createElement('div')
          text.className = 'comment-text'
          text.textContent = r.text
          item.appendChild(meta)
          item.appendChild(text)
          listEl.appendChild(item)
        })
        paging.offset += rows.length
        
        // ✅ Update comment count after loading comments
        const card = document.querySelector(`.game-card[data-game-id="${paging.gameId}"]`)
        if (card) {
          const cmtWrapper = card.querySelector('.icon-wrapper[data-role="comment"]')
          const cmtCountEl = cmtWrapper?.querySelector('.icon-count')
          if (cmtCountEl && paging.offset > 0) {
            // Only update if current count = 0 (wrong) but actually has comments
            const currentCount = parseInt(cmtCountEl.textContent) || 0
            if (currentCount === 0) {
              cmtCountEl.textContent = String(paging.offset)
              console.log('[COMMENT DEBUG] fetchMore - Fixed count from 0 to', paging.offset)
            }
          }
        }
      } catch(e){
        console.error('list_comments error:', e?.message || e)
      } finally { paging.loading = false }
    }
    async function openPanel(forGame){
      paging.gameId = forGame
      paging.offset = 0
      paging.loading = false
      paging.done = false
      listEl.innerHTML = ''
      ta.value = ''
      overlay.classList.add('open')
      
      // ✅ Load comments and update count based on actual data
      await fetchMore()
      
      // Update comment count based on loaded comments
      try {
        const { data, error } = await supabase.rpc('get_social_counts', { p_game_id: forGame })
        console.log('[COMMENT DEBUG] openPanel - Refreshing counts for', forGame, ':', data)
        if (!error && data) {
          const card = document.querySelector(`.game-card[data-game-id="${forGame}"]`)
          if (card) {
            const cmtWrapper = card.querySelector('.icon-wrapper[data-role="comment"]')
            const cmtCountEl = cmtWrapper?.querySelector('.icon-count')
            if (cmtCountEl) {
              const realCount = data.comments ?? 0
              cmtCountEl.textContent = String(Math.max(0, realCount))
              console.log('[COMMENT DEBUG] openPanel - Updated count to', realCount)
            }
          }
        }
      } catch (e) {
        console.error('[COMMENT DEBUG] openPanel - Error refreshing count:', e)
      }
    }
    loadMoreBtn.onclick = fetchMore
    closeBtn.onclick = () => overlay.classList.remove('open')
    
    // Click outside to close (desktop only)
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        overlay.classList.remove('open')
      }
    })
    
    postBtn.onclick = async () => {
      const text = (ta.value || '').trim()
      if (!text || !paging.gameId) return
      postBtn.disabled = true
      try {
        const { data, error } = await supabase.rpc('add_comment', {
      p_user_id: userId,
          p_game_id: paging.gameId,
          p_text: text
        })
        if (error) throw error
        const item = document.createElement('div')
        item.className = 'comment-item'
        const meta = document.createElement('div')
        meta.className = 'comment-meta'
        meta.textContent = `${shortAddr10(userId)} • just now`
        const body = document.createElement('div')
        body.className = 'comment-text'
        body.textContent = text
        item.appendChild(meta)
        item.appendChild(body)
        listEl.prepend(item)
        ta.value = ''
        
        // ✅ Refresh comment count after successful post!
        console.log('[COMMENT DEBUG] Comment posted! Refreshing count for', paging.gameId)
        const card = document.querySelector(`.game-card[data-game-id="${paging.gameId}"]`)
        if (card) {
          const cmtWrapper = card.querySelector('.icon-wrapper[data-role="comment"]')
          const cmtCountEl = cmtWrapper?.querySelector('.icon-count')
          if (cmtCountEl) {
            const currentCount = parseInt(cmtCountEl.textContent) || 0
            cmtCountEl.textContent = String(currentCount + 1)
            console.log('[COMMENT DEBUG] Updated count from', currentCount, 'to', currentCount + 1)
          }
        }
      } catch(e){
        console.error('add_comment error:', e?.message || e)
      } finally { postBtn.disabled = false }
    }

    const cards = document.querySelectorAll('.game-card')
    cards.forEach(card => {
      const gameId = card.getAttribute('data-game-id') || card.id
      if (!gameId) return

      const likeWrapper = card.querySelector('.icon-wrapper[data-role="like"]')
      const commentWrapper = card.querySelector('.icon-wrapper[data-role="comment"]')
      const shareWrapper = card.querySelector('.icon-wrapper[data-role="share"]')
      const leaderboardWrapper = card.querySelector('.icon-wrapper[data-role="leaderboard"]')
      const marketcapWrapper = card.querySelector('.icon-wrapper[data-role="marketcap"]')

      const likeBtn = likeWrapper?.querySelector('button')
      const commentBtn = commentWrapper?.querySelector('button')
      const shareBtn = shareWrapper?.querySelector('button')
      const leaderboardBtn = leaderboardWrapper?.querySelector('button')
      const marketcapBtn = marketcapWrapper?.querySelector('button')

      if (!likeBtn || !commentBtn) return

      const ensureCountEl = (wrapper, selector, fallback = '0') => {
        if (!wrapper) return null
        const existing = wrapper.querySelector(selector)
        if (existing) return existing
        const span = document.createElement('span')
        span.className = 'icon-count'
        span.textContent = fallback
        wrapper.appendChild(span)
        return span
      }

      const likeCountEl = ensureCountEl(likeWrapper, '.icon-count')
      const cmtCountEl = ensureCountEl(commentWrapper, '.icon-count')

      function setCounts(likes, comments) {
        if (likeCountEl) likeCountEl.textContent = String(Math.max(0, likes|0))
        if (cmtCountEl) cmtCountEl.textContent = String(Math.max(0, comments|0))
      }
      function renderHeart(isLiked) {
        const wrapper = likeBtn.closest('.icon-wrapper')
        if (wrapper) {
          wrapper.classList.toggle('liked', !!isLiked)
          console.log(`❤️ [LIKE DEBUG] ${gameId} - renderHeart(${isLiked}) → wrapper.classList.liked = ${wrapper.classList.contains('liked')}`)
        }
        likeBtn.setAttribute('aria-pressed', isLiked ? 'true' : 'false')
        console.log(`❤️ [LIKE DEBUG] ${gameId} - renderHeart(${isLiked}) → aria-pressed = ${likeBtn.getAttribute('aria-pressed')}`)
      }
      
      // Load initial like status from localStorage and Supabase
      ;(async () => {
        try {
          // First, check localStorage
          const localLiked = localStorage.getItem('mp_like_' + gameId) === '1'
          console.log(`❤️ [LIKE DEBUG] ${gameId} - Initial load: localStorage = ${localLiked}`)
          
          // Then, sync with Supabase to get accurate counts
          const { data, error } = await supabase.rpc('get_social_counts', { p_game_id: gameId })
          console.log(`❤️ [LIKE DEBUG] ${gameId} - get_social_counts RPC response:`, { data, error })
          
          if (!error && data) {
            console.log(`❤️ [LIKE DEBUG] ${gameId} - Setting counts:`, { likes: data.likes ?? 0, comments: data.comments ?? 0 })
            setCounts(data.likes ?? 0, data.comments ?? 0)
          }
          
          // Render based on localStorage (will be synced with Supabase on first click)
          // Note: We don't check Supabase here to avoid unnecessary API calls
          // The first click will sync localStorage with Supabase
          renderHeart(localLiked)
        } catch (e) {
          console.error(`❤️ [LIKE DEBUG] ${gameId} - Error loading initial state:`, e)
          // Fallback to localStorage
          const localLiked = localStorage.getItem('mp_like_' + gameId) === '1'
          renderHeart(localLiked)
        }
      })()
      
      likeBtn.addEventListener('click', async () => {
        const beforeState = localStorage.getItem('mp_like_' + gameId) === '1'
        console.log(`❤️ [LIKE DEBUG] ${gameId} - LIKE BUTTON CLICKED!`)
        console.log(`   → Before: localStorage = ${beforeState}, userId = ${userId}`)
        
        likeBtn.disabled = true
        
        try {
          console.log(`   → Calling toggle_like RPC...`)
          const { data, error } = await supabase.rpc('toggle_like', {
            p_user_id: userId,
            p_game_id: gameId
          })
          
          console.log(`   → RPC Response:`, { data, error })
          
          if (error) {
            console.error(`   ❌ RPC Error:`, error)
            throw error
          }
          
          const isLiked = !!(data && (data.is_liked ?? data.liked))
          const totalLikes = (data && (data.total_likes ?? data.likes)) ?? 0
          
          console.log(`   → Parsed: isLiked = ${isLiked}, totalLikes = ${totalLikes}`)
          
          // Update localStorage
          localStorage.setItem('mp_like_' + gameId, isLiked ? '1' : '0')
          console.log(`   → Updated localStorage: mp_like_${gameId} = ${isLiked ? '1' : '0'}`)
          
          // Update UI
          renderHeart(isLiked)
          console.log(`   → UI updated: renderHeart(${isLiked})`)
          
          // Update like count
          if (totalLikes != null) {
            const currentComments = cmtCountEl ? Number(cmtCountEl.textContent) || 0 : 0
            setCounts(totalLikes, currentComments)
            console.log(`   → Updated counts: likes = ${totalLikes}, comments = ${currentComments}`)
          }
          
          // Only reload game list if user is currently viewing "Liked" filter
          // This prevents auto-switching to "Liked" filter when user likes a game
          if (currentFilter === 'Liked') {
            console.log(`   → User is viewing "Liked" filter - reloading list...`)
            setTimeout(() => {
              if (typeof window.applyGameFilter === 'function') {
                window.applyGameFilter('Liked')
              }
            }, 200)
          } else {
            console.log(`   → User is viewing "${currentFilter}" filter - keeping current view`)
          }
          
          console.log(`   ✅ Like toggle completed successfully!`)
        } catch (e) {
          console.error(`   ❌ toggle_like error:`, e?.message || e)
          console.error(`   → Stack:`, e?.stack)
        } finally {
          likeBtn.disabled = false
          console.log(`   → Button re-enabled`)
        }
      })
      commentBtn.addEventListener('click', () => openPanel(gameId))
      // Market cap click handler is set by updateMC() function
      // Don't add handler here to avoid conflicts
      if (marketcapBtn) {
        // Handler will be set when MC is loaded via updateMC()
        console.log('Market Cap button found for', gameId)
      }
      if (shareBtn) {
        shareBtn.addEventListener('click', () => {
          openShareOverlay(gameId)
        })
      }
      if (leaderboardBtn) {
        leaderboardBtn.addEventListener('click', () => {
          if (typeof window.__openLeaderboardOverlay === 'function') {
            window.__openLeaderboardOverlay(gameId)
          }
        })
      }
    })
  }
  // ❌ REMOVED: initSocialHandlers() - Already called in DOMContentLoaded (line 1555)
  // This was causing duplicate event listeners → like button flickering!

  // Listen for game scores via postMessage
  // Handle TOGGLE_FOCUS_MODE message from iframe (pixel-space-shooter)
  window.addEventListener('message', (event) => {
    if (event.data?.type === 'TOGGLE_FOCUS_MODE') {
      const { gameId } = event.data;
      console.log('📥 Received TOGGLE_FOCUS_MODE from iframe:', gameId);
      
      // Set active game
      if (gameId) {
        try { window.__memeplayActiveGame = gameId } catch {}
        focusState.gameId = gameId;
        const card = document.querySelector(`[data-game-id="${gameId}"]`) || document.getElementById(gameId);
        if (card) {
          applyFocusActiveCard(gameId);
        }
      }
      
      // Toggle focus mode
      toggleFocusMode();
      
      // Send FOCUS_MODE_CHANGED back to iframe
      const iframes = document.querySelectorAll('iframe[data-game-url*="pixel-space-shooter"]');
      iframes.forEach(iframe => {
        if (iframe.contentWindow) {
          iframe.contentWindow.postMessage({
            type: 'FOCUS_MODE_CHANGED',
            isFocus: document.body.classList.contains('focus-mode')
          }, '*');
        }
      });
    }
  });
  
  // Legacy games (hosted on Lovable, sử dụng protocol cũ)
  const LEGACY_GAME_IDS = new Set([
    'bird-squash',      // Game 1
    'inverse-cramer',   // Jim Cramer
    'moonshot-bnb'      // Game 2
  ]);

  function isLegacyGame(gameId) {
    return !!gameId && LEGACY_GAME_IDS.has(gameId);
  }

  window.addEventListener('message', async (event) => {
    // DEBUG: Log ALL messages to see what's being received
    const msgType = event.data?.type
    const msgGameId = event.data?.gameId
    console.log('📨 [DEBUG] Parent received:', msgType, 'from', msgGameId, '| Origin:', event.origin);
    
    // ✅ ONLY sync activeGame when game is ACTUALLY PLAYING (GAME_SCORE only!)
    // ❌ DON'T sync with GAME_START/RESTART (may send automatically on iframe load)
    // ❌ DON'T sync with other messages (init, ready, etc.)
    if (event.data?.gameId && event.data?.type === 'GAME_SCORE') {
      const messageGameId = event.data.gameId
      
      if (activeGame !== messageGameId) {
        console.log('🔄 Syncing activeGame:', activeGame, '→', messageGameId)
        activeGame = messageGameId
      }
    }
    
    // Handle GAME_START message (start timer when user actually plays)
    if (event.data?.type === 'GAME_START' && event.data?.gameId) {
      const { gameId } = event.data;
      console.log('🎮 [TIMER DEBUG] GAME_START received:', { gameId, origin: event.origin });
      
      // Only start timer if not already running for this game
      if (!activeStartTime || (activeGame && activeGame !== gameId)) {
        // Stop previous game if different
        if (activeGame && activeGame !== gameId) {
          console.log('   ⏹️ Stopping previous game:', activeGame);
          await stopGame();
        }
        
        console.log('   ▶️ Starting timer for', gameId);
        startGame(gameId);
      } else if (activeGame === gameId) {
        console.log('   ℹ️ Timer already running for', gameId);
      }
    }
    
    if (event.data?.type === 'GAME_SCORE') {
      const { gameId, score, level } = event.data
      console.log('🎮 [TIMER DEBUG] GAME_SCORE received:', { gameId, score, origin: event.origin })
      
      // ✅ Clear fallback timer when receiving GAME_SCORE (game handles itself!)
      if (window.fallbackTimers && window.fallbackTimers[gameId]) {
        clearTimeout(window.fallbackTimers[gameId])
        delete window.fallbackTimers[gameId]
        console.log('🔄 [FALLBACK] Cleared fallback timer for', gameId, '(game sends GAME_SCORE)')
      }
      
      if (!gameId) {
        console.log('❌ [TIMER DEBUG] No gameId in message!')
        return
      }
      
      // Convert to integer (round down for fairness)
      const finalScore = Math.floor(Number(score))
      console.log('🎮 [TIMER DEBUG] Processing game:', gameId, 'score:', finalScore)
      
      // ✅ ALWAYS submit score first, then process timer logic
      // ✅ Ensure score is sent to leaderboard even if "Play Again" is detected
      console.log(`📊 Received score: ${score} → ${finalScore} for ${gameId}`)
      
      // Submit score immediately (don't wait for timer logic)
      try {
        const payload = {
          p_user_id: userId,
          p_game_id: gameId,
          p_score: finalScore
        }
        if (Number.isFinite(Number(level))) payload.p_level = Math.max(1, Math.trunc(Number(level)))

        console.log('📤 [SCORE] Submitting score immediately (keepalive):', payload)
        const { data, error } = await rpcWithKeepalive('submit_game_score', payload)
        
        if (error) throw error
        
        if (data?.is_new_best) {
          console.log(`🏆 New high score! Rank #${data.user_rank}/${data.total_players}`)
          // TODO: Show toast/animation "New Best!"
        } else {
          console.log(`✓ Score submitted. Best: ${data.best_score}, Rank: #${data.user_rank}`)
        }
      } catch (err) {
        console.error('❌ [SCORE] Submit score error:', err)
      }

      // Ensure a play is counted even if timer didn't start properly
      // ❗ Legacy games: skip safeguard here để tránh double-count; stopGame() sẽ lo increment.
      if (!isLegacyGame(gameId)) {
        try {
          // Compute session seconds; if not available, fallback to 3s minimum
          let secondsElapsed = 0
          if (activeGame === gameId && activeStartTime) {
            secondsElapsed = Math.max(0, Math.floor((Date.now() - activeStartTime) / 1000))
          }
          const secondsForPlay = Math.max(3, secondsElapsed)
          console.log('⏱ [PLAYS SAFEGUARD] secondsForPlay =', secondsForPlay, 'gameId =', gameId)
          const sgPayload = {
            p_user_id: userId,
            p_game_id: gameId,
            p_seconds: secondsForPlay
          };
          console.log('📈 [PLAYS] increment_play_count (safeguard) →', sgPayload);
          const { data: incData, error: incErr } = await rpcWithKeepalive('increment_play_count', sgPayload)
          if (incErr) {
            console.warn('⏱ [PLAYS SAFEGUARD] increment_play_count failed:', incErr.message)
          } else if (incData && typeof incData.total_plays === 'number') {
            setPlaysLabelForCard(gameId, incData.total_plays)
            console.log(`📊 [plays safeguard +1] ${gameId}:`, incData.total_plays)
          }
        } catch (e) {
          console.warn('⏱ [PLAYS SAFEGUARD] error:', e?.message || e)
          try { await loadPlayCount(gameId) } catch {}
        }
      }
      
      // LEGACY GAMES (Lovable): Always treat GAME_SCORE as full session end (old behavior)
      if (isLegacyGame(gameId)) {
        console.log('🕒 [LEGACY] Handling GAME_SCORE with legacy flow for', gameId);
      
        // Nếu timer chưa chạy hoặc đang chạy cho game khác, backfill start time tối thiểu
        if (!activeGame || activeGame !== gameId || !activeStartTime) {
          activeGame = gameId;
          // Backdate 5s để đảm bảo có thời gian >0 cho reward (increment_play_count dùng 3s cố định)
          activeStartTime = Date.now() - 5000;
          console.log('🕒 [LEGACY] Backfilled start time for', gameId, 'at', new Date(activeStartTime).toISOString());
        }
      
        // Dừng game ngay để finalize playtime + achievements như cũ
        try {
          await stopGame();
          console.log('✅ [LEGACY] stopGame() completed for', gameId);
        } catch (e) {
          console.error('❌ [LEGACY] stopGame error for', gameId, e);
        }
        // Không return; tiếp tục xuống logic GAME OVER chung để nổ toast giữa màn hình
      }
      
      // DETECT PLAY AGAIN: chỉ áp dụng cho game mới, không áp dụng cho legacy games
      if (!isLegacyGame(gameId)) {
        const hasScore = score > 0  // Score > 0 = game is being played
        const timerNotRunningForThisGame = !activeStartTime || (activeGame && activeGame !== gameId)
        
        const isPlayAgain = hasScore && timerNotRunningForThisGame && finalScore < 15  // ✅ Only detect Play Again if score < 15
        console.log('🎮 [TIMER DEBUG] isPlayAgain check:', { hasScore, timerNotRunningForThisGame, activeStartTime, activeGame, isPlayAgain })
        
        if (isPlayAgain) {
          console.log('🔄 [TIMER DEBUG] ✅ Play Again detected! Starting timer for:', gameId)
          
          // Stop previous session if exists (different game)
          if (activeGame && activeStartTime && activeGame !== gameId) {
            console.log('   ⏹️ Stopping previous game session:', activeGame)
            await stopGame()
          }
          
          console.log('   ▶️ Starting timer for', gameId)
          startGame(gameId)
          // Return early, wait for higher score to process game over
          return
        }
      }
      
      // HIGH SCORE = GAME OVER
      console.log('🎮 Game Over detected! Stopping game to finalize achievements...')
      
      // Set flag to allow showing achievements (ONLY after game over)
      isGameOver = true
      
      // Stop game = finalize playtime + queue any remaining achievements
      if (activeGame === gameId || activeGame) {
        console.log('   ⏹️ Calling stopGame() to finalize playtime...')
        await stopGame()
        console.log('   ✅ stopGame() completed - achievements finalized!')
      }
      
      // NOW check pending achievements (after stopGame finalized them)
      console.log('   🔍 Checking pending achievements...')
      console.log('   🔑 gameId from GAME_SCORE message:', gameId)
      console.log('   📦 pendingAchievements:', pendingAchievements)
      console.log('   📦 Keys in pending:', Object.keys(pendingAchievements))
      
      // Try BOTH gameId and any pending
      const achievementsToShow = pendingAchievements[gameId] || pendingAchievements[Object.keys(pendingAchievements)[0]]
      
      if (achievementsToShow && achievementsToShow.length > 0) {
        const keyUsed = pendingAchievements[gameId] ? gameId : Object.keys(pendingAchievements)[0]
        console.log('   ✅ Found', achievementsToShow.length, 'achievement(s) under key:', keyUsed)
        // Wait 1s after game over, then show achievements
        setTimeout(() => {
          console.log('   🎉 NOW showing achievements (isGameOver=true)...')
          showPendingAchievements(keyUsed)
        }, 1000)
      } else {
        console.log('   ❌ NO pending achievements found after stopGame!')
        // Reset flag if no achievements to show
        isGameOver = false
      }
    }
  })

  // Format count helper (1K, 10.5K, 1.2M)
  function formatCount(num) {
    const n = Number(num) || 0
    if (n >= 1000000) return (n / 1000000).toFixed(1).replace(/\.0$/, '') + 'M'
    if (n >= 1000) return (n / 1000).toFixed(1).replace(/\.0$/, '') + 'K'
    return String(n)
  }

  function shortAddrLeaderboard(addr) {
    if (!addr || addr.length <= 10) return addr || 'Anonymous'
    return addr.slice(0, 6) + '…' + addr.slice(-4)
  }

  // Format score based on game type
  function formatScore(score, gameId) {
    const num = Number(score) || 0;
    
    // Wojak game shows percentage
    if (gameId === 'wojak-btc-blast') {
      return num + '%';
    }
    
    // Other games use normal format (1K, 1M...)
    return formatCount(num);
  }

  function setLeaderboardActivePanel(panel) {
    const overlay = document.getElementById('leaderboardOverlay')
    if (!overlay) return
    const tabs = overlay.querySelectorAll('.leaderboard-tab')
    const scoresPanel = document.getElementById('leaderboardPanelScores')
    const rewardsPanel = document.getElementById('leaderboardPanelRewards')

    const target = panel === 'rewards' ? 'rewards' : 'scores'
    tabs.forEach(btn => {
      const isActive = btn.dataset.panel === target
      btn.classList.toggle('active', isActive)
    })
    scoresPanel?.classList.toggle('active', target === 'scores')
    rewardsPanel?.classList.toggle('active', target === 'rewards')
    overlay.dataset.activePanel = target
  }

  function renderRewardsPanel(gameId) {
    const summaryEl = document.getElementById('leaderboardRewardSummary')
    const listEl = document.getElementById('leaderboardRewardList')
    if (!summaryEl || !listEl) return

    const awardedMap = getGameAwards(gameId)
    const totalSeconds = getGameSeconds(gameId)
    const achievements = [
      { threshold: 10, name: '10s Play Reward', reward: 100 },
      { threshold: 60, name: 'Engaged', reward: 300 },
      { threshold: 300, name: 'Champion', reward: 1000 }
    ]

    const progress = Math.min(100, (totalSeconds / 300) * 100)
    summaryEl.innerHTML = `
      <div style="font-size:18px;">Total Playtime</div>
      <div class="reward-total">${totalSeconds}s / 300s</div>
      <div class="leaderboard-reward-progress"><span style="width:${progress}%"></span></div>
      <div style="margin-top:6px;font-size:13px;color:#a9b1c4;">Play more to unlock bonus PLAY rewards</div>
    `

    listEl.innerHTML = ''
    achievements.forEach(ach => {
      const unlocked = awardedMap[ach.threshold] || totalSeconds >= ach.threshold
      const secondsLeft = Math.max(0, ach.threshold - totalSeconds)
      const card = document.createElement('div')
      card.className = 'leaderboard-reward-card' + (unlocked ? ' unlocked' : '')
      card.innerHTML = `
        <div style="flex:1;">
          <div class="reward-name">${unlocked ? '✅' : '🔒'} ${ach.name}</div>
          <div class="reward-status">${unlocked ? 'Unlocked!' : `${secondsLeft}s remaining`}</div>
        </div>
        <div class="reward-amount">+${ach.reward}</div>
      `
      listEl.appendChild(card)
    })
  }

  async function openLeaderboardOverlay(gameId) {
    const overlay = document.getElementById('leaderboardOverlay')
    const list = document.getElementById('leaderboardList')
    const rewardSummary = document.getElementById('leaderboardRewardSummary')
    const rewardList = document.getElementById('leaderboardRewardList')
    if (!overlay || !list || !rewardSummary || !rewardList) return

    overlay.dataset.gameId = gameId
    setLeaderboardActivePanel('scores')
    renderRewardsPanel(gameId)

    list.innerHTML = '<div style="padding:24px;text-align:center;color:#bbb;">Loading...</div>'
    overlay.classList.add('open')

    try {
      const { data, error } = await supabase.rpc('get_game_leaderboard_with_user', {
        p_game_id: gameId,
        p_user_id: userId,
        p_limit: 100
      })

      if (error) throw error

      list.innerHTML = ''

      const userEntry = data?.current_user
      if (userEntry) {
        const userItem = document.createElement('div')
        userItem.className = 'leaderboard-item user-highlight'
        userItem.innerHTML = `
          <div class="leaderboard-rank">${userEntry.rank ? '#' + userEntry.rank : '-'}</div>
          <div class="leaderboard-user">You</div>
          <div class="leaderboard-score">${formatScore(userEntry.best_score, gameId)}</div>
        `
        list.appendChild(userItem)
      }

      const divider = document.createElement('div')
      divider.className = 'leaderboard-divider'
      divider.textContent = 'Top 100 Players'
      list.appendChild(divider)

      const topPlayers = data?.top_players || []
      if (topPlayers.length === 0) {
        const empty = document.createElement('div')
        empty.style.cssText = 'padding:24px;text-align:center;color:#888;'
        empty.textContent = 'No scores yet. Be the first!'
        list.appendChild(empty)
        return
      }

      topPlayers.forEach(player => {
        const item = document.createElement('div')
        item.className = 'leaderboard-item'
        if (player.user_id === userId) {
          item.classList.add('is-current-user')
        }

        let rankDisplay = `#${player.rank}`
        if (player.rank === 1) rankDisplay = '🥇'
        else if (player.rank === 2) rankDisplay = '🥈'
        else if (player.rank === 3) rankDisplay = '🥉'

        item.innerHTML = `
          <div class="leaderboard-rank">${rankDisplay}</div>
          <div class="leaderboard-user">${shortAddrLeaderboard(player.user_id)}</div>
          <div class="leaderboard-score">${formatScore(player.best_score, gameId)}</div>
        `
        list.appendChild(item)
      })
    } catch (err) {
      console.error('Leaderboard error:', err)
      list.innerHTML = '<div style="padding:24px;text-align:center;color:#f88;">Failed to load leaderboard</div>'
    }
  }

  ;(function initLeaderboardOverlay(){
    const overlay = document.getElementById('leaderboardOverlay')
    if (!overlay) return
    const closeBtn = document.getElementById('leaderboardCloseBtn')
    const tabButtons = overlay.querySelectorAll('.leaderboard-tab')

    if (!overlay.dataset.activePanel) overlay.dataset.activePanel = 'scores'

    function closeLeaderboardOverlay() {
      overlay.classList.remove('open')
    }

    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const panel = btn.dataset.panel
        if (panel) setLeaderboardActivePanel(panel)
      })
    })

    closeBtn?.addEventListener('click', closeLeaderboardOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeLeaderboardOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeLeaderboardOverlay()
    })

    window.__openLeaderboardOverlay = openLeaderboardOverlay
    window.__closeLeaderboardOverlay = closeLeaderboardOverlay
  })()

  // Share Modal Logic
  let currentShareGameId = null
  
  function openShareOverlay(gameId) {
    currentShareGameId = gameId
    const overlay = document.getElementById('shareOverlay')
    if (overlay) overlay.classList.add('open')
  }

  ;(function initShareOverlay(){
    const overlay = document.getElementById('shareOverlay')
    if (!overlay) return
    
    const closeBtn = document.getElementById('shareCloseBtn')
    const copyBtn = document.getElementById('shareCopyBtn')
    const telegramBtn = document.getElementById('shareTelegramBtn')
    const xBtn = document.getElementById('shareXBtn')

    function closeShareOverlay() {
      overlay.classList.remove('open')
    }

    // Close handlers
    closeBtn?.addEventListener('click', closeShareOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeShareOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeShareOverlay()
    })

    // Copy Link Button
    copyBtn?.addEventListener('click', async () => {
      const shareUrl = `${window.location.origin}${window.location.pathname}#${currentShareGameId}`
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(shareUrl)
          const originalHTML = copyBtn.innerHTML
          copyBtn.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            <span>✓ Copied!</span>
          `
          setTimeout(() => {
            copyBtn.innerHTML = originalHTML
          }, 2000)
        }
      } catch (err) {
        console.error('Copy failed:', err)
      }
    })

    // Telegram Button
    telegramBtn?.addEventListener('click', () => {
      const shareUrl = `${window.location.origin}${window.location.pathname}#${currentShareGameId}`
      const text = `🎮 Check out this awesome game on MemePlay Arcade! Play and earn PLAY points! 🚀`
      const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(text)}`
      window.open(telegramUrl, '_blank')
      closeShareOverlay()
    })

    // X/Twitter Button
    xBtn?.addEventListener('click', () => {
      const shareUrl = `${window.location.origin}${window.location.pathname}#${currentShareGameId}`
      const text = `🎮 Just played an awesome game on MemePlay! Play & earn PLAY points! 🚀`
      const xUrl = `https://twitter.com/intent/tweet?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(text)}`
      window.open(xUrl, '_blank')
      closeShareOverlay()
    })
  })()

  ;(function initStatsOverlay(){
    const overlay = document.getElementById('statsOverlay')
    if (!overlay) return
    const closeBtn = document.getElementById('statsCloseBtn')
    const streakEl = document.getElementById('statsStreak')
    const playsEl = document.getElementById('statsPlays')

    function updateStatsOverlay() {
      const streakSource = document.getElementById('streakCount')
      const playsSource = document.getElementById('headerEarned')
      if (streakSource) streakEl.textContent = streakSource.textContent || '0'
      if (playsSource) playsEl.textContent = playsSource.textContent || '0'
    }

    function openStatsOverlay() {
      updateStatsOverlay()
      overlay.classList.add('open')
    }

    function closeStatsOverlay() {
      overlay.classList.remove('open')
    }

    closeBtn?.addEventListener('click', closeStatsOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeStatsOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeStatsOverlay()
    })

    window.__openStatsOverlay = openStatsOverlay
    window.__updateStatsOverlay = updateStatsOverlay
  })()
 
   
  </script>

  <!-- Global helpers shim (non-module) to guarantee console access -->
  <script>
    (function installMemeplayShim(){
      function lsGetInt(key){
        const raw = localStorage.getItem(key);
        const num = raw == null ? NaN : Number(raw);
        return Number.isFinite(num) ? num : 0;
      }
      function getIds(){
        return Array.from(document.querySelectorAll('.game-card')).map(c => c.getAttribute('data-game-id') || c.id || 'unknown');
      }
      const shim = {
        getGameSeconds: function(gameId){ return lsGetInt('mp_game_seconds_' + gameId); },
        listAllGameSeconds: function(){
          const rows = getIds().map(id => ({ gameId: id, seconds: lsGetInt('mp_game_seconds_' + id) }));
          try { console.table(rows); } catch {}
          return rows;
        },
        resetGameProgress: function(gameId){
          if (!gameId) return false;
          localStorage.setItem('mp_game_seconds_' + gameId, '0');
          localStorage.removeItem('mp_game_awards_' + gameId);
          console.log('🔄 Reset progress for', gameId);
          return true;
        },
        startGame: function(gameId){
          try { if (window.memeplay && window.memeplay.startGame) return window.memeplay.startGame(gameId); } catch {}
          console.warn('startGame bridge: module not ready');
        },
        stopGame: function(){
          try { if (window.memeplay && window.memeplay.stopGame) return window.memeplay.stopGame(); } catch {}
          console.warn('stopGame bridge: module not ready');
        }
      };
      try { window.memeplay = Object.assign({}, shim, window.memeplay || {}); } catch {}
      try { self.memeplay = window.memeplay; } catch {}
      try { globalThis.memeplay = window.memeplay; } catch {}
      console.log('🧩 memeplay console shim ready');
    })();
  </script>

  <!-- Desktop scroll: Redirect scroll from full page into .game-container with scroll-snap -->
  <script>
    (function enableDesktopScroll(){
      const gameContainer = document.querySelector('.game-container');
      if (!gameContainer) return;
      
      // Redirect wheel events from document into .game-container
      document.addEventListener('wheel', (e) => {
        // Only handle vertical scroll
        if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
          const target = e.target;
          // Check if click is inside .game-container
          const isInGameContainer = gameContainer.contains(target) || 
                                    target.closest('.game-card') ||
                                    target.closest('.game-container') ||
                                    target.closest('.main-header');
          
          // If click outside game-container (black area), redirect scroll into .game-container
          if (!isInGameContainer) {
            e.preventDefault();
            e.stopPropagation();
            
            // Scroll with smoother speed, ensure scroll down works
            const scrollAmount = Math.abs(e.deltaY) * 1.2; // Increase scroll speed slightly
            const scrollDirection = e.deltaY > 0 ? 1 : -1; // Down = 1, Up = -1
            
            // Use scrollBy to trigger scroll-snap naturally
            gameContainer.scrollBy({
              top: scrollAmount * scrollDirection,
              behavior: 'auto' // 'auto' for scroll-snap to work
            });
            
            // After scrolling, automatically snap to nearest game card at center
            clearTimeout(gameContainer._snapTimeout);
            gameContainer._snapTimeout = setTimeout(() => {
              const cards = Array.from(document.querySelectorAll('.game-card'));
              if (!cards.length) return;
              
              const containerTop = gameContainer.scrollTop;
              const containerHeight = gameContainer.clientHeight;
              const viewportCenter = containerTop + containerHeight / 2;
              
              let bestCard = null;
              let bestDistance = Infinity;
              
              cards.forEach(card => {
                const cardTop = card.offsetTop - gameContainer.offsetTop;
                const cardHeight = card.offsetHeight;
                const cardCenter = cardTop + cardHeight / 2;
                const distance = Math.abs(cardCenter - viewportCenter);
                
                if (distance < bestDistance) {
                  bestDistance = distance;
                  bestCard = card;
                }
              });
              
              // If nearest card not at center, scroll to its exact center + 5% offset down
              if (bestCard && bestDistance > 30) {
                const cardTop = bestCard.offsetTop - gameContainer.offsetTop;
                const cardHeight = bestCard.offsetHeight;
                const cardCenter = cardTop + cardHeight / 2;
                // Calculate scroll position: center - 5% viewport down = center + 5% containerHeight
                const offsetDown = containerHeight * 0.05; // 5% down
                const targetScroll = Math.max(0, cardCenter - containerHeight / 2 - offsetDown);
                
                gameContainer.scrollTo({
                  top: targetScroll,
                  behavior: 'smooth'
                });
              }
            }, 150); // Debounce to avoid snapping too many times
          }
        }
      }, { passive: false });
      
      // Handle keyboard scroll (Space, Arrow keys) with scroll-snap
      document.addEventListener('keydown', (e) => {
        // Only handle when focus is not in input/textarea
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        const key = e.key;
        if (key === ' ' || key === 'ArrowDown' || key === 'ArrowUp' || key === 'PageDown' || key === 'PageUp') {
          e.preventDefault();
          
          // Find current game card and scroll to next/previous game
          const cards = Array.from(document.querySelectorAll('.game-card'));
          if (!cards.length) return;
          
          let currentIndex = 0;
          const containerTop = gameContainer.scrollTop;
          const containerHeight = gameContainer.clientHeight;
          
          // Find currently visible game card (occupying >50% viewport)
          for (let i = 0; i < cards.length; i++) {
            const card = cards[i];
            const cardTop = card.offsetTop - gameContainer.offsetTop;
            const cardBottom = cardTop + card.offsetHeight;
            const viewportTop = containerTop;
            const viewportBottom = containerTop + containerHeight;
            
            // If card occupies >50% viewport
            const visibleTop = Math.max(cardTop, viewportTop);
            const visibleBottom = Math.min(cardBottom, viewportBottom);
            const visibleHeight = visibleBottom - visibleTop;
            
            if (visibleHeight > containerHeight * 0.5) {
              currentIndex = i;
              break;
            }
          }
          
          // Determine next/previous game
          let nextIndex = currentIndex;
          if (key === 'ArrowDown' || key === ' ' || key === 'PageDown') {
            nextIndex = (currentIndex + 1) % cards.length;
          } else if (key === 'ArrowUp' || key === 'PageUp') {
            nextIndex = (currentIndex - 1 + cards.length) % cards.length;
          }
          
          // Scroll to center of game card + 5% offset down to make game appear slightly lower
          if (cards[nextIndex]) {
            const card = cards[nextIndex];
            const cardTop = card.offsetTop - gameContainer.offsetTop;
            const cardHeight = card.offsetHeight;
            const containerHeight = gameContainer.clientHeight;
            const cardCenter = cardTop + cardHeight / 2;
            // Calculate scroll position: center - 5% viewport down = center + 5% containerHeight
            const offsetDown = containerHeight * 0.05; // 5% down
            const targetScroll = Math.max(0, cardCenter - containerHeight / 2 - offsetDown);
            
            gameContainer.scrollTo({
              top: targetScroll,
              behavior: 'smooth'
            });
          }
        }
      });
    })();
  </script>

  <!-- Swipe navigation: up/down moves to next/prev game (loops) -->
  <script>
    (function swipeNavigation(){
      const sc = document.querySelector('.game-container');
      const cards = Array.from(document.querySelectorAll('.game-card'));
      if (!cards.length) return;

      let tops = [];
      function recalc(){
        tops = cards.map(el => el.offsetTop);
      }
      function currentIndex(){
        const y = sc.scrollTop + sc.clientHeight * 0.25; // focus upper quarter
        let best = 0, bestDiff = Infinity;
        for (let i=0;i<tops.length;i++){
          const d = Math.abs(tops[i]-y);
          if (d < bestDiff){ best = i; bestDiff = d; }
        }
        return best;
      }
      function scrollToIndex(i){
        const n = cards.length;
        const idx = ((i % n) + n) % n; // safe modulo
        const y = tops[idx] ?? 0;
        sc.scrollTo({ top: y, behavior: 'smooth' });
      }

      recalc();
      window.addEventListener('resize', recalc, { passive: true });
      window.addEventListener('orientationchange', recalc, { passive: true });

      let startY = 0, startT = 0, moved = false;
      const THRESHOLD = 60; // px
      const VELOCITY = 0.35; // px/ms

      sc.addEventListener('touchstart', (e) => {
        if (!e.touches || !e.touches.length) return;
        startY = e.touches[0].clientY; startT = performance.now(); moved = false;
      }, { passive: true });

      sc.addEventListener('touchmove', (e) => {
        moved = true;
      }, { passive: true });

      sc.addEventListener('touchend', (e) => {
        if (!moved) return;
        const endY = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY : startY;
        const dy = endY - startY; // down = positive
        const dt = Math.max(1, performance.now() - startT);
        const v = Math.abs(dy) / dt;
        if (Math.abs(dy) < THRESHOLD && v < VELOCITY) return; // ignore tiny swipes

        const cur = currentIndex();
        if (dy < 0) scrollToIndex(cur + 1); // swipe up -> next
        else scrollToIndex(cur - 1);        // swipe down -> prev
      }, { passive: true });

      // Force snap to nearest after inertial scrolling stops (prevents resting between cards)
      let snapTimer = null;
      sc.addEventListener('scroll', () => {
        if (snapTimer) clearTimeout(snapTimer);
        snapTimer = setTimeout(() => {
          recalc();
          const idx = currentIndex();
          scrollToIndex(idx);
        }, 120);
      }, { passive: true });
    })();
  </script>

  <script>
    ;(function initWalletOverlay(){
      const overlay = document.getElementById('walletOverlay')
      if (!overlay) return
      const closeBtn = document.getElementById('walletCloseBtn')
      const copyBtn = document.getElementById('walletCopyBtn')
      const disconnectBtn = document.getElementById('walletDisconnectBtn')
      const addressEl = document.getElementById('walletOverlayAddress')
      const streakEl = document.getElementById('walletOverlayStreak')
      const playsEl = document.getElementById('walletOverlayPlays')

      function updateWalletOverlay() {
        const api = globalThis.memeplayWallet || {}
        const address = api.getAddress?.() || ''
        addressEl.textContent = address ? address : 'Not connected'
        const streak = api.getStreak?.()
        const plays = api.getPlayPoints?.()
        streakEl.textContent = String(Number.isFinite(streak) ? streak : 0)
        playsEl.textContent = String(Number.isFinite(plays) ? plays : 0)
      }

      function openWalletOverlay() {
        updateWalletOverlay()
        overlay.classList.add('open')
      }

      function closeWalletOverlay() {
        overlay.classList.remove('open')
      }

      closeBtn?.addEventListener('click', closeWalletOverlay)
      overlay.addEventListener('click', (event) => {
        if (event.target === overlay) closeWalletOverlay()
      })
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && overlay.classList.contains('open')) closeWalletOverlay()
      })

      copyBtn?.addEventListener('click', async () => {
        const api = globalThis.memeplayWallet || {}
        const address = api.getAddress?.() || ''
        if (!address) return
        try {
          await navigator.clipboard.writeText(address)
          copyBtn.textContent = 'Copied!'
          setTimeout(() => { copyBtn.textContent = 'Copy address' }, 1500)
        } catch (err) {
          console.warn('Clipboard copy failed', err)
          copyBtn.textContent = 'Copy failed'
          setTimeout(() => { copyBtn.textContent = 'Copy address' }, 1500)
        }
      })

      disconnectBtn?.addEventListener('click', () => {
        const api = globalThis.memeplayWallet || {}
        api.disconnect?.()
        closeWalletOverlay()
      })

      window.__openWalletOverlay = openWalletOverlay
    window.__updateWalletOverlay = updateWalletOverlay
  })()

  ;(function initCreatorOverlay(){
    const overlay = document.getElementById('creatorOverlay')
    if (!overlay) return
    const closeBtn = document.getElementById('creatorCloseBtn')

    function openCreatorOverlay() {
      overlay.classList.add('open')
    }

    function closeCreatorOverlay() {
      overlay.classList.remove('open')
    }

    closeBtn?.addEventListener('click', closeCreatorOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeCreatorOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeCreatorOverlay()
    })

    window.__openCreatorOverlay = openCreatorOverlay
    window.__closeCreatorOverlay = closeCreatorOverlay
  })()

  // ==========================================
  // MARKET CAP - 4meme Integration
  // ==========================================
  setTimeout(() => {
    console.log('🚀 MC script start')
    
    if (!window.ethers) return console.error('❌ No ethers.js')
    console.log('✅ Ethers OK')
    
    // Contract addresses for each game
    // Game 1 (bird-squash) - contract address
    const GAME_CONTRACTS = {
      'bird-squash': '0xdb26dcc0cac3253a516398d60fd53e6f7c284444', // Game 1 - bird squash token
      // Add other games here as needed
      // 'wojak-btc-blast': '0x...',
      // 'moonshot-bnb': '0x...',
    }
    
    const HELPER = '0xF251F83e40a78868FcfA3FA4599Dad6494E46034'
    
    function fmt(n) {
      if (!n) return '--'
      if (n >= 1e9) return (n/1e9).toFixed(1)+'B'
      if (n >= 1e6) return (n/1e6).toFixed(1)+'M'
      if (n >= 1e3) return (n/1e3).toFixed(1)+'K'
      return n.toFixed(0)
    }
    
    // Get BNB price
    async function getBNB() {
      try {
        const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=binancecoin&vs_currencies=usd')
        const data = await res.json()
        return data.binancecoin?.usd || 600
      } catch {
        return 600
      }
    }
    
    async function update(id) {
      const btn = document.querySelector(`#${id} [data-role="marketcap"] button span`)
      if (!btn) return console.log(`[MC] No span: ${id}`)
      
      // Get contract address for this game - NO FALLBACK, must be in GAME_CONTRACTS
      const TOKEN = GAME_CONTRACTS[id]
      
      if (!TOKEN) {
        console.warn(`⚠️ [MC] No contract address configured for game: ${id}`)
        btn.textContent = '--' // Only show number, MC comes from CSS ::before
        return // Don't fetch MC if no contract configured
      }
      
      console.log(`📝 [MC] Using contract for ${id}: ${TOKEN}`)
      
      const wrap = document.querySelector(`#${id} [data-role="marketcap"] button`)
      if (!wrap) return console.log(`[MC] No button: ${id}`)
      
      btn.textContent = '...' // Only show loading number, MC comes from CSS ::before
      
      try {
        // Init provider & contract
        const p = new ethers.providers.JsonRpcProvider('https://bsc-dataseed.binance.org/')
        const h = new ethers.Contract(HELPER, ['function getTokenInfo(address) view returns (uint256,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool)'], p)
        
        // Get token info
        const info = await h.getTokenInfo(TOKEN)
        const graduated = info[11] // liquidityAdded
        
        let mc = 0
        
        if (graduated) {
          // CASE 1: Already on PancakeSwap → DexScreener
          // Market cap graduated to DexScreener
          
          const dex = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${TOKEN}`)
          const dexData = await dex.json()
          
          if (dexData.pairs && dexData.pairs.length > 0) {
            mc = dexData.pairs[0].fdv || dexData.pairs[0].marketCap || 0
            console.log(`✅ [MC] ${id}: $${fmt(mc)} (DexScreener)`)
          } else {
            throw new Error('No DEX data')
          }
          
        } else {
          // CASE 2: Bonding curve → 4meme contract
          // Market cap from bonding curve
          
          const bnb = await getBNB()
          const priceBNB = Number(info[3]) / 1e18
          const priceUSD = priceBNB * bnb
          mc = priceUSD * 1e9
          
          console.log(`✅ [MC] ${id}: $${fmt(mc)} (4meme contract)`)
        }
        
        // Update UI - Show MC value after "MC" text (from ::before)
        // Format: "MC 43.5K" (MC from CSS ::before, number from span)
        btn.textContent = fmt(mc) // Show formatted number (e.g., "43.5K")
        wrap.style.cursor = 'pointer'
        
        // Remove ALL existing click handlers by cloning and replacing
        const newWrap = wrap.cloneNode(true)
        wrap.parentNode.replaceChild(newWrap, wrap)
        
        // Update btn reference to new element after clone
        const newBtn = newWrap.querySelector('span')
        if (newBtn) {
          // Update text content on new element
          newBtn.textContent = fmt(mc)
        }
        
        // Add click handler to open 4meme link
        newWrap.addEventListener('click', (e) => {
          e.preventDefault()
          e.stopPropagation()
          console.log(`🔗 Opening 4meme link for ${id}:`, TOKEN)
          window.open(`https://four.meme/token/${TOKEN}`, '_blank', 'noopener,noreferrer')
        })
        
        newWrap.style.cursor = 'pointer'
        newWrap.title = `Market Cap: $${mc.toLocaleString()} - Click to view on 4meme`
        mcCache[id] = mc // Cache result
        
      } catch (e) {
        console.error(`❌ [MC] ${id}:`, e)
        btn.textContent = '--' // Only show number, MC comes from CSS ::before
        mcCache[id] = 'error' // Cache error to avoid retry
      }
    }
    
    // Cache to avoid refetching
    const mcCache = {}
    const mcLoading = {}
    
    // Lazy load MC when game visible AND iframe loaded
    const mcObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
          const gameId = entry.target.id
          
          // Check if iframe has loaded
          const iframe = entry.target.querySelector('iframe')
          const iframeLoaded = iframe && iframe.src && !iframe.src.includes('about:blank')
          
          if (iframeLoaded && !mcCache[gameId] && !mcLoading[gameId]) {
            // Wait 2s for game to stabilize, THEN fetch MC
            setTimeout(() => {
              mcLoading[gameId] = true
              update(gameId)
            }, 2000)
          }
        }
      })
    }, { 
      threshold: 0.5, // Increased from 0.3 → 0.5 (visible 50%)
      rootMargin: '0px' // Remove preload, only fetch when actually visible
    })
    
    // Wait 5s after page load, then start observing
    setTimeout(() => {
      // Start lazy load observer after 5s delay
      document.querySelectorAll('.game-card').forEach(card => {
        mcObserver.observe(card)
      })
    }, 5000)
    
    // Manual trigger
    window.__updateMC = () => {
      update('bird-squash')
      update('wojak-btc-blast')
      update('moonshot-bnb')
      update('valley-explorer-3d')
      update('hodl-tower-stack')
    }
  }, 5000)
  
  </script>
</body>
</html>