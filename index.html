<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MemePlay Arcade</title>
  <!-- Favicon files (desktop + mobile) -->
  <link rel="icon" type="image/svg+xml" href="assets/favicon.svg?v=2">
  <link rel="shortcut icon" href="assets/favicon.svg?v=2">
  <link rel="apple-touch-icon" href="assets/favicon.svg?v=2">
  <link rel="stylesheet" href="style.css">
  <link rel="preconnect" href="https://moonshot-bnb.lovable.app" crossorigin>
  <link rel="preconnect" href="https://bird-squash-dev.lovable.app" crossorigin>
  <link rel="preconnect" href="https://wojak-btc-blast.lovable.app" crossorigin>
  <link rel="preconnect" href="https://hodl-tower-stack.lovable.app" crossorigin>
  <link rel="preconnect" href="https://hook-pull-crypto.lovable.app" crossorigin>
  <link rel="preconnect" href="https://game-detective-clone.lovable.app" crossorigin>
  <link rel="preconnect" href="https://monkey-crypto-climb.lovable.app" crossorigin>
  <link rel="preconnect" href="https://crypto-arrow1.lovable.app" crossorigin>
  <link rel="preconnect" href="https://inverse-cramer.lovable.app" crossorigin>
  <link rel="preconnect" href="https://cryptomole-whack-meme.lovable.app" crossorigin>
  <link rel="preconnect" href="https://coin-catch1.lovable.app" crossorigin>
  <link rel="preconnect" href="https://xstarship-flap.lovable.app" crossorigin>
  <link rel="preconnect" href="https://pacman-memeplay.lovable.app" crossorigin>
  <link rel="preconnect" href="https://crypto-sky-jump.lovable.app" crossorigin>
  <link rel="preconnect" href="https://story-shape-studio.lovable.app" crossorigin>
  <link rel="preconnect" href="https://pixel-orb-escape.lovable.app" crossorigin>
  <link rel="preconnect" href="https://rosebud.ai" crossorigin>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Local development redirect for short Pacman game URLs -->
  <script>
    // Handle short URL format for local development: /pacman-game-8041
    // On Vercel, this is handled by vercel.json rewrites
    // On local server, we need JavaScript redirect
    (function() {
      const path = window.location.pathname;
      const pacmanGameMatch = path.match(/^\/(pacman-game-[^\/]+)$/);
      if (pacmanGameMatch) {
        const gameId = pacmanGameMatch[1];
        const redirectUrl = `/games/templates/pacman-template/index.html?game=${gameId}`;
        window.location.replace(redirectUrl);
        return;
      }
    })();
  </script>
  <!-- Debug console for mobile - Remove sau khi fix xong -->
  <!-- DEBUG: Eruda console (DISABLED for performance) -->
  <!-- <script src="https://cdn.jsdelivr.net/npm/eruda"></script> -->
  <!-- <script>eruda.init();</script> -->
  <style>
    :root { --header-h: 60px; }
    /* ===== HEADER (Docs link left, actions right) ===== */
    .main-header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: var(--header-h);
      background: #111;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      box-sizing: border-box;
      z-index: 9999;
      border-bottom: 2px solid #222;
    }
    .logo {
      display: inline-flex;
      align-items: center;
      gap: 12px;
      position: relative;
    }
    .hamburger-wrapper {
      position: relative;
      display: inline-flex;
    }
    .hamburger-wrapper .nav-dropdown {
      left: 0;
      right: auto;
    }
    .docs-menu-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 8px;
      background: rgba(255, 182, 66, 0.08);
      transition: all 0.2s ease;
      text-decoration: none;
      cursor: pointer;
      border: none;
    }
    .docs-menu-btn:hover {
      background: rgba(255, 182, 66, 0.15);
      transform: translateY(-1px);
    }
    .docs-menu-btn:active {
      transform: translateY(0);
    }
    .hamburger-icon {
      width: 20px;
      height: 20px;
      display: block;
    }
    .logo-text {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 1.4px;
      color: #ffb642;
      text-shadow: 0 0 12px rgba(255, 182, 66, 0.45);
      user-select: none;
    }
    .header-flash {
      position: absolute;
      top: 0;
      left: 0;
      font-size: 13px;
      font-weight: 700;
      color: #fff;
      background: linear-gradient(135deg, #ffb642, #ff6b42);
      padding: 4px 10px;
      border-radius: 8px;
      border: 1.5px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 4px 12px rgba(255, 182, 66, 0.5);
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      white-space: nowrap;
      pointer-events: none;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      letter-spacing: 0.2px;
      line-height: 1.3;
    }
    .header-actions {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .search-wrapper {
      position: relative;
    }
    .icon-button {
      width: 44px;
      height: 44px;
      border-radius: 14px;
      border: 1px solid #2a2f38;
      background: #1b1f24;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.18s ease, transform 0.18s ease;
      padding: 0;
    }
    .icon-button[hidden] {
      display: none !important;
    }
    .icon-button:hover {
      background: #273040;
      transform: translateY(-1px);
    }
    .icon-button svg.header-icon {
      width: 22px;
      height: 22px;
      stroke: #ffb642;
      fill: none;
      stroke-width: 2.1;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.18s ease;
    }
    .icon-button:hover svg.header-icon,
    .icon-button:focus-visible svg.header-icon {
      stroke: #ffd678;
    }
    .icon-button img {
      width: 22px;
      height: 22px;
    }
    .icon-button .icon-plus {
      font-size: 24px;
      font-weight: 600;
      color: #ffb642;
      line-height: 1;
      transition: color 0.18s ease;
    }
    .icon-button:hover .icon-plus {
      color: #ffd678;
    }
    .nav-dropdown {
      position: absolute;
      top: calc(100% + 12px);
      right: 0;
      width: 210px;
      background: #1a1f28;
      color: #fff;
      border-radius: 16px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.6);
      display: none;
      flex-direction: column;
      padding: 10px 0;
      z-index: 10000;
      overflow: hidden; /* Fix: Prevent content from breaking rounded corners */
    }
    .nav-dropdown.open {
      display: flex;
      animation: fadeIn 0.18s ease;
    }
    .dropdown-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .dropdown-item {
      padding: 12px 22px;
      cursor: pointer;
      transition: background 0.18s ease;
      font-weight: 500;
      font-size: 16px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
    }
    .dropdown-item:hover,
    .dropdown-item.active {
      background: #273e66;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px);}
      to { opacity: 1; transform: none;}
    }
    .wallet-connect img {
      width: 26px;
      height: 24px;
    }
    .wallet-status-button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 0 14px;
      height: 44px;
      border-radius: 14px;
      border: 1px solid #2a2f38;
      background: #1b1f24;
      color: #0ff;
      font-weight: 600;
      letter-spacing: 0.3px;
      cursor: pointer;
      transition: background 0.18s ease, transform 0.18s ease;
    }
    .wallet-status-button[hidden] {
      display: none !important;
    }
    .wallet-status-button:hover {
      background: #273040;
      transform: translateY(-1px);
    }
    .wallet-status-icon {
      width: 22px;
      height: 18px;
    }

    /* ===== PAGE LAYOUT SPACING ===== */
    body {
      margin: 0;
      padding-top: calc(var(--header-h) + env(safe-area-inset-top));
      min-height: 100svh;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      scroll-behavior: smooth;
      overflow: hidden; /* scroll inside .game-container for snap */
    }
    /* Move the game container below the header */
    .game-container {
      margin-top: 0; /* Remove margin for precise centering */
    }

    .game-card {
      position: relative;
    }
    
    /* Ensure html and body also hide scrollbar */
    html {
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
    }
    html::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
    body {
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    body::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
    .allow-text-select,
    .allow-text-select * {
      user-select: text !important;
      -webkit-user-select: text !important;
      -webkit-touch-callout: default !important;
    }
    textarea,
    input,
    .comments-input,
    .comments-input * {
      user-select: text !important;
      -webkit-user-select: text !important;
      -webkit-touch-callout: default !important;
    }
    .game-container {
      height: calc(100svh - var(--header-h) - env(safe-area-inset-top));
      overflow-y: auto;
      overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
      scroll-snap-type: y mandatory;
      scroll-padding-top: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 2px 0 28px;
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
      /* ✅ Added: Smooth scroll animation */
      scroll-behavior: smooth;
      transition: scroll-behavior 0.3s ease;
    }
    .game-container.is-scrolling {
      scroll-snap-type: none;
      scroll-behavior: auto !important;
    }
    .game-container::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
    .game-card {
      width: min(calc(100vw - 8px), 720px);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      margin: 0 auto 6px;
      padding: 0 3px 6px;
      box-sizing: border-box;
      scroll-snap-align: center;
      scroll-snap-stop: always;
      contain: layout;
    }
    /* ✅ FIX: Điều chỉnh scroll-snap cho Pacman games - cân bằng giữa snap vào và scroll qua
       - Giữ scroll-snap-align: center (để vẫn có thể snap vào Pacman)
       - Chỉ thay đổi scroll-snap-stop: always → normal (cho phép scroll qua được, không force stop)
       - Áp dụng cho tất cả Pacman games (bất kỳ vị trí nào: số 1, số 3, etc.)
    */
    .game-card[id^="pacman-"],
    .game-card[id="pacman-memeplay"],
    .game-card[data-game-id^="pacman-"],
    .game-card[data-game-id="pacman-memeplay"] {
      scroll-snap-stop: normal !important;
      /* Giữ scroll-snap-align: center để vẫn có thể snap vào Pacman */
    }
    /* ✅ FIX: Ẩn và xóa các game Pacman có đường dẫn kiểu cũ (pacman-game-*) */
    .game-card[id^="pacman-game-"],
    .game-card[data-game-id^="pacman-game-"] {
      display: none !important;
      visibility: hidden !important;
    }
    .game-card.is-playing {
      will-change: contents;
    }
    .game-card.is-playing .game-footer *,
    .game-card.is-playing .focus-toggle {
      transition: none !important;
      animation: none !important;
    }
    /* ✅ FIX: Ẩn button focus-toggle cũ trong game-stage của Pacman games
       Vì Pacman template đã có button focus-toggle riêng trong game
    */
    .game-card[data-game-id^="pacman-"] .game-stage .focus-toggle,
    .game-card[id^="pacman-"] .game-stage .focus-toggle,
    .game-card[data-game-id="pacman-memeplay"] .game-stage .focus-toggle,
    .game-card[id="pacman-memeplay"] .game-stage .focus-toggle {
      display: none !important;
      visibility: hidden !important;
    }
    .game-card iframe {
      touch-action: pan-y;
    }
    .game-stage {
      position: relative;
      width: 100%;
      aspect-ratio: 720 / 1000 !important;  /* ← FORCE TABLE VERSION! */
      border-radius: 28px;
      background: linear-gradient(145deg, rgba(14,19,30,0.92), rgba(6,9,15,0.92));
      border: 1px solid rgba(40,58,90,0.35);
      overflow: hidden;
      box-shadow: 0 20px 55px rgba(0,0,0,0.6);
      user-select: none;
      -webkit-user-select: none;
      contain: layout style paint;
      content-visibility: auto;
    }
    .game-stage iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
      will-change: transform;
      transform: translateZ(0);
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      pointer-events: auto;
      overflow: hidden !important;
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
    }
    .game-stage iframe::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
    .focus-toggle {
      position: absolute;
      top: 14px;
      right: 14px;
      width: 44px;
      height: 44px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(6, 9, 15, 0.3);
      color: #eef4ff;
      font-size: 22px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0.32;
      transition: background 0.18s ease, transform 0.18s ease, opacity 0.18s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      user-select: none;
      -webkit-user-select: none;
    }
    .focus-toggle:hover,
    .focus-toggle:focus-visible {
      background: rgba(6, 9, 15, 0.72);
      opacity: 0.95;
      transform: translateY(-1px);
      outline: none;
    }
    .game-footer {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 4px 10px 6px;
      background: rgba(9, 14, 22, 0.94);
      border: 1px solid rgba(40,58,90,0.25);
      border-radius: 14px;
      box-shadow: 0 5px 16px rgba(0,0,0,0.35);
      color: #e3ecff;
      font-size: 9.8px;
      user-select: none;
      -webkit-user-select: none;
      text-align: center;
    }
    .game-icons {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: nowrap;
      gap: 14px;
    }
    .game-icons-left {
      display: flex;
      align-items: center;
      gap: 14px;
    }
    .game-icons-right {
      display: flex;
      align-items: center;
      gap: 14px;
    }
    .icon-wrapper {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }
    .icon-wrapper button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      border: none;
      background: none;
      padding: 0;
      cursor: pointer;
      transition: transform 0.18s ease, opacity 0.18s ease;
    }
    .icon-wrapper button:hover {
      transform: translateY(-2px);
    }
    .icon-wrapper button:focus-visible {
      outline: 2px solid rgba(255,182,66,0.45);
      outline-offset: 3px;
    }
    .icon-wrapper[data-role="marketcap"] {
      margin-right: -10px;
    }
    .icon-wrapper[data-role="marketcap"] button {
      width: auto;
      min-width: 26px;
      padding: 0;
    }
    .icon-wrapper[data-role="marketcap"] button::before {
      content: 'MC';
      font-size: 20px;
      font-weight: 700;
      color: #ffffff;
      line-height: 1;
    }
    .icon-wrapper[data-role="marketcap"] button span {
      white-space: nowrap;
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.5px;
      line-height: 1;
      color: #ffffff;
      display: inline !important; /* Show MC number after "MC" text */
      margin-left: 4px; /* Add space between "MC" and number */
    }
    .icon-wrapper[data-role="donate"] svg {
      stroke: #ffffff;
      stroke-width: 3.5;
      width: 20px;
      height: 20px;
    }
    .icon-wrapper[data-role="donate"] .icon-count {
      color: #ffffff;
      font-weight: 700;
    }
    @media (max-width: 768px) {
      .icon-wrapper[data-role="marketcap"] {
        transform: translateX(-30px);
      }
      .icon-wrapper[data-role="marketcap"] button::before {
        font-size: 14px;
      }
      .icon-wrapper[data-role="marketcap"] button span {
        font-size: 8.5px;
        letter-spacing: 0.1px;
        display: inline !important; /* Show MC number on mobile */
        margin-left: 2px; /* Add space between "MC" and number on mobile */
      }
      .game-footer {
        padding: 4px 14px 6px 14px !important;
        position: relative;
      }
      .creator-text {
        font-size: 8.25px !important;
        margin-left: 0px !important;
        padding-right: 36px !important;
        text-align: left !important;
        display: block !important;
        width: 100%;
      }
      .creator-text strong {
        font-size: 8.25px !important;
        font-weight: 600;
      }
      .icon-wrapper[data-role="leaderboard"] {
        position: absolute !important;
        bottom: 6px !important;
        right: 14px !important;
        transform: scale(1) !important;
      }
    }
    .icon-wrapper svg {
      width: 22px;
      height: 22px;
      stroke: #ffb642;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.18s ease, fill 0.18s ease;
    }
    .icon-wrapper:hover svg,
    .icon-wrapper:active svg {
      stroke: #ffd678;
    }
    .icon-wrapper.liked svg {
      stroke: #ffb642;
      fill: #ffb642;
    }
    .icon-count {
      color: #ffb642;
      font-size: 11px;
      font-weight: 600;
      line-height: 1;
      min-width: 20px;
      text-align: right;
    }
    .creator-text {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      color: #d4def5;
      font-size: 11px;
      letter-spacing: 0.2px;
      line-height: 1.2;
    }
    .creator-box {
      max-width: 540px;
      padding: 36px 32px;
      gap: 0;
      background: #0b0b0b;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }
    .creator-box .wallet-header {
      border-bottom: none;
      margin-bottom: 16px;
      padding-bottom: 0;
    }
    .creator-hero {
      color: #ffb642;
      font-size: 34px;
      font-weight: 700;
      line-height: 1.2;
      text-align: left;
      margin-bottom: 32px;
      border-bottom: none;
    }
    .creator-points {
      display: flex;
      flex-direction: column;
      gap: 18px;
      margin-bottom: 32px;
      color: #f3c978;
      font-size: 18px;
      line-height: 1.5;
    }
    .creator-point {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .creator-point-icon {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 2px solid #ffb642;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: 700;
    }
    .creator-cta {
      margin-top: auto;
      border: 2px solid #ffb642;
      border-radius: 16px;
      padding: 18px 24px;
      text-align: center;
      color: #ffb642;
      font-size: 22px;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      opacity: 0.45;
      transition: opacity 0.2s ease;
    }
    .creator-cta span {
      display: block;
      font-size: 14px;
      font-weight: 500;
      color: #e5c37a;
      letter-spacing: 0;
      text-transform: none;
      opacity: 0.75;
    }
    .leaderboard-box {
      max-width: 520px;
      padding: 20px 24px;
      background: #0b0b0b;
      border: 1px solid rgba(255,182,66,0.35);
    }
    .leaderboard-header {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .leaderboard-tabs {
      display: flex;
      gap: 10px;
      background: rgba(255,182,66,0.08);
      padding: 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,182,66,0.25);
    }
    .leaderboard-tab {
      background: transparent;
      border: none;
      color: #ffce7a;
      font-weight: 700;
      font-size: 16px;
      padding: 8px 18px;
      border-radius: 999px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.1s ease;
      letter-spacing: 0.5px;
    }
    .leaderboard-tab:hover {
      background: rgba(255,182,66,0.12);
      transform: scale(1.02);
    }
    .leaderboard-tab.active {
      background: rgba(255,182,66,0.35);
      color: #ffffff;
      text-shadow: 0 0 12px rgba(255,182,66,0.6);
      font-weight: 700;
    }
    .leaderboard-panels {
      margin-top: 18px;
    }
    .leaderboard-panel {
      display: none;
    }
    .leaderboard-panel.active {
      display: block;
    }
    .leaderboard-list {
      max-height: 65vh;
      overflow-y: auto;
      padding: 12px 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .leaderboard-list::-webkit-scrollbar {
      display: none;
    }
    .leaderboard-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #15191f;
      border: 1px solid rgba(255,182,66,0.15);
      border-radius: 10px;
      padding: 12px 16px;
      gap: 12px;
      transition: background 0.2s ease;
    }
    .leaderboard-item:hover {
      background: #1a1f28;
    }
    .leaderboard-item.user-highlight {
      background: linear-gradient(135deg, rgba(255,182,66,0.2), rgba(255,206,122,0.15));
      border: 2px solid #ffb642;
      margin-bottom: 12px;
    }
    .leaderboard-rank {
      font-size: 18px;
      font-weight: 700;
      color: #ffb642;
      min-width: 48px;
      text-align: center;
    }
    .leaderboard-user {
      flex: 1;
      color: #d5d9e6;
      font-size: 15px;
      font-weight: 500;
    }
    .leaderboard-score {
      font-size: 17px;
      font-weight: 700;
      color: #ffb642;
      min-width: 60px;
      text-align: right;
    }
    .leaderboard-divider {
      text-align: center;
      color: #f0c67a;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin: 20px 0 6px;
    }
    .leaderboard-reward-summary {
      text-align: center;
      color: #f0c67a;
      margin-bottom: 18px;
    }
    .leaderboard-reward-summary .reward-total {
      font-size: 30px;
      font-weight: 700;
      color: #ffb642;
      margin-top: 6px;
    }
    .leaderboard-reward-progress {
      width: 100%;
      height: 8px;
      background: rgba(255,182,66,0.2);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 12px;
    }
    .leaderboard-reward-progress span {
      display: block;
      height: 100%;
      background: #ffb642;
      transition: width 0.3s ease;
    }
    .leaderboard-reward-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .leaderboard-reward-card {
      padding: 16px 20px;
      border-radius: 12px;
      border: 1px solid rgba(60, 90, 138, 0.4);
      background: rgba(39, 62, 102, 0.3);
      display: flex;
      align-items: center;
      gap: 12px;
      transition: border 0.2s ease, background 0.2s ease;
    }
    .leaderboard-reward-card.unlocked {
      background: rgba(255, 182, 66, 0.15);
      border-color: rgba(255, 182, 66, 0.4);
    }
    .leaderboard-reward-card .reward-name {
      font-size: 18px;
      font-weight: 700;
      color: #999;
    }
    .leaderboard-reward-card.unlocked .reward-name {
      color: #ffb642;
    }
    .leaderboard-reward-card .reward-status {
      font-size: 14px;
      color: #bbb;
      margin-top: 4px;
    }
    .leaderboard-reward-card .reward-amount {
      font-size: 18px;
      font-weight: 700;
      color: #666;
    }
    .leaderboard-reward-card.unlocked .reward-amount {
      color: #ffb642;
    }
    /* Share Modal Buttons */
    .share-option-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: rgba(39, 62, 102, 0.4);
      border: 1px solid rgba(60, 90, 138, 0.5);
      border-radius: 12px;
      color: #fff;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      width: 100%;
      box-sizing: border-box;
    }
    .share-option-btn:hover {
      background: rgba(39, 62, 102, 0.7);
      border-color: rgba(60, 90, 138, 0.8);
      transform: translateY(-2px);
    }
    .share-option-btn:active {
      transform: translateY(0);
    }
    .share-option-btn svg {
      flex-shrink: 0;
    }
    .share-option-btn span {
      flex: 1;
      text-align: left;
    }
    #shareCopyBtn svg {
      stroke: #ffb642;
    }
    #shareTelegramBtn svg {
      fill: #0088cc;
    }
    #shareXBtn svg {
      fill: #fff;
    }
    /* Achievement Toast Center */
    .achievement-toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 999999 !important; /* Higher than focus-mode (90000) */
      background: linear-gradient(135deg, rgba(255, 182, 66, 1) 0%, rgba(255, 144, 0, 1) 100%); /* Full opacity */
      border: 4px solid #ffb642;
      border-radius: 24px;
      padding: 24px 32px;
      text-align: center;
      box-shadow: 0 20px 80px rgba(255, 182, 66, 0.9), 0 0 100px rgba(255, 144, 0, 0.7);
      opacity: 0;
      transform-origin: center;
      transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      pointer-events: none;
      backdrop-filter: blur(10px);
      max-width: 90%; /* Responsive width */
      min-width: 280px; /* Smaller minimum for mobile */
    }
    .achievement-toast-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      border: none;
      background: rgba(0, 0, 0, 0.2);
      color: #fff;
      font-size: 28px;
      font-weight: 700;
      line-height: 1;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
      pointer-events: all !important; /* ✅ Always clickable, even when parent has pointer-events: none */
      z-index: 10; /* ✅ Above all other elements in toast */
    }
    .achievement-toast-close:hover {
      background: rgba(0, 0, 0, 0.4);
    }
    .achievement-toast.show {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
      animation: bounceIn 0.6s ease-out;
      pointer-events: all !important; /* Allow user to interact with toast */
    }
    .achievement-toast-title {
      font-size: 36px;
      font-weight: 800;
      color: #000;
      margin-bottom: 16px;
      text-shadow: 0 3px 8px rgba(255,255,255,0.5);
      letter-spacing: 1px;
    }
    .achievement-toast-subtitle {
      font-size: 24px;
      font-weight: 700;
      color: #1a1a1a;
      margin-bottom: 12px;
    }
    .achievement-toast-reward {
      font-size: 48px;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 4px 12px rgba(0,0,0,0.7), 0 0 20px rgba(255,255,255,0.3);
      letter-spacing: 2px;
    }
    /* Mobile responsive toast */
    @media (max-width: 480px) {
      .achievement-toast {
        padding: 20px 24px;
        min-width: 260px;
        max-width: 85%;
        border-radius: 16px;
      }
      .achievement-toast-title {
        font-size: 28px;
        margin-bottom: 12px;
    }
    .achievement-toast-subtitle {
        font-size: 18px;
      margin-bottom: 8px;
    }
    .achievement-toast-reward {
        font-size: 36px;
        letter-spacing: 1px;
      }
    }
    /* Daily Check-in Toast */
    .daily-checkin-toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 999999;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: 4px solid #8b5cf6;
      border-radius: 24px;
      padding: 32px 40px;
      text-align: center;
      box-shadow: 0 20px 80px rgba(102, 126, 234, 0.6), 0 0 100px rgba(118, 75, 162, 0.5);
      opacity: 0;
      transform-origin: center;
      transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      pointer-events: none;
      backdrop-filter: blur(15px);
      max-width: 90%;
      min-width: 320px;
    }
    .daily-checkin-toast.show {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
      animation: dailyBounceIn 0.8s ease-out;
    }
    .daily-checkin-icon {
      font-size: 64px;
      margin-bottom: 16px;
      animation: dailyPulse 2s ease-in-out infinite;
    }
    .daily-checkin-title {
      font-size: 32px;
      font-weight: 800;
      color: #fff;
      margin-bottom: 20px;
      text-shadow: 0 3px 8px rgba(0,0,0,0.3);
      letter-spacing: 1px;
    }
    .daily-checkin-stats {
      display: flex;
      justify-content: center;
      gap: 32px;
      margin-bottom: 20px;
    }
    .daily-checkin-stat {
      text-align: center;
    }
    .daily-checkin-stat-value {
      font-size: 40px;
      font-weight: 900;
      color: #fbbf24;
      text-shadow: 0 3px 10px rgba(0,0,0,0.5);
      display: block;
      margin-bottom: 4px;
    }
    .daily-checkin-stat-label {
      font-size: 14px;
      font-weight: 600;
      color: rgba(255,255,255,0.9);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .daily-checkin-reward {
      font-size: 44px;
      font-weight: 900;
      color: #10b981;
      background: rgba(16, 185, 129, 0.2);
      border: 2px solid #10b981;
      border-radius: 16px;
      padding: 16px 32px;
      text-shadow: 0 4px 12px rgba(16, 185, 129, 0.5);
      letter-spacing: 2px;
      margin-top: 12px;
      white-space: nowrap; /* Force single line */
    }
    @media (max-width: 480px) {
      .daily-checkin-toast {
        padding: 24px 28px;
        min-width: 280px;
        max-width: 90%;
      }
      .daily-checkin-icon {
        font-size: 48px;
      }
      .daily-checkin-title {
        font-size: 24px;
        margin-bottom: 16px;
      }
      .daily-checkin-stats {
        gap: 20px;
      }
      .daily-checkin-stat-value {
        font-size: 32px;
      }
      .daily-checkin-stat-label {
        font-size: 12px;
      }
      .daily-checkin-reward {
        font-size: 28px;
        padding: 12px 20px;
        letter-spacing: 1px;
      }
    }
    /* Create Game Toast */
    .create-game-toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 999999;
      background: linear-gradient(135deg, #ffb642 0%, #ff8c00 100%);
      border: 4px solid #ffb642;
      border-radius: 24px;
      padding: 32px 40px;
      text-align: center;
      box-shadow: 0 20px 80px rgba(255, 182, 66, 0.6), 0 0 100px rgba(255, 140, 0, 0.5);
      opacity: 0;
      transform-origin: center;
      transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      pointer-events: none;
      backdrop-filter: blur(15px);
      max-width: 90%;
      min-width: 320px;
      cursor: pointer;
    }
    .create-game-toast.show {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
      animation: dailyBounceIn 0.8s ease-out;
      pointer-events: all;
    }
    .create-game-toast-content {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }
    .create-game-icon {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }
    .create-game-icon::before {
      content: '+';
      font-size: 32px;
      font-weight: 300;
      color: #ffb642;
      line-height: 1;
      text-shadow: 0 2px 8px rgba(255, 182, 66, 0.5);
    }
    .create-game-text {
      font-size: 28px;
      font-weight: 800;
      color: #fff;
      text-shadow: 0 3px 8px rgba(0,0,0,0.3);
      letter-spacing: 1px;
    }
    @media (max-width: 480px) {
      .create-game-toast {
        padding: 24px 28px;
        min-width: 280px;
        max-width: 90%;
      }
      .create-game-icon {
        width: 40px;
        height: 40px;
        border-radius: 10px;
      }
      .create-game-icon::before {
        font-size: 28px;
      }
      .create-game-text {
        font-size: 20px;
      }
    }
    @keyframes dailyBounceIn {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    @keyframes dailyPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.15); }
    }
    @keyframes bounceIn {
      0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.05); }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    /* Achievement Icon Shake */
    @keyframes shakeIcon {
      0%, 100% { transform: rotate(0deg); }
      10%, 30%, 50%, 70%, 90% { transform: rotate(-15deg); }
      20%, 40%, 60%, 80% { transform: rotate(15deg); }
    }
    .icon-wrapper[data-role="leaderboard"].shake {
      animation: shakeIcon 0.8s ease-in-out;
    }
    .icon-wrapper[data-role="leaderboard"] svg {
      transform: scale(1); /* Same size as heart icon */
    }
    .icon-wrapper[data-role="leaderboard"].shake svg {
      fill: #ffb642;
      filter: drop-shadow(0 0 8px rgba(255, 182, 66, 0.8));
    }
    /* Confetti Canvas */
    .confetti-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100001;
    }
    body.focus-mode {
      padding-top: env(safe-area-inset-top);
      overscroll-behavior: none;
      overflow: hidden;
      height: 100svh;
      position: fixed;
      inset: 0;
      width: 100%;
    }
    body.focus-mode .main-header,
    body.focus-mode .page-footer {
      display: none !important;
    }
    body.focus-mode .game-container {
      height: calc(100svh - env(safe-area-inset-top));
      padding: 0;
      overflow: hidden;
      scroll-snap-type: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: fixed;
      top: env(safe-area-inset-top);
      left: 50%;
      transform: translateX(-50%);
      width: min(calc(100vw - 4px), 780px);
    }
    body.focus-mode .game-card {
      width: 100%;
      max-width: 720px;  /* ← FORCE TABLE VERSION! */
      margin: 0;
      padding: 0;
    }
    body.focus-mode .game-stage {
      border-radius: 18px;
      box-shadow: 0 12px 48px rgba(0,0,0,0.7);
      touch-action: none !important;
      -ms-touch-action: none !important;
      overscroll-behavior: contain;
    }
    body.focus-mode .game-card:not(.is-focus-active) {
      display: none !important;
    }
    body.focus-mode .game-footer {
      display: none !important;
    }
    body.focus-mode .focus-toggle {
      background: rgba(0, 0, 0, 0.55);
      opacity: 0.55;
    }
    body.focus-mode .game-card:not(.is-focus-active) {
      display: none !important;
    }

    @media (max-width: 800px) {
      /* MOBILE: pixel-space-shooter handles its own scaling internally */
      /* Override common CSS to allow game 14 to control its own iframe */
      .game-card[data-game-id="pixel-space-shooter"] .game-stage {
        /* Keep aspect-ratio but allow game to scale internally */
        aspect-ratio: 720 / 1000 !important;
        width: min(100vw, 720px) !important;
        max-width: 720px !important;
      }
      .game-card[data-game-id="pixel-space-shooter"] .game-stage iframe {
        /* Keep absolute positioning but let game scale internally */
        position: absolute !important;
        inset: 0 !important;
        width: 100% !important;
        height: 100% !important;
      }
      
      /* HEADER - Reduce by 25% */
      :root { --header-h: 39px; } /* Reduced from 52px */
      .main-header {
        height: var(--header-h);
        padding: 0 14px;
      }
      .logo {
        gap: 8px;
      }
      .docs-menu-btn {
        width: 30px;
        height: 30px;
        border-radius: 6px;
      }
      .hamburger-icon {
        width: 16px;
        height: 16px;
      }
      .logo-text {
        font-size: 17px; /* Reduced 25% from 22px */
        letter-spacing: 0.8px;
      }
      .header-actions {
        gap: 8px;
      }
      .icon-button {
        width: 30px; /* Reduced 25% from 40px */
        height: 30px; /* Reduced 25% from 40px */
        border-radius: 9px;
      }
      .icon-button svg.header-icon {
        width: 16px; /* Reduced accordingly */
        height: 16px;
      }
      .wallet-status-button {
        height: 30px; /* Reduced 25% from 40px */
        padding: 0 10px;
        font-size: 12px;
      }
      .wallet-status-icon {
        width: 14px;
        height: 12px;
      }
      .nav-dropdown {
        width: 180px;
        right: 0;
      }
      
      /* FOOTER - Increase by 25% */
      .game-footer {
        gap: 5px; /* Increased from 4px */
        padding: 5px 12px 8px; /* Increased from 4px 10px 6px */
      }
      .game-icons {
        padding: 0; /* Remove padding to align to edge */
      }
      .game-icons-left {
        gap: 8px;
        margin-left: -8px; /* Pull closer to left edge by 50% */
      }
      .game-icons-right {
        gap: 8px;
        margin-right: -8px; /* Pull closer to right edge by 50% */
      }
      .icon-wrapper {
        gap: 6px; /* Reduced from 8px for tighter icon+text */
      }
      .icon-wrapper button {
        width: 25px; /* Reduced 25% from 33px */
        height: 25px;
      }
      .icon-wrapper svg {
        width: 21px; /* Reduced 25% from 28px */
        height: 21px;
        stroke-width: 2.2;
      }
      .icon-wrapper button span {
        font-size: 19px !important; /* MC text reduced 25% from 25px */
      }
      .icon-count {
        font-size: 11px; /* Reduced 25% from 14px */
        min-width: 20px;
      }
      .creator-text {
        font-size: 11px; /* Keep compact size on mobile */
      }
    }

    /* Like button active state */
    .game-icons button.liked {
      color: #ff4d4d;
      transform: scale(1.08);
    }
    /* Comments overlay */
    .comments-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:100000}
    .comments-overlay.open{display:flex}
    .comments-box{width:720px;max-width:95vw;background:#0b0b0b;border:1px solid #1f1f1f;border-radius:12px;box-shadow:0 10px 30px #000a;display:flex;flex-direction:column}
    .comments-header{display:flex;align-items:center;justify-content:flex-end;padding:10px 14px;border-bottom:1px solid #1f1f1f}
    .comments-title{display:none}
    .comments-list{height:50vh;overflow:auto;padding:10px 14px;display:flex;flex-direction:column;gap:10px;scrollbar-width:none;-ms-overflow-style:none}
    .comments-list::-webkit-scrollbar{display:none}
    .comment-item{background:#101010;border:1px solid #1f1f1f;border-radius:10px;padding:10px}
    .comment-meta{color:#8aa; font-size:24px;margin-bottom:8px}
    .comment-text{font-size:28px;line-height:1.6;white-space:pre-wrap}
    .comments-input{display:flex;gap:8px;padding:10px 14px;border-top:1px solid #1f1f1f;position:relative;z-index:100001}
    .comments-input textarea{flex:1;min-height:60px;max-height:160px;background:#0e0e0e;color:#fff;border:1px solid #2a2a2a;border-radius:8px;padding:10px;font-size:20px;resize:vertical;pointer-events:auto !important;cursor:text !important;z-index:100002;position:relative}
    .comments-input button{height:56px;background:#273e66;color:#fff;border:1px solid #3c5a8a;border-radius:8px;padding:0 16px;cursor:pointer;font-size:32px;pointer-events:auto !important;z-index:100002;position:relative}
    .comments-footer{display:flex;justify-content:center;padding:10px 14px}
    .comments-footer button{background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:8px;padding:8px 16px;cursor:pointer;font-size:16px}
    #statsOverlay .comments-box{max-width:460px;padding:24px 28px;background:#0b0b0b;border:1px solid rgba(255,182,66,0.35)}
    .stats-header{display:flex;align-items:center;justify-content:space-between;padding-bottom:12px;margin-bottom:12px;border-bottom:1px solid rgba(255,182,66,0.25)}
    .stats-title{font-size:20px;font-weight:600;color:#ffb642;letter-spacing:1px;text-transform:uppercase}
    .stats-content{display:flex;flex-direction:column;gap:18px;align-items:center;text-align:center;padding:12px 0 8px}
    .stats-item{display:flex;flex-direction:column;gap:6px;align-items:center}
    .stats-label{font-size:16px;color:#f0c67a;letter-spacing:1px;text-transform:uppercase}
    .stats-metric{font-size:42px;font-weight:700;color:#ffb642;text-shadow:0 0 18px rgba(255,182,66,0.35)}
    .stats-divider{width:80%;height:1px;background:rgba(255,182,66,0.2)}
    .stats-note{font-size:14px;color:#bfa36a}
    .stats-data-cache {
      position: absolute;
      width: 0;
      height: 0;
      overflow: hidden;
      opacity: 0;
    }
    #walletOverlay .comments-box{max-width:520px;padding:20px 24px;gap:0}
    .wallet-sheet{display:flex;flex-direction:column;gap:16px}
    .wallet-header{display:flex;align-items:center;justify-content:space-between;padding-bottom:12px;border-bottom:1px solid #1f1f1f}
    .wallet-title{font-size:20px;font-weight:600;color:#0ff;letter-spacing:0.8px;text-transform:uppercase}
    .wallet-body{display:flex;flex-direction:column;gap:12px;color:#d5d9e6}
    .wallet-row{display:flex;align-items:center;justify-content:space-between;background:#15191f;border:1px solid #1f242c;border-radius:12px;padding:12px 16px}
    .wallet-row span:first-child{font-size:14px;color:#9aa}
    .wallet-row span:last-child{font-size:16px;font-weight:600;color:#0ff}
    .wallet-actions{display:flex;justify-content:flex-end;gap:12px;margin-top:8px}
    .wallet-actions button{background:#273e66;color:#fff;border:1px solid #3c5a8a;border-radius:10px;padding:10px 18px;font-size:15px;font-weight:600;cursor:pointer}
    .wallet-actions button.secondary{background:none;border:1px solid #2a2f38;color:#bbb}
    @media (min-width: 1024px) {
      /* DESKTOP: Ensure all games maintain 720px width (original size) */
      .game-card {
        width: 720px !important;
        max-width: 720px !important;
      }
      .game-card .game-stage {
        width: 100% !important;
        aspect-ratio: 720 / 1000 !important;
      }
      .game-card .game-stage iframe {
        width: 100% !important;
        height: 100% !important;
      }
      
      /* DESKTOP: pixel-space-shooter handles its own scaling */
      .game-card[data-game-id="pixel-space-shooter"] .game-stage {
        aspect-ratio: none !important;
        width: auto !important;
        height: auto !important;
      }
      .game-card[data-game-id="pixel-space-shooter"] .game-stage iframe {
        position: relative !important;
        inset: auto !important;
        width: 720px !important;
        height: 1000px !important;
      }
      
      .game-footer {
        gap: 10px;
        padding: 8px 16px 12px;
        font-size: 15.5px;
      }
      .game-icons {
        gap: 22px;
      }
      .icon-wrapper button {
        width: 42px;
        height: 42px;
      }
      .icon-wrapper svg {
        width: 36px;
        height: 36px;
        stroke-width: 2.6;
      }
      .icon-count {
        font-size: 17px;
        min-width: 28px;
      }
      .creator-text {
        font-size: 17px;
        line-height: 1.4;
        letter-spacing: 0.25px;
      }
    }
  </style>
</head>
<body>
  <!-- HEADER: Logo left, Dropdown right, single row -->
  <div class="main-header">
    <div class="logo">
      <div class="hamburger-wrapper">
        <button id="hamburgerButton" class="docs-menu-btn" aria-haspopup="true" aria-expanded="false" title="Menu">
          <svg class="hamburger-icon" viewBox="0 0 24 24" aria-hidden="true">
            <line x1="3" y1="6" x2="21" y2="6" stroke="#ffb642" stroke-width="2.5" stroke-linecap="round"/>
            <line x1="3" y1="12" x2="21" y2="12" stroke="#ffb642" stroke-width="2.5" stroke-linecap="round"/>
            <line x1="3" y1="18" x2="21" y2="18" stroke="#ffb642" stroke-width="2.5" stroke-linecap="round"/>
          </svg>
        </button>
        <div class="nav-dropdown" id="hamburgerDropdown" role="menu" aria-hidden="true">
          <div class="dropdown-list" id="hamburgerList">
            <div class="dropdown-item" data-action="docs">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; stroke: #ffb642; fill: none; stroke-width: 2; margin-right: 8px;">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
              </svg>
              Docs
            </div>
            <div class="dropdown-item" data-action="stats">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; stroke: #ffb642; fill: none; stroke-width: 2; margin-right: 8px;">
                <rect x="3" y="3" width="7" height="7"></rect>
                <rect x="14" y="3" width="7" height="7"></rect>
                <rect x="14" y="14" width="7" height="7"></rect>
                <rect x="3" y="14" width="7" height="7"></rect>
              </svg>
              Stats
            </div>
          </div>
        </div>
      </div>
      <span class="logo-text" id="memeplayLogo" style="cursor:pointer;">MEMEPLAY</span>
      <span id="headerEarnedFlash" class="header-flash"></span>
    </div>
    <div class="header-actions">
      <div class="search-wrapper">
        <button id="searchToggleButton" class="icon-button search-button" aria-haspopup="true" aria-expanded="false" title="Browse categories">
          <svg class="header-icon" viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="10.5" cy="10.5" r="6.5"></circle>
            <path d="M15.5 15.5L21 21"></path>
          </svg>
        </button>
        <div class="nav-dropdown" id="navDropdown" role="menu" aria-hidden="true">
          <div class="dropdown-list" id="dropdownList">
            <div class="dropdown-item active" data-category="Recommended">Recommended</div>
            <div class="dropdown-item" data-category="Liked">Liked</div>
            <div class="dropdown-item" data-category="Trending">Trending</div>
            <div class="dropdown-item" data-category="Popular">Popular</div>
          </div>
        </div>
      </div>
      <button id="creatorButton" class="icon-button" title="Create Game">
        <svg class="header-icon" viewBox="0 0 24 24" aria-hidden="true">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
        </button>
      <button id="walletConnectBtn" class="icon-button wallet-connect" aria-label="Connect MetaMask">
        <img src="assets/icons/metamask.svg" alt="MetaMask" />
      </button>
      <button id="walletStatusBtn" class="wallet-status-button" hidden aria-label="Wallet details">
        <img src="assets/icons/wallet.svg" alt="Wallet" class="wallet-status-icon" />
        <span id="walletStatusText"></span>
      </button>
    </div>
    <div class="stats-data-cache" aria-hidden="true">
      <span id="streakCount">0</span>
      <span id="headerEarned">0</span>
    </div>
  </div>

  

  <div class="game-container"></div>
    

  
  <div id="commentsOverlay" class="comments-overlay">
    <div class="comments-box">
      <div class="comments-header">
        <div class="comments-title"></div>
        <button id="commentsCloseBtn" style="background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:6px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:42px;line-height:1;font-weight:700;">×</button>
      </div>
      <div id="commentsList" class="comments-list"></div>
      <div class="comments-footer">
        <button id="commentsLoadMore">Load more</button>
      </div>
      <div class="comments-input">
        <textarea id="commentsTextarea" placeholder="Write a comment..."></textarea>
        <button id="commentsPostBtn">Post</button>
      </div>
    </div>
  </div>
  
  <div id="walletOverlay" class="comments-overlay">
    <div class="comments-box wallet-sheet">
      <div class="wallet-header">
        <div class="wallet-title">Wallet</div>
        <button id="walletCloseBtn" style="background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:6px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:42px;line-height:1;font-weight:700;">×</button>
      </div>
      <div class="wallet-body">
        <div class="wallet-row">
          <span>Address</span>
          <span id="walletOverlayAddress">-</span>
        </div>
        <div class="wallet-row">
          <span>Streak</span>
          <span id="walletOverlayStreak">0</span>
        </div>
        <div class="wallet-row">
          <span>PLAY points</span>
          <span id="walletOverlayPlays">0</span>
        </div>
      </div>
      <div class="wallet-actions">
        <button class="secondary" id="walletCopyBtn">Copy address</button>
        <button id="walletDisconnectBtn">Disconnect</button>
      </div>
    </div>
  </div>
  
  <div id="creatorOverlay" class="comments-overlay">
    <div class="comments-box creator-box">
      <div class="wallet-header" style="justify-content:flex-end;">
        <button id="creatorCloseBtn" style="background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:6px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:42px;line-height:1;font-weight:700;">×</button>
      </div>
      <div class="creator-hero">Build your game with MemePlay AI studio.</div>
      <div class="creator-points">
        <div class="creator-point">
          <div class="creator-point-icon">↑</div>
          <div>Instantly public + meme coin exposure for featured drops.</div>
        </div>
        <div class="creator-point">
          <div class="creator-point-icon">$</div>
          <div>Earn additional airdrop tokens every time players engage.</div>
        </div>
      </div>
      <div class="creator-cta">
        Create game
        <span>(coming soon)</span>
      </div>
    </div>
  </div>

  <div id="statsOverlay" class="comments-overlay">
    <div class="comments-box">
      <div class="stats-header">
        <div class="stats-title">MemePlay Stats</div>
        <button id="statsCloseBtn" style="background:none;border:1px solid rgba(255,182,66,0.4);color:#ffce7a;border-radius:8px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:36px;line-height:1;font-weight:700;">×</button>
      </div>
      <div class="stats-content">
        <div class="stats-item">
          <div class="stats-label">Current Streak</div>
          <div class="stats-metric" id="statsStreak">0</div>
        </div>
        <div class="stats-divider"></div>
        <div class="stats-item">
          <div class="stats-label">Play Points</div>
          <div class="stats-metric" id="statsPlays">0</div>
        </div>
        <div class="stats-note">Lifetime PLAY points keep growing — keep gaming daily!</div>
      </div>
    </div>
  </div>

  <div id="leaderboardOverlay" class="comments-overlay">
    <div class="comments-box leaderboard-box">
      <div class="stats-header leaderboard-header">
        <div class="leaderboard-tabs">
          <button class="leaderboard-tab active" data-panel="scores">🏆 SCORES</button>
          <button class="leaderboard-tab" data-panel="rewards">🎖 REWARDS</button>
        </div>
        <button id="leaderboardCloseBtn" style="background:none;border:1px solid rgba(255,182,66,0.4);color:#ffce7a;border-radius:8px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:36px;line-height:1;font-weight:700;margin-left:auto;">×</button>
      </div>
      <div class="leaderboard-panels">
        <div id="leaderboardPanelScores" class="leaderboard-panel active">
          <div id="leaderboardList" class="leaderboard-list"></div>
        </div>
        <div id="leaderboardPanelRewards" class="leaderboard-panel">
          <div id="leaderboardRewardSummary" class="leaderboard-reward-summary"></div>
          <div id="leaderboardRewardList" class="leaderboard-reward-list"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="shareOverlay" class="comments-overlay">
    <div class="comments-box" style="max-width:420px;padding:28px 32px;">
      <div class="stats-header">
        <div class="stats-title">Share Game</div>
        <button id="shareCloseBtn" style="background:none;border:1px solid rgba(255,182,66,0.4);color:#ffce7a;border-radius:8px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:36px;line-height:1;font-weight:700;">×</button>
      </div>
      <div style="display:flex;flex-direction:column;gap:14px;padding:20px 0 10px;">
        <button id="shareCopyBtn" class="share-option-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
          </svg>
          <span>Copy Link</span>
        </button>
        <button id="shareTelegramBtn" class="share-option-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.64 6.8c-.15 1.58-.8 5.42-1.13 7.19-.14.75-.42 1-.68 1.03-.58.05-1.02-.38-1.58-.75-.88-.58-1.38-.94-2.23-1.5-.99-.65-.35-1.01.22-1.59.15-.15 2.71-2.48 2.76-2.69a.2.2 0 00-.05-.18c-.06-.05-.14-.03-.21-.02-.09.02-1.49.95-4.22 2.79-.4.27-.76.41-1.08.4-.36-.01-1.04-.2-1.55-.37-.63-.2-1.12-.31-1.08-.66.02-.18.27-.36.74-.55 2.92-1.27 4.86-2.11 5.83-2.51 2.78-1.16 3.35-1.36 3.73-1.36.08 0 .27.02.39.12.1.08.13.19.14.27-.01.06.01.24 0 .38z"/>
          </svg>
          <span>Share on Telegram</span>
        </button>
        <button id="shareXBtn" class="share-option-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
          </svg>
          <span>Share on X</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Achievement Toast -->
  <div id="achievementToast" class="achievement-toast">
    <button id="achievementToastClose" class="achievement-toast-close" aria-label="Close">×</button>
    <div class="achievement-toast-title">🎉 Reward Earned!</div>
    <div class="achievement-toast-subtitle" id="achievementName">⭐ 10s Play Reward</div>
    <div class="achievement-toast-reward" id="achievementReward">+100 PLAY</div>
  </div>

  <!-- Confetti Canvas -->
  <canvas id="confettiCanvas" class="confetti-canvas"></canvas>

  <script>
    // Game management system (auto-activate visible card)
    let currentActiveGame = null;
    const preloadedGames = new Set(); // Track preloaded games
    
    // Centralized game states (foundation for active/wait/hidden slots)
    const GAME_STATES = Object.freeze({
      HIDDEN: 'hidden',
      WAITING: 'waiting',
      ACTIVE: 'active'
    });
    const gameStateStore = new Map();
    window.MEMEPLAY_GAME_STATES = GAME_STATES;
    
    // ✅ PERFORMANCE: Debug logging helpers (reduce console.log overhead on mobile)
    // Set window.__DEBUG_SCROLL = true in console to enable debug logs
    // Set window.__DEBUG_INFO = true to enable info logs
    const debugLog = (...args) => {
      if (window.__DEBUG_SCROLL) console.log(...args);
    };
    const infoLog = (...args) => {
      if (window.__DEBUG_INFO) console.log(...args);
    };
    // console.error and console.warn are always enabled (critical for error tracking)
    
    function getGameCardElement(gameId) {
      if (!gameId) return null;
      return document.getElementById(gameId) ||
             document.querySelector(`.game-card[data-game-id="${gameId}"]`);
    }
    
    function setGameState(gameId, nextState, cardRef = null) {
      if (!gameId) return;
      const validStates = GAME_STATES;
      const normalizedState = Object.values(validStates).includes(nextState)
        ? nextState
        : validStates.HIDDEN;
      const card = cardRef || getGameCardElement(gameId);
      if (!card) return;
      if (card.dataset.gameState === normalizedState) {
        gameStateStore.set(gameId, normalizedState);
        return;
      }
      card.dataset.gameState = normalizedState;
      gameStateStore.set(gameId, normalizedState);
      card.classList.toggle('state-active', normalizedState === validStates.ACTIVE);
      card.classList.toggle('state-waiting', normalizedState === validStates.WAITING);
      card.classList.toggle('state-hidden', normalizedState === validStates.HIDDEN);
    }
    
    function getGameState(gameId) {
      if (!gameId) return GAME_STATES.HIDDEN;
      return gameStateStore.get(gameId) || GAME_STATES.HIDDEN;
    }
    
    function initializeGameStates(cards = []) {
      cards.forEach((card) => {
        const gid = card?.id || card?.dataset?.gameId;
        if (gid) {
          setGameState(gid, GAME_STATES.HIDDEN, card);
        }
      });
    }
    window.setGameState = setGameState;
    window.getGameState = getGameState;
    window.initializeGameStates = initializeGameStates;
    
    // Game URLs mapping (active games only)
    const gameUrls = {
      'bird-squash': 'https://bird-squash-dev.lovable.app',
      'wojak-btc-blast': 'https://wojak-btc-blast.lovable.app',
      'moonshot-bnb': 'https://moonshot-bnb.lovable.app',
      'game-detective': 'https://game-detective-clone.lovable.app',
      'monkey-crypto-climb': 'https://monkey-crypto-climb.lovable.app',
      'crypto-arrow': 'https://crypto-arrow1.lovable.app',
      'inverse-cramer': 'https://inverse-cramer.lovable.app',
      'brick-fallen-crypto': 'games/brick-fallen-crypto/index.html',
      'pacman-memeplay': 'https://pacman-memeplay.lovable.app',
      'story-shape-studio': 'https://story-shape-studio.lovable.app',
      'pixel-space-shooter': 'games/pixel-space-shooter/index.html',
      'rocket-bnb': 'games/rocket-bnb/index.html',
      'crypto-blocks': 'games/crypto-blocks/index.html'
    };
    const PACMAN_TEMPLATE_ID = 'pacman-template';
    const BLOCKS_TEMPLATE_ID = 'blocks-8x8';
    const PACMAN_STORAGE_PREFIX = 'pacman_brand_config_';
    const BLOCKS_STORAGE_PREFIX = 'blocks_brand_config_';
  
    // Get all game cards in order
    function getAllGameCards() {
      const cards = Array.from(document.querySelectorAll('.game-card'))
      if (cards.length === 0) {
        console.warn('⚠️ No game cards found in DOM')
        return []
      }
      return cards
        .map(card => ({
          id: card.id || card.dataset?.gameId,
          element: card
        }))
        .filter(item => {
          if (!item.id) return false
          // ✅ FIX: Loại bỏ các game Pacman có đường dẫn kiểu cũ (pacman-game-*)
          // Chỉ giữ lại các game có đường dẫn kiểu mới (pacman-{số})
          if (item.id.startsWith('pacman-game-')) {
            console.log(`🗑️ Filtering out old format Pacman game: ${item.id}`)
            return false
          }
          return true
        })
    }
    
    // ========= VIRTUAL SCROLL HELPERS (Step 4.2) =========
    const VIRTUAL_SCROLL_DEFAULTS = Object.freeze({
      bufferBefore: 4,
      bufferAfter: 6,
      minVisible: 12
    })
    
    const virtualScrollState = window.__memeplayVirtual || {}
    virtualScrollState.defaults = VIRTUAL_SCROLL_DEFAULTS
    window.__memeplayVirtual = virtualScrollState
    
    function computeViewportGameWindow(options = {}) {
      const container = document.querySelector('.game-container')
      const cards = container ? Array.from(container.querySelectorAll('.game-card')) : []
      const totalCards = cards.length
      const noContainerResult = {
        startIndex: 0,
        endIndex: -1,
        ids: [],
        totalCards,
        visibleCount: 0,
        reason: container ? 'no-cards' : 'no-container'
      }
      if (!container || !totalCards) {
        virtualScrollState.lastWindow = noContainerResult
        return noContainerResult
      }
      
      const settings = {
        bufferBefore: Number.isFinite(options.bufferBefore) ? options.bufferBefore : VIRTUAL_SCROLL_DEFAULTS.bufferBefore,
        bufferAfter: Number.isFinite(options.bufferAfter) ? options.bufferAfter : VIRTUAL_SCROLL_DEFAULTS.bufferAfter,
        minVisible: Number.isFinite(options.minVisible) ? options.minVisible : VIRTUAL_SCROLL_DEFAULTS.minVisible
      }
      
      const containerRect = container.getBoundingClientRect()
      const containerTop = containerRect.top
      const containerBottom = containerRect.bottom
      
      let firstVisible = -1
      let lastVisible = -1
      cards.forEach((card, idx) => {
        const rect = card.getBoundingClientRect()
        const intersects = rect.bottom > containerTop && rect.top < containerBottom
        if (intersects) {
          if (firstVisible === -1) firstVisible = idx
          lastVisible = idx
        }
      })
      
      if (firstVisible === -1) {
        let closestIdx = 0
        let minDistance = Infinity
        const containerCenter = containerTop + (containerRect.height / 2)
        cards.forEach((card, idx) => {
          const rect = card.getBoundingClientRect()
          const cardCenter = rect.top + rect.height / 2
          const distance = Math.abs(cardCenter - containerCenter)
          if (distance < minDistance) {
            minDistance = distance
            closestIdx = idx
          }
        })
        firstVisible = closestIdx
        lastVisible = closestIdx
      }
      
      let startIndex = Math.max(0, firstVisible - settings.bufferBefore)
      let endIndex = Math.min(totalCards - 1, lastVisible + settings.bufferAfter)
      
      const currentWindowSize = endIndex >= startIndex ? (endIndex - startIndex + 1) : 0
      if (currentWindowSize < settings.minVisible) {
        const deficit = settings.minVisible - currentWindowSize
        const extendBefore = Math.min(startIndex, Math.floor(deficit / 2))
        const extendAfter = deficit - extendBefore
        startIndex = Math.max(0, startIndex - extendBefore)
        endIndex = Math.min(totalCards - 1, endIndex + extendAfter)
        if ((endIndex - startIndex + 1) < settings.minVisible) {
          const remaining = settings.minVisible - (endIndex - startIndex + 1)
          startIndex = Math.max(0, startIndex - remaining)
        }
      }
      
      if (endIndex < startIndex) {
        endIndex = startIndex
      }
      
      const ids = cards.slice(startIndex, endIndex + 1)
        .map(card => card.id || card.dataset?.gameId)
        .filter(Boolean)
      
      const result = {
        startIndex,
        endIndex,
        totalCards,
        ids,
        visibleCount: Math.max(0, lastVisible - firstVisible + 1),
        bufferBefore: settings.bufferBefore,
        bufferAfter: settings.bufferAfter
      }
      virtualScrollState.lastWindow = result
      if (window.__DEBUG_SCROLL) {
        debugLog(`📐 [VIRTUAL] Visible window ${startIndex}-${endIndex} (viewport count: ${result.visibleCount}/${totalCards})`)
      }
      return result
    }
    
    virtualScrollState.enabled = true
    virtualScrollState.lastSignature = ''
    virtualScrollState.hiddenCount = 0
    
    function applyVirtualVisibility(windowInfo, { reason = '' } = {}) {
      if (!virtualScrollState.enabled) return windowInfo
      const cards = Array.from(document.querySelectorAll('.game-card'))
      if (!cards.length) return windowInfo
      
      if (!windowInfo || !Array.isArray(windowInfo.ids) || windowInfo.ids.length === 0) {
        if (virtualScrollState.lastSignature) {
          cards.forEach(card => card.classList.remove('virtual-hidden'))
          virtualScrollState.lastSignature = ''
          virtualScrollState.hiddenCount = 0
        }
        return windowInfo
      }
      
      const keepIds = new Set(windowInfo.ids)
      if (currentActiveGame) keepIds.add(currentActiveGame)
      if (window.__memeplayPinnedGameId) keepIds.add(window.__memeplayPinnedGameId)
      if (window.__memeplayHighPriorityGameId) keepIds.add(window.__memeplayHighPriorityGameId)
      
      const signature = `${windowInfo.startIndex}-${windowInfo.endIndex}-${Array.from(keepIds).join(',')}`
      if (signature === virtualScrollState.lastSignature) return windowInfo
      virtualScrollState.lastSignature = signature
      
      let hiddenCount = 0
      cards.forEach(card => {
        const gid = card.id || card.dataset?.gameId
        if (!gid) return
        const shouldShow = keepIds.has(gid)
        card.classList.toggle('virtual-hidden', !shouldShow)
        if (!shouldShow) hiddenCount += 1
      })
      virtualScrollState.hiddenCount = hiddenCount
      if (window.__DEBUG_SCROLL) {
        debugLog(`🌓 [VIRTUAL] visible=${cards.length - hiddenCount}, hidden=${hiddenCount}, reason=${reason || 'auto'}`)
      }
      return windowInfo
    }
    
    function refreshVirtualVisibility(reason = 'manual') {
      if (!virtualScrollState.enabled) return null
      const windowInfo = computeViewportGameWindow()
      return applyVirtualVisibility(windowInfo, { reason })
    }
    
    function setVirtualVisibilityEnabled(enabled) {
      const next = Boolean(enabled)
      if (virtualScrollState.enabled === next) return
      virtualScrollState.enabled = next
      if (!next) {
        document.querySelectorAll('.game-card.virtual-hidden').forEach(card => card.classList.remove('virtual-hidden'))
        virtualScrollState.lastSignature = ''
        virtualScrollState.hiddenCount = 0
      } else {
        refreshVirtualVisibility('enable')
      }
    }
    
    virtualScrollState.getVisibleWindow = computeViewportGameWindow
    virtualScrollState.applyVisibility = applyVirtualVisibility
    virtualScrollState.refreshVisibility = refreshVirtualVisibility
    virtualScrollState.setEnabled = setVirtualVisibilityEnabled
    
    
    document.addEventListener('memeplay:active-game-changed', () => {
      refreshVirtualVisibility('active-game-change')
    })
    
    // ========= PACMAN CONTROL BRIDGE =========
    const PACMAN_ID_PREFIX = 'pacman-'
    const pacmanKeys = new Set(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'])

    function isPacmanGame(gameId) {
      if (!gameId) return false
      if (gameId === 'pacman-memeplay') return true
      return gameId.startsWith(PACMAN_ID_PREFIX)
    }

    function getPacmanIframe(gameId) {
      const card = getGameCardElement(gameId)
      return card?.querySelector('iframe') || null
    }

    function sendPacmanMessage(gameId, payload) {
      if (!isPacmanGame(gameId) || !payload) return false
      const iframe = getPacmanIframe(gameId)
      if (!iframe || !iframe.contentWindow) return false
      try {
        iframe.contentWindow.postMessage(payload, '*')
        return true
      } catch (err) {
        console.warn(`[PacmanBridge] postMessage failed for ${gameId}`, err)
        return false
      }
    }

    function focusPacmanIframe(gameId, reason = 'auto') {
      if (!isPacmanGame(gameId)) return false
      try { window.focus?.() } catch (_) {}
      const iframe = getPacmanIframe(gameId)
      if (!iframe) return false
      let focused = false
      try {
        iframe.focus({ preventScroll: true })
        focused = true
      } catch (_) {}
      try {
        iframe.contentWindow?.focus()
        focused = true
      } catch (_) {}
      sendPacmanMessage(gameId, {
        type: 'PACMAN_REMOTE_FOCUS',
        reason,
        ts: Date.now()
      })
      return focused
    }

    function relayPacmanKey(event) {
      if (!pacmanKeys.has(event.key)) return
      if (!isPacmanGame(currentActiveGame)) return
      const target = event.target
      if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable)) {
        return
      }
      event.preventDefault()
      event.stopPropagation()
      focusPacmanIframe(currentActiveGame, 'keyboard-relay')
      const sent = sendPacmanMessage(currentActiveGame, {
        type: 'PACMAN_REMOTE_INPUT',
        key: event.key,
        phase: event.type,
        ts: Date.now()
      })
      if (!sent) {
        console.warn(`[PacmanBridge] Failed relay ${event.type} ${event.key} for ${currentActiveGame}`)
      }
    }

    window.addEventListener('keydown', relayPacmanKey, true)
    window.addEventListener('keyup', relayPacmanKey, true)

    // ✅ FIX: Không auto-focus Pacman khi active game change - để tránh trigger snap về center
    // Chỉ focus khi user thực sự click vào game (handle trong game click handler)
    // document.addEventListener('memeplay:active-game-changed', (event) => {
    //   const gameId = event?.detail?.gameId || null
    //   if (isPacmanGame(gameId)) {
    //     focusPacmanIframe(gameId, 'active-event')
    //   }
    // })

    function isPacmanGameId(gameId) {
      return isPacmanGame(gameId)
    }

    // Load game iframe (helper function) - simple and fast
    function loadGameIframe(gameId) {
      const card = getGameCardElement(gameId)
      if (!card) {
        console.warn(`⚠️ loadGameIframe: Card not found for ${gameId}`)
        return false
      }
      const iframe = card.querySelector('iframe')
      if (!iframe) {
        console.warn(`⚠️ loadGameIframe: Iframe not found for ${gameId}`)
        return false
      }
      
      const targetUrl = iframe.getAttribute('data-game-url') || gameUrls[gameId]
      if (!targetUrl) {
        console.warn(`⚠️ loadGameIframe: No URL for ${gameId}`)
        return false
      }
      
      const currentSrc = iframe.src || ''
      const baseUrl = targetUrl.split('?')[0]
      const needsLoad = !currentSrc || currentSrc === '' || currentSrc.includes('about:blank') ||
                       (!currentSrc.includes(baseUrl))
      
      if (!needsLoad) {
        if (window.__DEBUG_SCROLL) console.log(`ℹ️ [loadGameIframe] Game ${gameId} already loaded (src: ${currentSrc.substring(0, 60)}...)`)
        return true
      }
      
      const sep = targetUrl.includes('?') ? '&' : '?'
      const newSrc = targetUrl + sep + 'v=' + Date.now()
      iframe.src = newSrc
      if (window.__DEBUG_SCROLL) console.log(`✅ [loadGameIframe] Loading iframe for ${gameId} | URL: ${newSrc.substring(0, 80)}...`)
      return true
    }
    
    function notifyPacmanFocus(gameId, reason = 'auto') {
      focusPacmanIframe(gameId, reason)
    }
    
    // Unload game iframe
    function unloadGameIframe(gameId) {
      const card = getGameCardElement(gameId)
      if (!card) return
      const iframe = card.querySelector('iframe')
      if (iframe) {
        iframe.src = 'about:blank'
        setGameState(gameId, GAME_STATES.HIDDEN, card)
      }
    }
  
    function activateGame(gameId, isPreload = false) {
      console.log(`🎮 [ACTIVATE] activateGame called: ${gameId} (isPreload: ${isPreload})`)
      debugLog(`🚀 [activateGame] CALLED with gameId: ${gameId}, isPreload: ${isPreload}`)
      if (!gameId) {
        console.warn(`⚠️ [activateGame] gameId is null/undefined, returning early`)
        return
      }
      
      const allGames = getAllGameCards()
      debugLog(`📋 [activateGame] Found ${allGames.length} total games`)
      const currentIndex = allGames.findIndex(g => g.id === gameId)
      if (currentIndex === -1) {
        console.error(`❌ [activateGame] Game ${gameId} not found in allGames (available: ${allGames.map(g => g.id).join(', ')})`)
        return
      }
      
      const totalGames = allGames.length
      
      // Calculate prev/next with circular logic
      const prevIndex = currentIndex === 0 ? totalGames - 1 : currentIndex - 1
      const nextIndex = currentIndex === totalGames - 1 ? 0 : currentIndex + 1
      
      const prevGameId = allGames[prevIndex]?.id
      const nextGameId = allGames[nextIndex]?.id
      
      // If already active, just ensure prev/next are loaded (don't reload active game)
      if (!isPreload && currentActiveGame === gameId) {
        const isCurrentPacman = isPacmanGame(gameId)
        
        // ✅ FIXED: For Pacman games, don't preload prev/next (only 1 Pacman should load)
        if (isCurrentPacman) {
          debugLog(`🎮 [Already Active] Pacman game ${gameId} is ACTIVE - No preload needed`)
          return
        }
        
        debugLog(`🔄 Game ${gameId} already active (currentActiveGame: ${currentActiveGame}), ensuring prev/next are loaded...`)
        // Ensure prev/next are loaded (only for non-Pacman games)
        if (prevGameId && !isPacmanGame(prevGameId)) {
          const prevCard = getGameCardElement(prevGameId)
          if (prevCard) {
            setGameState(prevGameId, GAME_STATES.WAITING)
            const prevLoaded = loadGameIframe(prevGameId)
            debugLog(`📦 [Already Active] Preloaded prev game: ${prevGameId} (WAITING) - Loading: ${prevLoaded}`)
          } else {
            console.error(`❌ [Already Active] Prev game card not found: ${prevGameId}`)
          }
        }
        if (nextGameId && !isPacmanGame(nextGameId)) {
          const nextCard = getGameCardElement(nextGameId)
          if (nextCard) {
            setGameState(nextGameId, GAME_STATES.WAITING)
            const nextLoaded = loadGameIframe(nextGameId)
            debugLog(`📦 [Already Active] Preloaded next game: ${nextGameId} (WAITING) - Loading: ${nextLoaded}`)
          } else {
            console.error(`❌ [Already Active] Next game card not found: ${nextGameId}`)
          }
        }
        // Still log that this game is active
        debugLog(`🎮 [Already Active] Game ${gameId} is ACTIVE | Prev: ${prevGameId || 'none'} | Next: ${nextGameId || 'none'}`)
        return
      }
      
      // If we reach here, this is a NEW game being activated (different from currentActiveGame)
      if (currentActiveGame && currentActiveGame !== gameId) {
        debugLog(`🔄 Switching active game: ${currentActiveGame} → ${gameId}`)
      }
      
      // Games to keep loaded: active + prev + next (always 3 games)
      const gamesToKeep = [gameId, prevGameId, nextGameId].filter(Boolean)
      debugLog(`🔍 [activateGame] Game ${gameId} | Index: ${currentIndex}/${totalGames} | Prev: ${prevGameId || 'none'} | Next: ${nextGameId || 'none'}`)
      debugLog(`🔍 Games to keep loaded: ${gamesToKeep.join(', ')}`)
      
      const isCurrentPacman = isPacmanGame(gameId)
      
      // ✅ FIXED: For Pacman games, only load the active game (no preload)
      // This prevents multiple Pacman games running simultaneously and causing lag
      if (isCurrentPacman) {
        // Unload ALL other Pacman games immediately
        const allGamesToCheck = getAllGameCards()
        allGamesToCheck.forEach((game) => {
          if (game.id && isPacmanGame(game.id) && game.id !== gameId) {
            debugLog(`🗑️ [Pacman] Unloading other Pacman game: ${game.id}`)
            unloadGameIframe(game.id)
          }
        })
        
        // Only load the active Pacman game
        const activeLoaded = loadGameIframe(gameId)
        setGameState(gameId, GAME_STATES.ACTIVE)
        notifyPacmanFocus(gameId, 'activate-game')
        currentActiveGame = gameId
        try { window.__memeplayActiveGame = gameId } catch {}
        document.dispatchEvent(new CustomEvent('memeplay:active-game-changed', { detail: { gameId } }))
        debugLog(`🎮 [Pacman] Activated game: ${gameId} (ACTIVE) - All other Pacman games unloaded`)
        return
      }
      
      // For non-Pacman games: Load prev and next games IMMEDIATELY and set to WAITING state
      // This ensures when user scrolls to them, they're already loaded and ready to play
      
      // Load prev game FIRST (user might scroll back) - but skip if it's a Pacman game
      if (prevGameId && !isPacmanGame(prevGameId)) {
        const prevCard = getGameCardElement(prevGameId)
        if (!prevCard) {
          console.error(`❌ Prev game card not found: ${prevGameId}`)
        } else {
          // Set state FIRST, then load (so UI shows WAITING state immediately)
          setGameState(prevGameId, GAME_STATES.WAITING)
          const prevLoaded = loadGameIframe(prevGameId)
          const prevState = getGameState(prevGameId)
          debugLog(`📦 [IMMEDIATE] Preloaded prev game: ${prevGameId} (WAITING state: ${prevState}) - Loading: ${prevLoaded}`)
          
          // Verify iframe is actually loading
          const prevIframe = prevCard.querySelector('iframe')
          if (prevIframe) {
            const iframeSrc = prevIframe.src || 'not set'
            debugLog(`   → Prev game iframe src: ${iframeSrc.substring(0, 80)}...`)
          }
        }
      } else if (prevGameId && isPacmanGame(prevGameId)) {
        debugLog(`⏭️ [Pacman] Skipping preload of prev Pacman game: ${prevGameId}`)
      } else {
        console.warn(`⚠️ No prev game for ${gameId}`)
      }
      
      // Load next game (user will scroll to it) - but skip if it's a Pacman game
      if (nextGameId && !isPacmanGame(nextGameId)) {
        const nextCard = getGameCardElement(nextGameId)
        if (!nextCard) {
          console.error(`❌ Next game card not found: ${nextGameId}`)
        } else {
          // Set state FIRST, then load (so UI shows WAITING state immediately)
          setGameState(nextGameId, GAME_STATES.WAITING)
          const nextLoaded = loadGameIframe(nextGameId)
          const nextState = getGameState(nextGameId)
          debugLog(`📦 [IMMEDIATE] Preloaded next game: ${nextGameId} (WAITING state: ${nextState}) - Loading: ${nextLoaded}`)
          
          // Verify iframe is actually loading
          const nextIframe = nextCard.querySelector('iframe')
          if (nextIframe) {
            const iframeSrc = nextIframe.src || 'not set'
            debugLog(`   → Next game iframe src: ${iframeSrc.substring(0, 80)}...`)
          }
        }
      } else if (nextGameId && isPacmanGame(nextGameId)) {
        debugLog(`⏭️ [Pacman] Skipping preload of next Pacman game: ${nextGameId}`)
      } else {
        console.warn(`⚠️ No next game for ${gameId}`)
      }
      
      // Load active game
      const activeLoaded = loadGameIframe(gameId)
      setGameState(gameId, GAME_STATES.ACTIVE)
      notifyPacmanFocus(gameId, 'activate-game')
      currentActiveGame = gameId
      try { window.__memeplayActiveGame = gameId } catch {}
      document.dispatchEvent(new CustomEvent('memeplay:active-game-changed', { detail: { gameId } }))
      debugLog(`🎮 Activated game: ${gameId} (ACTIVE) | Prev: ${prevGameId || 'none'} | Next: ${nextGameId || 'none'}`)
      
      // ✅ FIXED: Don't unload games aggressively - only unload games very far away
      // This ensures games are visible when user scrolls to them
      // Only unload games that are more than 5 positions away from current game to save memory
      const allGamesToCheck = getAllGameCards()
      
      allGamesToCheck.forEach((game) => {
        if (game.id && !gamesToKeep.includes(game.id)) {
          const gameIndex = allGames.findIndex(g => g.id === game.id)
          if (gameIndex !== -1) {
            const distance = Math.abs(gameIndex - currentIndex)
            const unloadRadius = isPacmanGame(game.id) ? 2 : 5
            if (distance > unloadRadius) {
              if (window.__DEBUG_SCROLL) console.log(`🗑️ Unloading distant game: ${game.id} (distance: ${distance}, radius: ${unloadRadius})`)
              unloadGameIframe(game.id)
            } else {
              if (window.__DEBUG_SCROLL) console.log(`✅ Keeping nearby game loaded: ${game.id} (distance: ${distance})`)
            }
          }
        } else if (game.id && gamesToKeep.includes(game.id) && window.__DEBUG_SCROLL) {
          console.log(`✅ Keeping game loaded: ${game.id} (in keep list)`)
        }
      })
    }

    // Observe which game card is visible and activate early for snappier switching
  function initGameObserver() {
    // ✅ PERFORMANCE: Reduced thresholds from 11 to 4 (Step 3)
    // This reduces IntersectionObserver callback frequency by ~70%
    // 4 thresholds are sufficient for accurate detection while saving CPU
    const thresholds = [0, 0.3, 0.7, 1.0];
    const gameContainer = document.querySelector('.game-container');
    const observer = new IntersectionObserver((entries) => {
        if (window.__memeplayLockObserverUntil && Date.now() < window.__memeplayLockObserverUntil) {
          debugLog(`👁️ Observer locked (until ${new Date(window.__memeplayLockObserverUntil).toLocaleTimeString()})`);
          return
        }
        const visible = entries.filter(e => e.isIntersecting);
        if (!visible.length) {
          debugLog('👁️ Observer: No visible games')
          return
        }
        
        // Deduplicate: Keep only the entry with highest intersection ratio for each game
        const gameMap = new Map()
        visible.forEach(entry => {
          const gameId = entry.target.id
          if (!gameId) return
          
          const existing = gameMap.get(gameId)
          if (!existing || entry.intersectionRatio > existing.intersectionRatio) {
            gameMap.set(gameId, entry)
          }
        })
        
        // Convert back to array (now deduplicated)
        const visibleDeduped = Array.from(gameMap.values())

        // IMPROVED: Find the game card closest to the center of the viewport
        // This is more accurate than just using intersection ratio
        let best = null;
        let minDistanceToCenter = Infinity;
        let bestInViewport = false;
        
        // Calculate viewport center - use window center if no container
        const viewportCenter = window.innerHeight / 2;
        
        // Log all visible games with their positions for debugging (use deduplicated list)
        const visibleGamesDebug = visibleDeduped.map(e => {
          const cardRect = e.target.getBoundingClientRect();
          const cardTop = cardRect.top;
          const cardBottom = cardRect.bottom;
          const cardCenter = cardRect.top + cardRect.height / 2;
          const distanceToCenter = Math.abs(cardCenter - viewportCenter);
          const isInViewport = cardTop >= 0 && cardBottom <= window.innerHeight;
          return {
            id: e.target.id,
            ratio: (e.intersectionRatio * 100).toFixed(1) + '%',
            top: Math.round(cardTop),
            bottom: Math.round(cardBottom),
            center: Math.round(cardCenter),
            viewportCenter: Math.round(viewportCenter),
            distToCenter: Math.round(distanceToCenter) + 'px',
            isInViewport: isInViewport
          };
        });
        // Log each game on separate lines for easier reading
        if (window.__DEBUG_SCROLL) {
          debugLog(`👁️ [DEBUG] Viewport center: ${Math.round(viewportCenter)}px, Found ${visibleDeduped.length} unique visible game(s) (${visible.length} total entries):`);
          visibleGamesDebug.forEach((game, idx) => {
            debugLog(`   ${idx + 1}. ${game.id}: ratio=${game.ratio}, dist=${game.distToCenter}, inViewport=${game.isInViewport}, top=${game.top}, bottom=${game.bottom}`);
          });
        }
        
        visibleDeduped.forEach(entry => {
          const cardRect = entry.target.getBoundingClientRect();
          const cardTop = cardRect.top;
          const cardBottom = cardRect.bottom;
          const cardCenter = cardRect.top + cardRect.height / 2;
          const distanceToCenter = Math.abs(cardCenter - viewportCenter);
          
          // Check if game is in viewport (fully or partially visible)
          const isInViewport = cardTop >= 0 && cardBottom <= window.innerHeight;
          const isPartiallyInViewport = cardTop < window.innerHeight && cardBottom > 0; // Any part visible
          const isMostlyInViewport = cardTop >= -100 && cardBottom <= window.innerHeight + 100;
          
          // Calculate visible height (how much of the game is actually visible)
          const visibleTop = Math.max(cardTop, 0);
          const visibleBottom = Math.min(cardBottom, window.innerHeight);
          const visibleHeight = Math.max(0, visibleBottom - visibleTop);
          const visibleRatio = visibleHeight / cardRect.height;
          
          // ✅ FIX: Điều chỉnh minRatio cho Pacman - cho phép game bị cắt mép một chút vẫn được activate
          // Khi game bị cắt mép trên (F5 hoặc quay lại), intersectionRatio giảm → cần threshold thấp hơn
          const gameId = entry.target.id || entry.target.getAttribute('data-game-id') || ''
          const isPacman = gameId && (gameId.startsWith('pacman-') || gameId === 'pacman-memeplay')
          // ✅ FIX: Nếu game đang active và vẫn visible một phần → ưu tiên giữ nó active
          const isCurrentActive = gameId === currentActiveGame
          // Giảm minRatio: Active Pacman chỉ cần 20%, Pacman khác 30% (thay vì 50%)
          const minRatio = isPacman ? (isCurrentActive ? 0.2 : 0.3) : 0.3
          
          // Prefer game with good intersection ratio
          // ✅ FIX: Nếu game đang active và vẫn visible một phần (> 10%) → vẫn được activate
          if (entry.intersectionRatio > minRatio || (isCurrentActive && entry.intersectionRatio > 0.1)) {
            // CRITICAL: Prioritize distance to center FIRST, then intersection ratio
            // A game closer to center is more likely to be the one user is playing
            // Even if it has slightly lower intersection ratio
            
            if (best === null) {
              minDistanceToCenter = distanceToCenter;
              best = entry;
              bestInViewport = isInViewport;
            } else {
              // Calculate distance for current best
              const bestRect = best.target.getBoundingClientRect();
              const bestCenter = bestRect.top + bestRect.height / 2;
              const bestDistance = Math.abs(bestCenter - viewportCenter);
              
              // PRIORITY 1: If one game is MUCH closer to center (difference > 200px), choose it
              // This handles cases where a game is partially visible but closer to center
              if (distanceToCenter < bestDistance - 200) {
                // This game is significantly closer to center
                minDistanceToCenter = distanceToCenter;
                best = entry;
                bestInViewport = isInViewport;
              } else if (bestDistance < distanceToCenter - 200) {
                // Current best is significantly closer, keep it
                // Do nothing
              } else {
                // Games are similarly close to center (within 200px), prefer higher intersection ratio
                if (entry.intersectionRatio > best.intersectionRatio + 0.1) {
                  // This game has significantly higher intersection ratio
                  minDistanceToCenter = distanceToCenter;
                  best = entry;
                  bestInViewport = isInViewport;
                } else if (best.intersectionRatio > entry.intersectionRatio + 0.1) {
                  // Current best has significantly higher intersection ratio, keep it
                  // Do nothing
                } else {
                  // Similar intersection ratio, prefer one closer to center
                  if (distanceToCenter < bestDistance) {
                    minDistanceToCenter = distanceToCenter;
                    best = entry;
                    bestInViewport = isInViewport;
                  }
                }
              }
            }
          }
        });
        
        // Fallback: if no game found with good intersection, use highest intersection ratio
        if (!best) {
          best = visibleDeduped.reduce((a, b) => a.intersectionRatio >= b.intersectionRatio ? a : b);
        }
        
        const gameId = best.target.id;
        const isPacmanGame = isPacmanGameId(gameId)
        // ✅ FIX #1: Disable IntersectionObserver focus khi scroll từ Pacman
        // Chỉ focus khi user thực sự click vào Pacman (không phải scroll)
        if (isPacmanGame) {
          // Check nếu đang scroll TỪ Pacman sang game khác
          const currentActiveGameId = window.__memeplayActiveGame || currentActiveGame || '';
          const isCurrentActivePacman = currentActiveGameId && (
            currentActiveGameId.startsWith('pacman-') || 
            currentActiveGameId === 'pacman-memeplay'
          );
          
          // Nếu current active là Pacman KHÁC với gameId đang visible → đang scroll TỪ Pacman
          // Không focus để tránh trigger scroll về Pacman
          if (isCurrentActivePacman && currentActiveGameId !== gameId) {
            // Đang scroll từ Pacman sang game khác → không focus
            return;
          }
          
          // Delay focus để không trigger snap khi đang scroll
          setTimeout(() => {
            // Double-check: Chỉ focus nếu game vẫn là active game (không bị switch sang game khác)
            // VÀ không phải đang scroll từ Pacman
            const finalActiveGameId = window.__memeplayActiveGame || currentActiveGame || '';
            const isStillActive = finalActiveGameId === gameId;
            const isStillPacman = isPacmanGameId(finalActiveGameId);
            
            // Chỉ focus nếu:
            // 1. Game vẫn là active game
            // 2. Không phải đang scroll từ Pacman khác
            if (isStillActive && isPacmanGameId(gameId) && (!isStillPacman || finalActiveGameId === gameId)) {
              if (typeof window.focus === 'function') {
                try { window.focus() } catch (_) {}
              }
              focusPacmanIframe(gameId, 'observer-visible')
            }
          }, 500)
        }
        
        if (!gameId) {
          console.warn('⚠️ Observer: Game card has no ID', best.target)
          return
        }
        
        // ✅ FIX: Don't activate different game if there's a pinned game (from focusGameCard)
        const pinnedGameId = window.__memeplayPinnedGameId
        if (pinnedGameId && gameId !== pinnedGameId) {
          debugLog(`👁️ Observer: Skipping activation of ${gameId} (pinned game: ${pinnedGameId})`)
          return
        }
        
        // ✅ FIX: Don't activate different game if observer is locked
        if (window.__memeplayLockObserverUntil && Date.now() < window.__memeplayLockObserverUntil) {
          debugLog(`👁️ Observer: Skipping activation (locked until ${new Date(window.__memeplayLockObserverUntil).toLocaleTimeString()})`)
          return
        }
        
        // Log all visible games for debugging (use deduplicated list)
        const visibleGames = visibleDeduped.map(e => {
          const rect = e.target.getBoundingClientRect();
          const center = rect.top + rect.height / 2;
          const dist = Math.abs(center - viewportCenter);
          return { 
            id: e.target.id, 
            ratio: (e.intersectionRatio * 100).toFixed(1) + '%',
            distToCenter: Math.round(dist) + 'px'
          };
        });
        debugLog(`👁️ Observer detected ${visibleDeduped.length} unique visible game(s) (${visible.length} total entries):`, visibleGames)
        
        // Calculate final distance for logging (avoid Infinity)
        const finalDistance = isFinite(minDistanceToCenter) ? Math.round(minDistanceToCenter) : 'N/A'
        debugLog(`👁️ Observer activating game: ${gameId} (intersection: ${(best.intersectionRatio * 100).toFixed(1)}%, distance to center: ${finalDistance}px, currentActiveGame: ${currentActiveGame})`)
        
        // WARNING: If rocket-bnb is not in visible list but is being played, scroll check should handle it
        if (gameId !== 'rocket-bnb' && currentActiveGame === 'rocket-bnb') {
          if (window.__DEBUG_SCROLL) console.warn(`⚠️ Observer detected ${gameId} but currentActiveGame is rocket-bnb - scroll check fallback should activate rocket-bnb`)
        }
        
        // ✅ REMOVED: Pacman game check - Games should activate normally when scrolled to
        // This was blocking games from activating, causing them to not display
        
        // ✅ FIX: Nếu game đang active và vẫn visible một phần → ưu tiên giữ nó active
        // Ngăn bug "game bị cắt mép trên" khi F5 hoặc quay lại từ editor
        if (currentActiveGame === gameId) {
          // Game đang active → không cần activate lại
          debugLog(`🛡️ [OBSERVER] Game ${gameId} is already active - KEEP active`)
          return
        }
        
        // ✅ FIX: Tính visible ratio và distance của game đang active để ưu tiên giữ nó active
        // NHƯNG chỉ khi nó gần center - nếu game khác gần center hơn → cho phép activate game khác
        if (currentActiveGame) {
          const currentCard = getGameCardElement(currentActiveGame)
          if (currentCard) {
            const currentRect = currentCard.getBoundingClientRect()
            const currentVisibleTop = Math.max(currentRect.top, 0)
            const currentVisibleBottom = Math.min(currentRect.bottom, window.innerHeight)
            const currentVisibleHeight = Math.max(0, currentVisibleBottom - currentVisibleTop)
            const currentVisibleRatio = currentVisibleHeight / currentRect.height
            
            // Tính distance của game đang active đến center
            const currentCenter = currentRect.top + currentRect.height / 2
            const currentDistance = Math.abs(currentCenter - (window.innerHeight / 2))
            
            // Tính distance của game mới đến center
            const bestRect = best.target.getBoundingClientRect()
            const bestCenter = bestRect.top + bestRect.height / 2
            const bestDistance = Math.abs(bestCenter - (window.innerHeight / 2))
            
            // ✅ FIX: Chỉ ưu tiên game đang active nếu:
            // 1. Nó vẫn visible một phần (> 10%) VÀ
            // 2. Nó gần center hơn game mới (hoặc game mới cách center > 200px)
            // Nếu game mới gần center hơn nhiều (difference > 150px) → cho phép activate game mới
            if (currentVisibleRatio > 0.1 && currentDistance < 200) {
              // Game đang active vẫn gần center → chỉ activate game mới nếu nó gần center hơn nhiều
              if (bestDistance < currentDistance - 150) {
                // Game mới gần center hơn nhiều → cho phép activate
                debugLog(`🔄 [OBSERVER] Game ${gameId} is much closer to center (${Math.round(bestDistance)}px vs ${Math.round(currentDistance)}px) - ALLOW activate`)
              } else {
                // Game đang active vẫn gần center hơn → giữ nó active
                debugLog(`🛡️ [OBSERVER] Current active game ${currentActiveGame} is ${Math.round(currentVisibleRatio * 100)}% visible and closer to center (${Math.round(currentDistance)}px vs ${Math.round(bestDistance)}px) - KEEP active`)
                return
              }
            }
          }
        }
        
        // Only activate if scroll check hasn't already activated a better game
        // Scroll check runs every 200ms and is more reliable, so we only use observer as secondary
        // Check if currentActiveGame is different - if scroll check already activated a game, don't override
        if (currentActiveGame && currentActiveGame !== gameId) {
          // Scroll check may have already activated the correct game, so check distance first
          const currentGameCard = getGameCardElement(currentActiveGame)
          if (currentGameCard) {
            const currentRect = currentGameCard.getBoundingClientRect()
            const currentCenter = currentRect.top + currentRect.height / 2
            const currentDistance = Math.abs(currentCenter - (window.innerHeight / 2))
            
            const bestRect = best.target.getBoundingClientRect()
            const bestCenter = bestRect.top + bestRect.height / 2
            const bestDistance = Math.abs(bestCenter - (window.innerHeight / 2))
            
            // Only activate if observer's game is significantly closer (within 100px difference)
            if (bestDistance < currentDistance - 100) {
              debugLog(`👁️ Observer overriding scroll check: ${currentActiveGame} → ${gameId} (distances: ${Math.round(currentDistance)}px vs ${Math.round(bestDistance)}px)`)
              activateGame(gameId)
            } else {
              debugLog(`👁️ Observer skipping (scroll check already activated closer game: ${currentActiveGame}, distance: ${Math.round(currentDistance)}px)`)
            }
          } else {
            activateGame(gameId)
          }
        } else {
          activateGame(gameId)
        }
    }, {
        // Observe inside the snapping container (relative to container, not viewport)
        // This is important because game cards scroll within the container
        root: gameContainer || null, // Use container as root for proper intersection calculation
        // ✅ FIX: Giảm rootMargin từ 500px → 200px để tránh detect Pacman khi đã scroll xa
        // rootMargin quá lớn → IntersectionObserver detect Pacman là "visible" ngay cả khi đã scroll xa 500px
        rootMargin: '200px 0px 200px 0px', // Preload games 200px above/below visible area (giảm từ 500px)
        threshold: [0, 0.3, 0.7, 1.0] // ✅ PERFORMANCE: Reduced from 11 to 4 thresholds (Step 3)
      });

    const cards = document.querySelectorAll('.game-card')
      cards.forEach(card => {
        observer.observe(card)
        if (window.__DEBUG_SCROLL) console.log(`👁️ Observing game card: ${card.id || card.dataset?.gameId}`)
      })
      if (window.__DEBUG_SCROLL) console.log('✅ Game observer initialized for', cards.length, 'games')
    
    // FALLBACK: Also check scroll position to find game at center
    // This helps when IntersectionObserver misses the game
    let scrollCheckTimeout = null
    const checkScrollPosition = () => {
      try {
        if (scrollCheckTimeout) clearTimeout(scrollCheckTimeout)
        scrollCheckTimeout = setTimeout(() => {
          try {
            const viewportCenter = window.innerHeight / 2
            const allCards = Array.from(document.querySelectorAll('.game-card'))
              .filter(card => {
                const cardId = card.id || card.getAttribute('data-game-id') || ''
                // ✅ FIX: Loại bỏ các game Pacman có đường dẫn kiểu cũ (pacman-game-*)
                if (cardId.startsWith('pacman-game-')) {
                  return false
                }
                return true
              })
            if (!allCards.length) return // No cards yet
            
            let checkList = allCards
            if (currentActiveGame) {
              const currentIndex = allCards.findIndex(card => card.id === currentActiveGame)
              if (currentIndex !== -1) {
                // ✅ PERFORMANCE: Reduced check range from 7 games to 5 games (Step 4.1)
                // Changed from: currentIndex - 3 to + 4 (7 games) → currentIndex - 2 to + 3 (5 games)
                // This reduces CPU usage when checking scroll position by ~28%
                // Only check 5 games (2 above + active + 2 below) instead of 7 games
                const start = Math.max(0, currentIndex - 2)  // 2 games above active
                const end = Math.min(allCards.length, currentIndex + 3)  // 2 games below active (total: 5 games)
                checkList = allCards.slice(start, end)
              }
            }
            
            // ✅ FIX: Loại bỏ currentActiveGame khỏi checkList nếu nó là Pacman
            // Ngăn checkScrollPosition detect lại Pacman khi đang scroll từ Pacman sang game khác
            // Game 1 (index 0) có thể không bị vì scroll xuống nhanh chóng ra khỏi viewport
            // Game 3 (index 2) vẫn nằm trong checkList → bị detect lại → scroll về
            const currentActiveGameId = window.__memeplayActiveGame || currentActiveGame || '';
            const isCurrentActivePacman = currentActiveGameId && (
              currentActiveGameId.startsWith('pacman-') || 
              currentActiveGameId === 'pacman-memeplay'
            );
            
            // Nếu currentActiveGame là Pacman → loại bỏ nó khỏi checkList
            if (isCurrentActivePacman && currentActiveGameId) {
              checkList = checkList.filter(card => {
                const cardId = card.id || card.getAttribute('data-game-id') || '';
                return cardId !== currentActiveGameId; // Loại bỏ currentActiveGame
              });
            }
            
            let closestGame = null
            let minDistance = Infinity
            
            checkList.forEach(card => {
              try {
                const rect = card.getBoundingClientRect()
                const cardCenter = rect.top + rect.height / 2
                const distance = Math.abs(cardCenter - viewportCenter)
                
                // ✅ FIX: Chỉ check games thực sự trong viewport (không dùng rootMargin như IntersectionObserver)
                // Check if game is visible (any part in viewport) - KHÔNG tính rootMargin
                const isVisible = rect.top < window.innerHeight && rect.bottom > 0
                
                // ✅ FIX: Thêm check distance - chỉ activate game nếu distance < 400px (không quá xa)
                // Ngăn detect Pacman khi đã scroll xa (do rootMargin quá lớn)
                const isCloseEnough = distance < 400; // Chỉ activate game nếu cách center < 400px
                
                if (isVisible && isCloseEnough && distance < minDistance) {
                  minDistance = distance
                  closestGame = card
                }
              } catch (e) {
                console.warn('Error checking card:', e)
              }
            })
            
            if (closestGame && closestGame.id) {
              // ✅ FIX: Không focus Pacman khi scroll - để tránh trigger snap về center
              // Chỉ focus khi user click vào game (handle trong game click handler)
              
              if (closestGame.id !== currentActiveGame && typeof activateGame === 'function') {
                // ✅ FIX: Tính visible ratio và distance để ưu tiên game đang active
                // NHƯNG chỉ khi nó gần center - nếu game khác gần center hơn → cho phép activate game khác
                const rect = closestGame.getBoundingClientRect()
                const cardCenter = rect.top + rect.height / 2
                const distance = Math.abs(cardCenter - viewportCenter)
                
                // Tính visible ratio của game mới
                const visibleTop = Math.max(rect.top, 0)
                const visibleBottom = Math.min(rect.bottom, window.innerHeight)
                const visibleHeight = Math.max(0, visibleBottom - visibleTop)
                const visibleRatio = visibleHeight / rect.height
                
                // ✅ FIX: Kiểm tra game đang active (nếu có)
                if (currentActiveGame) {
                  const currentCard = getGameCardElement(currentActiveGame)
                  if (currentCard) {
                    const currentRect = currentCard.getBoundingClientRect()
                    const currentCenter = currentRect.top + currentRect.height / 2
                    const currentDistance = Math.abs(currentCenter - viewportCenter)
                    
                    // Tính visible ratio của game đang active
                    const currentVisibleTop = Math.max(currentRect.top, 0)
                    const currentVisibleBottom = Math.min(currentRect.bottom, window.innerHeight)
                    const currentVisibleHeight = Math.max(0, currentVisibleBottom - currentVisibleTop)
                    const currentVisibleRatio = currentVisibleHeight / currentRect.height
                    
                    // ✅ FIX: Chỉ ưu tiên game đang active nếu:
                    // 1. Nó vẫn visible một phần (> 10%) VÀ
                    // 2. Nó gần center hơn game mới (hoặc game mới cách center > 200px)
                    // Nếu game mới gần center hơn nhiều (difference > 150px) → cho phép activate game mới
                    if (currentVisibleRatio > 0.1 && currentDistance < 200) {
                      // Game đang active vẫn gần center → chỉ activate game mới nếu nó gần center hơn nhiều
                      if (distance < currentDistance - 150) {
                        // Game mới gần center hơn nhiều → cho phép activate
                        debugLog(`🔄 [SCROLL CHECK] Game ${closestGame.id} is much closer to center (${Math.round(distance)}px vs ${Math.round(currentDistance)}px) - ALLOW activate`)
                      } else {
                        // Game đang active vẫn gần center hơn → giữ nó active
                        debugLog(`🛡️ [SCROLL CHECK] Current active game ${currentActiveGame} is ${Math.round(currentVisibleRatio * 100)}% visible and closer to center (${Math.round(currentDistance)}px vs ${Math.round(distance)}px) - KEEP active`)
                        return // Giữ game đang active, không activate game khác
                      }
                    }
                  }
                }
                
                debugLog(`📍 [SCROLL CHECK] Found game at center: ${closestGame.id} (distance: ${Math.round(distance)}px, currentActiveGame: ${currentActiveGame})`)
                activateGame(closestGame.id)
                
                // ✅ FIX: Không auto-focus Pacman từ checkScrollPosition - để tránh trigger snap về center
                // Chỉ focus khi user thực sự click vào game (handle trong game click handler)
                // if (isPacmanGame(closestGame.id)) {
                //   setTimeout(() => {
                //     focusPacmanIframe(closestGame.id, 'scroll-center')
                //   }, 300)
                // }
              }
            }
            
            refreshVirtualVisibility('scroll-check')
          } catch (e) {
            if (window.__DEBUG_SCROLL) console.warn('Error in scroll check:', e)
          }
        }, 100) // Debounce 100ms
      } catch (e) {
        console.warn('Error setting up scroll check:', e)
      }
    }
    
    // Check on scroll (only if container exists)
    try {
      const gameContainer = document.querySelector('.game-container')
      if (gameContainer) {
        gameContainer.addEventListener('scroll', checkScrollPosition, { passive: true })
      }
      window.addEventListener('scroll', checkScrollPosition, { passive: true })
      
      // ✅ PERFORMANCE: Optimized scroll check frequency (Step 2)
      // Increased interval from 200ms to 350ms to reduce CPU usage
      // Use requestIdleCallback to avoid blocking game, but with short timeout for responsiveness
      let scrollCheckPending = false
      function runPeriodicScrollCheck() {
        if (scrollCheckPending) return
        
          scrollCheckPending = true
        
        // Use requestIdleCallback to avoid blocking game (especially on mobile)
        // Short timeout (300ms) ensures responsiveness even if browser is busy
        if (window.requestIdleCallback) {
          window.requestIdleCallback(() => {
            scrollCheckPending = false
            checkScrollPosition()
          }, { timeout: 300 })
        } else {
          // Fallback for browsers without requestIdleCallback
          setTimeout(() => {
            scrollCheckPending = false
            checkScrollPosition()
          }, 200)
        }
      }
      
      // ✅ PERFORMANCE: Increased interval from 200ms to 350ms
      // This reduces CPU usage from 5 checks/sec to ~2.8 checks/sec
      // IntersectionObserver still handles real-time activation, so UX remains smooth
      setInterval(runPeriodicScrollCheck, 350)
    } catch (e) {
      console.warn('Error setting up scroll listeners:', e)
    }
  }
    
    // Dropdown nav logic
    const navDropdown = document.getElementById('navDropdown');
    const dropdownList = document.getElementById('dropdownList');
    const items = dropdownList ? dropdownList.querySelectorAll('.dropdown-item') : [];
    const searchToggleButton = document.getElementById('searchToggleButton');
    
    // Hamburger menu dropdown
    const hamburgerButton = document.getElementById('hamburgerButton');
    const hamburgerDropdown = document.getElementById('hamburgerDropdown');
    const hamburgerItems = hamburgerDropdown ? hamburgerDropdown.querySelectorAll('.dropdown-item') : [];
    
    // Creator button (direct click - no dropdown)
    const creatorButton = document.getElementById('creatorButton');

    function closeNavDropdown() {
      navDropdown.classList.remove('open');
      navDropdown.setAttribute('aria-hidden', 'true');
      searchToggleButton?.setAttribute('aria-expanded', 'false');
    }

    function closeHamburgerDropdown() {
      hamburgerDropdown?.classList.remove('open');
      hamburgerDropdown?.setAttribute('aria-hidden', 'true');
      hamburgerButton?.setAttribute('aria-expanded', 'false');
    }

    // Hamburger button click
    hamburgerButton?.addEventListener('click', (event) => {
      event.stopPropagation();
      closeNavDropdown();
      const willOpen = !hamburgerDropdown.classList.contains('open');
      if (willOpen) {
        hamburgerDropdown.classList.add('open');
        hamburgerDropdown.setAttribute('aria-hidden', 'false');
        hamburgerButton.setAttribute('aria-expanded', 'true');
      } else {
        closeHamburgerDropdown();
    }
    });

    searchToggleButton?.addEventListener('click', (event) => {
      event.stopPropagation();
      closeHamburgerDropdown();
      const willOpen = !navDropdown.classList.contains('open');
      if (willOpen) {
        navDropdown.classList.add('open');
        navDropdown.setAttribute('aria-hidden', 'false');
        searchToggleButton.setAttribute('aria-expanded', 'true');
      } else {
        closeNavDropdown();
      }
    });

    items.forEach(item => {
      item.addEventListener('click', function(e) {
        items.forEach(i => i.classList.remove('active'));
        this.classList.add('active');
        const category = this.getAttribute('data-category');
        closeNavDropdown();
        e.stopPropagation();
        
        // Apply filter based on category
        if (category) {
          // Use window.applyGameFilter since it's defined in a module
          if (typeof window.applyGameFilter === 'function') {
            window.applyGameFilter(category);
          } else {
            console.error('applyGameFilter is not available yet. Please wait for the page to load.');
          }
        }
      });
    });

    // Hamburger dropdown items
    hamburgerItems.forEach(item => {
      item.addEventListener('click', (event) => {
        event.stopPropagation();
        const action = item.getAttribute('data-action');
        switch(action) {
          case 'docs':
            window.open('docs.html', '_blank', 'noopener,noreferrer');
            break;
          case 'stats':
            if (typeof window.__openStatsOverlay === 'function') {
              window.__openStatsOverlay();
            }
            break;
        }
        closeHamburgerDropdown();
      });
    });

    // Creator button - navigate to shared template editor
    creatorButton?.addEventListener('click', (event) => {
      event.preventDefault();
      closeNavDropdown();
      closeHamburgerDropdown();
      window.location.href = '/games/templates/';
    });

    document.addEventListener('click', function(e) {
      // Close dropdowns when clicking outside
      if (navDropdown.contains(e.target) || searchToggleButton.contains(e.target)) {
        closeHamburgerDropdown();
        return;
      }
      if (hamburgerDropdown?.contains(e.target) || hamburgerButton?.contains(e.target)) {
      closeNavDropdown();
        return;
      }
      // Click outside - close all
      closeNavDropdown();
      closeHamburgerDropdown();
    });
  </script>

  <!-- main.js disabled (conflicts with embedded iframes) -->

  <!-- === SUPABASE DAILY CHECK-IN & REWARD === -->

<script type="module">
  // 1️⃣ Import Supabase SDK (library for connecting to Supabase directly on web)
  import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

  // 2️⃣ Declare connection info (URL & Anon Key of your project)
  const SUPABASE_URL = 'https://iikckrcdrvnqctzacxgx.supabase.co'
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlpa2NrcmNkcnZucWN0emFjeGd4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE3Mzc3NDgsImV4cCI6MjA3NzMxMzc0OH0.nIPvf11YfFlWH0XHDZdxI496zaP431QOJCuQ-5XX4DQ'

  // 3️⃣ Create "supabase" object for using RPC, queries, insert, etc.
  // ✅ FIX: Completely disable realtime to prevent local network permission prompt
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
    // NO realtime config - completely disabled
    global: {
      headers: {},
      fetch: (url, options = {}) => {
        return fetch(url, options);
      }
    },
    auth: {
      persistSession: false,
      autoRefreshToken: false,
      detectSessionInUrl: false
    }
  })
  
  // ✅ CRITICAL: Explicitly disconnect realtime to prevent WebSocket connections
  // This prevents the "local network permission" popup on production
  if (supabase.realtime) {
    supabase.realtime.disconnect();
  }

  // Global state for current filter
  let currentFilter = 'Recommended' // 'Recommended', 'Liked', 'Trending', 'Popular'
  
  // Sort games by likes (descending - highest likes first)
  async function sortGamesByLikes(cards) {
    if (!cards || cards.length === 0) return cards
    
    // Get like counts for all games in parallel
    const likeCounts = await Promise.all(
      cards.map(async (card) => {
        const gameId = card.id || card.getAttribute('data-game-id')
        if (!gameId) return { gameId: null, likes: 0 }
        
        try {
          const { data, error } = await supabase.rpc('get_social_counts', { p_game_id: gameId })
          if (error) {
            console.warn(`Failed to get likes for ${gameId}:`, error.message)
            return { gameId, likes: 0 }
          }
          return { gameId, likes: (data?.likes || 0) }
        } catch (e) {
          console.warn(`Error getting likes for ${gameId}:`, e)
          return { gameId, likes: 0 }
        }
      })
    )
    
    // Create map for quick lookup
    const likesMap = new Map(likeCounts.map(item => [item.gameId, item.likes]))
    
    // Sort cards by likes (descending)
    const sorted = [...cards].sort((a, b) => {
      const aId = a.id || a.getAttribute('data-game-id')
      const bId = b.id || b.getAttribute('data-game-id')
      const aLikes = likesMap.get(aId) || 0
      const bLikes = likesMap.get(bId) || 0
      return bLikes - aLikes // Descending order
    })
    
    // ✅ DEBUG: Log top 5 games with their like counts
    const top5 = sorted.slice(0, 5).map((card, idx) => {
      const gameId = card.id || card.getAttribute('data-game-id')
      const likes = likesMap.get(gameId) || 0
      return `${idx + 1}. ${gameId} (${likes} likes)`
    })
    console.log(`📊 Sorted ${sorted.length} games by likes (highest first):`, top5.join(', '))
    
    return sorted
  }
  
  // Filter games by "Liked" (user's liked games)
  // CRITICAL: Only return games that are LIKED (localStorage = '1')
  // Games that are UNLIKED or NEVER LIKED will be filtered out (hidden)
  function filterLikedGames(cards) {
    if (!cards || cards.length === 0) return cards
    
    const likedGames = cards.filter(card => {
      const gameId = card.id || card.getAttribute('data-game-id')
      if (!gameId) return false
      
      // CRITICAL: Only show games where localStorage has '1' (liked)
      // If localStorage is '0' (unliked) or null/undefined (never liked) → HIDE
      const likeStatus = localStorage.getItem('mp_like_' + gameId)
      const isLiked = likeStatus === '1'
      
      if (!isLiked) {
        console.log(`   ❌ Game ${gameId} is NOT liked (status: ${likeStatus || 'null'}) → Will be HIDDEN`)
      }
      
      return isLiked
    })
    
    console.log(`❤️ Filtered to ${likedGames.length} liked game(s) (${cards.length - likedGames.length} games will be HIDDEN)`)
    return likedGames
  }
  
  // Apply filter and reorder games
  // Make it globally accessible (for event listeners in non-module scripts)
  window.applyGameFilter = async function applyGameFilter(category) {
    const container = document.querySelector('.game-container')
    if (!container) return
    
    currentFilter = category
    console.log(`🔍 Applying filter: ${category}`)
    
    // Get all game cards
    const allCards = Array.from(container.querySelectorAll('.game-card'))
    if (allCards.length === 0) return
    
    let filteredCards = allCards
    
    // Apply filter based on category
    if (category === 'Liked') {
      // STEP 1: First, hide ALL games
      allCards.forEach(card => {
        card.style.display = 'none'
      })
      
      // STEP 2: Filter to get only liked games
      filteredCards = filterLikedGames(allCards)
      
      // STEP 3: Show ONLY liked games
      filteredCards.forEach(card => {
        const gameId = card.id || card.getAttribute('data-game-id')
        card.style.display = '' // Show liked games
        console.log(`   ✅ Game ${gameId} is LIKED → SHOW`)
      })
      
      // STEP 4: Double-check: Hide any remaining games that are NOT liked
      allCards.forEach(card => {
        const gameId = card.id || card.getAttribute('data-game-id')
        if (!gameId) {
          card.style.display = 'none'
          return
        }
        
        const likeStatus = localStorage.getItem('mp_like_' + gameId)
        const isLiked = likeStatus === '1'
        
        if (!isLiked) {
          card.style.display = 'none' // Hide unliked/never-liked games
          console.log(`   ❌ Game ${gameId} is NOT liked (status: ${likeStatus || 'null'}) → HIDE`)
        }
      })
      
      if (filteredCards.length === 0) {
        console.log('⚠️ No liked games found - all games will be HIDDEN')
      } else {
        console.log(`❤️ Showing ${filteredCards.length} liked game(s)`)
      }
    } else {
      // Show all games for other filters
      allCards.forEach(card => card.style.display = '')
    }
    
    // Sort by likes (for Recommended, Trending, Popular, and Liked)
    if (category === 'Recommended' || category === 'Trending' || category === 'Popular' || category === 'Liked') {
      // Only sort visible games (for 'Liked', this is already filteredCards)
      const cardsToSort = category === 'Liked' ? filteredCards : allCards.filter(card => card.style.display !== 'none')
      filteredCards = await sortGamesByLikes(cardsToSort)
    }
    
    // Reorder DOM elements (only visible/liked games)
    // CRITICAL: Deduplicate by gameId to prevent duplicate games
    const seenGameIds = new Set()
    const visibleCards = filteredCards.filter(card => {
      const gameId = card.id || card.getAttribute('data-game-id')
      if (!gameId) return false
      
      // Skip if we've already seen this gameId
      if (seenGameIds.has(gameId)) {
        console.warn(`⚠️ Duplicate game detected: ${gameId} - skipping`)
        return false
      }
      seenGameIds.add(gameId)
      
      // For 'Liked' filter, double-check localStorage
      if (category === 'Liked') {
        const likeStatus = localStorage.getItem('mp_like_' + gameId)
        return likeStatus === '1'
      }
      
      return card.style.display !== 'none'
    })
    
    console.log(`📋 Reordering ${visibleCards.length} unique games (${seenGameIds.size} unique gameIds)`)
    
    visibleCards.forEach((card) => {
      container.appendChild(card) // Move to end (will reorder)
    })
    
    // Reinitialize after reordering
    const newAllCards = Array.from(container.querySelectorAll('.game-card'))
    
    // CRITICAL: Remove any duplicate games by gameId (keep only the first occurrence)
    const gameIdMap = new Map()
    const duplicatesToRemove = []
    
    newAllCards.forEach((card, index) => {
      const gameId = card.id || card.getAttribute('data-game-id')
      if (!gameId) return
      
      if (gameIdMap.has(gameId)) {
        // This is a duplicate - mark for removal
        duplicatesToRemove.push(card)
        console.warn(`⚠️ Found duplicate game in DOM: ${gameId} at index ${index} - will be removed`)
      } else {
        gameIdMap.set(gameId, card)
      }
    })
    
    // Remove duplicates from DOM
    duplicatesToRemove.forEach(card => {
      card.remove()
      console.log(`🗑️ Removed duplicate game: ${card.id || card.getAttribute('data-game-id')}`)
    })
    
    // Get updated list after removing duplicates
    const finalAllCards = Array.from(container.querySelectorAll('.game-card'))
    
    // Final check: Ensure only liked games are visible when filter is 'Liked'
    if (category === 'Liked') {
      finalAllCards.forEach(card => {
        const gameId = card.id || card.getAttribute('data-game-id')
        if (!gameId) {
          card.style.display = 'none'
          return
        }
        
        const likeStatus = localStorage.getItem('mp_like_' + gameId)
        if (likeStatus !== '1') {
          card.style.display = 'none'
        }
      })
    }
    
    const visibleAllCards = finalAllCards.filter(card => card.style.display !== 'none')
    
    if (typeof window.initializeGameStates === 'function') {
      window.initializeGameStates(finalAllCards)
    }
    
    // Reinitialize observer (cards order changed)
    initGameObserver()
    
    // Auto load first game (after filter/sort) - only if there are visible games
    if (visibleAllCards.length > 0 && visibleAllCards[0]?.id) {
      const game1Id = visibleAllCards[0].id
      const game2Id = visibleAllCards[1]?.id
      
      const game1Card = getGameCardElement(game1Id)
      if (game1Card) {
        loadGameIframe(game1Id)
        setGameState(game1Id, GAME_STATES.ACTIVE)
        currentActiveGame = game1Id
        try { window.__memeplayActiveGame = game1Id } catch {}
        document.dispatchEvent(new CustomEvent('memeplay:active-game-changed', { detail: { gameId: game1Id } }))
        console.log(`🚀 Filter applied: Game 1 (${game1Id}) loaded`)
      }
      
      if (game2Id) {
        const game2Card = getGameCardElement(game2Id)
        if (game2Card) {
          setGameState(game2Id, GAME_STATES.WAITING)
          loadGameIframe(game2Id)
          console.log(`📦 Filter applied: Game 2 (${game2Id}) preloaded`)
        }
      }
      
      // Scroll to first game
      const gameContainer = document.querySelector('.game-container')
      if (game1Card && gameContainer) {
        gameContainer.style.scrollSnapType = 'none'
        gameContainer.scrollTop = 0
        game1Card.scrollIntoView({ behavior: 'smooth', block: 'start' })
        setTimeout(() => {
          gameContainer.style.scrollSnapType = 'y mandatory'
        }, 1000)
      }
    }
  }

  async function loadUserCreatedGames() {
    const container = document.querySelector('.game-container')
    if (!container) {
      console.warn('❌ Game container not found')
      return []
    }

    const baseUrl = window.location.origin.replace(/\/$/, '')
    container.querySelectorAll('.game-card[data-user-created="true"]').forEach(card => card.remove())

    // ✅ CLEANUP: Remove ALL existing Pacman games from production (one-time cleanup)
    // After this cleanup, new games created on production will display normally
    const isProduction = !window.location.origin.includes('localhost') && 
                         !window.location.origin.includes('127.0.0.1') && 
                         !window.location.origin.includes('192.168.')
    
    // Run Pacman cleanup only once per browser to avoid repeated heavy scans
    const PACMAN_CLEANUP_KEY = 'mp_pacman_cleanup_done_v2'
    let shouldRunPacmanCleanup = false
    try {
      shouldRunPacmanCleanup = localStorage.getItem(PACMAN_CLEANUP_KEY) !== 'true'
    } catch (err) {
      shouldRunPacmanCleanup = !window.__memeplayPacmanCleanupDone
    }

    if (isProduction && shouldRunPacmanCleanup) {
      console.log('🧹 [CLEANUP] Production detected - Removing existing Pacman games (one-time cleanup)')
      
      // Remove all Pacman games from DOM
      const allPacmanGames = container.querySelectorAll('.game-card[id^="pacman-"], .game-card[data-game-id^="pacman-"]')
      allPacmanGames.forEach(card => {
        const gameId = card.id || card.getAttribute('data-game-id') || ''
        if (gameId && (gameId.startsWith('pacman-') || gameId.startsWith('pacman-game-'))) {
          console.log(`🗑️ [CLEANUP] Removing Pacman game from DOM: ${gameId}`)
          card.remove()
        }
      })
      
      // Delete all Pacman games from localStorage (keep creation logic intact)
      const keysToDelete = []
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i)
        if (key && key.startsWith('pacman_brand_config_')) {
          const gameId = key.replace('pacman_brand_config_', '')
          if (gameId.startsWith('pacman-') || gameId.startsWith('pacman-game-')) {
            keysToDelete.push(key)
          }
        }
      }
      keysToDelete.forEach(key => {
        localStorage.removeItem(key)
        console.log(`🗑️ [CLEANUP] Deleted from localStorage: ${key}`)
      })
      
      if (keysToDelete.length > 0) {
        console.log(`✅ [CLEANUP] Removed ${keysToDelete.length} Pacman games from localStorage`)
      }

      try {
        localStorage.setItem(PACMAN_CLEANUP_KEY, 'true')
      } catch (_) {}
      window.__memeplayPacmanCleanupDone = true
    } else if (isProduction) {
      console.log('⏭️ [CLEANUP] Skipped Pacman cleanup (already completed once)')
    }

    // ✅ OPTIMIZATION 2: Priority loading - Check ?game= parameter first
    const urlParams = new URLSearchParams(window.location.search)
    const gameIdFromQuery = urlParams.get('game')
    let priorityGame = null
    let priorityGameActivated = false

    if (gameIdFromQuery) {
      console.log(`⚡ [PRIORITY] Loading game from ?game= parameter: ${gameIdFromQuery}`)
      priorityGame = loadGameFromLocalStorage(gameIdFromQuery, baseUrl)
      
      // ✅ FIX: If not found in localStorage, try Supabase immediately
      if (!priorityGame) {
        console.log(`⚠️ [PRIORITY] Priority game not found in localStorage, trying Supabase...`)
        try {
          const { data: rpcData, error: rpcError } = await supabase.rpc('list_user_created_games', {
            p_template_id: 'pacman-template'
          })
          
          if (!rpcError && Array.isArray(rpcData)) {
            const foundGame = rpcData.find(item => {
              const gameId = item?.game_id || item?.id
              return gameId === gameIdFromQuery
            })
            
            if (foundGame) {
              let stories = foundGame.stories || []
              if (typeof stories === 'string') {
                try {
                  stories = JSON.parse(stories)
                } catch (e) {
                  stories = []
                }
              }
              if (!Array.isArray(stories)) {
                stories = []
              }
              
              const gameId = foundGame.game_id || foundGame.id || gameIdFromQuery
              priorityGame = {
                source: 'supabase',
                gameId: gameId,
                title: foundGame.title || 'Pacman Game',
                creator: foundGame.creator_name || foundGame.creator_id || 'Creator',
                mapColor: foundGame.map_color || '#1a1a2e',
                fragmentLogoUrl: foundGame.fragment_logo_url || '',
                mapIndex: Number.isInteger(foundGame.map_index) ? foundGame.map_index : 0,
                stories: stories,
                likes: foundGame.likes_count ?? foundGame.likes ?? 0,
                comments: foundGame.comments_count ?? foundGame.comments ?? 0,
                plays: foundGame.plays_count ?? foundGame.plays ?? 0,
                templateUrl: foundGame.template_url || `${baseUrl}/games/templates/pacman-template/index.html?game=${gameId}`,
                publicUrl: foundGame.public_url || `${baseUrl}/?game=${gameId}`
              }
              console.log(`✅ [PRIORITY] Found priority game in Supabase: ${priorityGame.gameId}`)
              cachePacmanBrandConfig(priorityGame)
            } else {
              console.log(`⚠️ [PRIORITY] Priority game not found in Supabase: ${gameIdFromQuery}`)
            }
          }
        } catch (err) {
          console.error(`❌ [PRIORITY] Error loading from Supabase:`, err)
        }
      }
      
      if (priorityGame) {
        // Filter out old format
        if (!priorityGame.gameId.startsWith('pacman-game-')) {
          console.log(`⚡ [PRIORITY] Rendering priority game immediately: ${priorityGame.gameId}`)
          renderUserGameCard(priorityGame, container)
          priorityGameActivated = true
          // Activate game immediately (<200ms)
          setTimeout(() => {
            if (typeof activateGame === 'function') {
              console.log(`⚡ [PRIORITY] Activating priority game: ${priorityGame.gameId}`)
              activateGame(priorityGame.gameId)
            }
          }, 50)
        } else {
          console.log(`⚠️ [PRIORITY] Priority game is old format, skipping: ${gameIdFromQuery}`)
          priorityGame = null
        }
      }
    }

    // ✅ OPTIMIZATION 1: Optimistic rendering - Load all games from localStorage first (<100ms)
    const startTime = performance.now()
    const localGames = loadLocalUserGames(baseUrl)
    const localLoadTime = performance.now() - startTime
    console.log(`⚡ [OPTIMISTIC] Loaded ${localGames.length} games from localStorage in ${localLoadTime.toFixed(2)}ms`)

    // Filter out old format and priority game (already rendered)
    const filteredLocalGames = localGames.filter(game => {
      if (!game || !game.gameId) return false
      if (game.gameId.startsWith('pacman-game-')) return false // Old format
      // ✅ CLEANUP: Filter out Pacman games created on localhost (check templateUrl)
      if (game.gameId.startsWith('pacman-')) {
        const templateUrl = game.templateUrl || ''
        const isLocalGame = templateUrl.includes('localhost') || templateUrl.includes('127.0.0.1') || templateUrl.includes('192.168.')
        if (isLocalGame) {
          console.log(`🗑️ Filtering out Pacman game created on localhost: ${game.gameId} (templateUrl: ${templateUrl})`)
          return false
        }
      }
      if (priorityGameActivated && game.gameId === priorityGame?.gameId) return false // Skip if already rendered
      return true
    })

    // Render all local games immediately (optimistic)
    if (filteredLocalGames.length > 0) {
      console.log(`⚡ [OPTIMISTIC] Rendering ${filteredLocalGames.length} games from localStorage immediately`)
      filteredLocalGames.forEach(game => {
        // Skip if already rendered (priority game)
        if (document.getElementById(game.gameId)) {
          return
        }
        renderUserGameCard(game, container)
      })

      // ✅ FIX: Don't activate first game if in "Recommended" category (will sort by likes after)
      // Only activate first game if NOT in Recommended category (Liked, Trending, Popular)
      // This prevents showing wrong game before sort completes
      if (!priorityGameActivated && filteredLocalGames.length > 0) {
        const isRecommended = currentFilter === 'Recommended'
        if (!isRecommended) {
          // Only activate first game if NOT in Recommended category
        const firstGame = filteredLocalGames[0]
        setTimeout(() => {
          if (typeof activateGame === 'function') {
              console.log(`⚡ [OPTIMISTIC] Activating first game: ${firstGame.gameId} (category: ${currentFilter})`)
            activateGame(firstGame.gameId)
          }
        }, 100)
        } else {
          console.log(`⏭️ [OPTIMISTIC] Skipping first game activation (Recommended category - will sort by likes first)`)
        }
      }
    }

    // ✅ Load Supabase games in background (non-blocking)
    console.log(`🔄 [BACKGROUND] Loading games from Supabase in background...`)
    const supabasePromise = fetchSupabaseUserGames(baseUrl).then(supabaseGames => {
      console.log(`✅ [BACKGROUND] Supabase loaded ${supabaseGames.length} games`)
      // ✅ DEBUG: Log game IDs to see what was loaded
      if (supabaseGames.length > 0) {
        const gameIds = supabaseGames.map(g => g.gameId).filter(Boolean)
        console.log(`📋 [BACKGROUND] Supabase game IDs:`, gameIds)
        const pacmanGames = gameIds.filter(id => id.startsWith('pacman-') && !id.startsWith('pacman-game-'))
        if (pacmanGames.length > 0) {
          console.log(`🎮 [BACKGROUND] Found ${pacmanGames.length} Pacman games:`, pacmanGames)
        }
      }
      return supabaseGames
    }).catch(error => {
      console.error('❌ [BACKGROUND] Supabase load failed:', error)
      console.error('❌ [BACKGROUND] Error details:', error.message, error.stack)
      return []
    })

    // Wait for Supabase and merge with local games
    const supabaseGames = await supabasePromise
    const allGames = supabaseGames.length > 0 ? supabaseGames : localGames

    // ✅ DEBUG: Log before merge
    console.log(`📊 [MERGE] Before merge - Supabase: ${supabaseGames.length}, Local: ${localGames.length}`)

    // Merge: Supabase games override local games (have more accurate data like likes, comments)
    const gameMap = new Map()
    // Add local games first
    localGames.forEach(game => {
      if (game.gameId && !game.gameId.startsWith('pacman-game-')) {
        if (game.templateId === PACMAN_TEMPLATE_ID && game.gameId.startsWith('pacman-')) {
          const templateUrl = game.templateUrl || ''
          const isLocalGame = templateUrl.includes('localhost') || templateUrl.includes('127.0.0.1') || templateUrl.includes('192.168.')
          if (isLocalGame) {
            console.log(`🗑️ [MERGE] Filtered out localhost Pacman game: ${game.gameId}`)
            return
          }
        }
        gameMap.set(game.gameId, game)
        console.log(`📦 [MERGE] Added local game: ${game.gameId}`)
      } else if (game.gameId && game.gameId.startsWith('pacman-game-')) {
        console.log(`🗑️ [MERGE] Filtered out old format local game: ${game.gameId}`)
      }
    })
    // Override with Supabase games (more accurate)
    supabaseGames.forEach(game => {
      if (game.gameId && !game.gameId.startsWith('pacman-game-')) {
        if (game.templateId === PACMAN_TEMPLATE_ID && game.gameId.startsWith('pacman-')) {
          const templateUrl = game.templateUrl || ''
          const isLocalGame = templateUrl.includes('localhost') || templateUrl.includes('127.0.0.1') || templateUrl.includes('192.168.')
          if (isLocalGame) {
            console.log(`🗑️ [MERGE] Filtered out localhost Pacman game from Supabase: ${game.gameId} (templateUrl: ${templateUrl})`)
            return
          }
        }
        gameMap.set(game.gameId, game)
        console.log(`📦 [MERGE] Added/Updated Supabase game: ${game.gameId}`)
      } else if (game.gameId && game.gameId.startsWith('pacman-game-')) {
        console.log(`🗑️ [MERGE] Filtered out old format Supabase game: ${game.gameId}`)
      }
    })
    const mergedGames = Array.from(gameMap.values())

    console.log(`📊 [MERGE] Merged games: ${mergedGames.length} total (${supabaseGames.length} from Supabase, ${localGames.length} from local)`)
    const pacmanMerged = mergedGames.filter(g => g.gameId && g.gameId.startsWith('pacman-') && !g.gameId.startsWith('pacman-game-'))
    if (pacmanMerged.length > 0) {
      console.log(`🎮 [MERGE] Pacman games after merge: ${pacmanMerged.length}`, pacmanMerged.map(g => g.gameId))
    } else {
      console.warn(`⚠️ [MERGE] No Pacman games found after merge! Check Supabase and localStorage.`)
    }
    const blocksMerged = mergedGames.filter(g => g.gameId && g.gameId.startsWith('blocks-'))
    if (blocksMerged.length > 0) {
      console.log(`🧱 [MERGE] Blocks games after merge: ${blocksMerged.length}`, blocksMerged.map(g => g.gameId))
    } else {
      console.warn('⚠️ [MERGE] No Blocks games found after merge! Check localStorage/Supabase.')
    }

    // Update games that were already rendered (update likes, comments, etc.)
    mergedGames.forEach(game => {
      const existingCard = document.getElementById(game.gameId)
      if (existingCard) {
        // Update social counts if different
        const likeCount = existingCard.querySelector('[data-label="likes"]')
        const commentCount = existingCard.querySelector('[data-label="comments"]')
        if (likeCount && game.likes > 0) {
          likeCount.textContent = game.likes
        }
        if (commentCount && game.comments > 0) {
          commentCount.textContent = game.comments
        }
        // Update plays count
        if (typeof setPlaysLabelForCard === 'function' && Number.isFinite(game.plays)) {
          setPlaysLabelForCard(game.gameId, game.plays)
        }
      } else {
        // Render new games from Supabase that weren't in localStorage
        if (!game.gameId.startsWith('pacman-game-')) {
          if (game.templateId === PACMAN_TEMPLATE_ID && game.gameId.startsWith('pacman-')) {
            const templateUrl = game.templateUrl || ''
            const isLocalGame = templateUrl.includes('localhost') || templateUrl.includes('127.0.0.1') || templateUrl.includes('192.168.')
            if (isLocalGame) {
              console.log(`🗑️ [MERGE] Filtered out localhost Pacman game: ${game.gameId}`)
              return
            }
          }
          console.log(`🆕 [MERGE] Rendering new game from Supabase: ${game.gameId}`)
          renderUserGameCard(game, container)
        }
      }
    })
    
    // ✅ CLEANUP: All Pacman games were already removed at the start of this function (production only)
    // New games created on production will display normally after this cleanup

    const totalTime = performance.now() - startTime
    if (mergedGames.length > 0) {
      console.log(`✅ [COMPLETE] Loaded ${mergedGames.length} user-created game(s) in ${totalTime.toFixed(2)}ms (local: ${localLoadTime.toFixed(2)}ms, supabase: ${(totalTime - localLoadTime).toFixed(2)}ms)`)
    } else {
      console.log('ℹ️ No user-created games found')
    }
    return mergedGames
  }

  // ✅ OPTIMIZATION: Load single game from localStorage (for priority loading)
  function loadGameFromLocalStorage(gameId, baseUrl) {
    if (!gameId) return null
    const isBlocksGame = typeof gameId === 'string' && gameId.startsWith('blocks-')
    try {
      if (isBlocksGame) {
        const storageKey = `${BLOCKS_STORAGE_PREFIX}${gameId}`
        const saved = localStorage.getItem(storageKey)
        if (!saved) return null
        const config = JSON.parse(saved)
        if (!config) return null

        const storyText = typeof config.story === 'string' ? config.story : ''

        return {
          source: 'localStorage',
          templateId: BLOCKS_TEMPLATE_ID,
          gameId,
          title: storyText ? `Blocks 8x8 - ${storyText.slice(0, 24)}` : 'Blocks 8x8 Game',
          creator: 'Blocks 8x8',
          mapColor: config.mapColor || '#0a0a0a',
          fragmentLogoUrl: config.fragmentLogoUrl || '',
          mapIndex: 0,
          stories: storyText ? [storyText] : [],
          likes: 0,
          comments: 0,
          plays: 0,
          templateUrl: `${baseUrl}/games/crypto-blocks/index.html?game=${gameId}`,
          publicUrl: `${baseUrl}/?game=${gameId}`
        }
      }

      const storageKey = `${PACMAN_STORAGE_PREFIX}${gameId}`
      const saved = localStorage.getItem(storageKey)
      if (!saved) return null
      const config = JSON.parse(saved)
      if (!config || !config.title) return null
      
      return {
        source: 'localStorage',
        templateId: PACMAN_TEMPLATE_ID,
        gameId,
        title: config.title || 'Pacman Game',
        creator: config.title || 'Creator',
        mapColor: config.mapColor || '#1a1a2e',
        fragmentLogoUrl: config.fragmentLogoUrl || '',
        mapIndex: typeof config.mapIndex === 'number' ? config.mapIndex : 0,
        stories: Array.isArray(config.stories) ? config.stories : [],
        likes: 0,
        comments: 0,
        plays: 0,
        templateUrl: `${baseUrl}/games/templates/pacman-template/index.html?game=${gameId}`,
        publicUrl: `${baseUrl}/?game=${gameId}`
      }
    } catch (error) {
      console.warn(`[loadGameFromLocalStorage] Failed to load game ${gameId}:`, error)
      return null
    }
  }

  function loadLocalUserGames(baseUrl) {
    console.log('🔍 Loading user-created games from localStorage (fallback)...')
    const results = []
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i)
      if (!key) continue

      if (key.startsWith(PACMAN_STORAGE_PREFIX) && key.length > PACMAN_STORAGE_PREFIX.length) {
        if (key === 'pacman_brand_config') continue
      try {
          const gameId = key.replace(PACMAN_STORAGE_PREFIX, '')
        const config = JSON.parse(localStorage.getItem(key) || '{}')
        if (!config || !config.title) continue
        
        results.push({
          source: 'localStorage',
            templateId: PACMAN_TEMPLATE_ID,
          gameId,
          title: config.title || 'Pacman Game',
          creator: config.title || 'Creator',
          mapColor: config.mapColor || '#1a1a2e',
          fragmentLogoUrl: config.fragmentLogoUrl || '',
            mapIndex: typeof config.mapIndex === 'number' ? config.mapIndex : 0,
          stories: Array.isArray(config.stories) ? config.stories : [],
          likes: 0,
          comments: 0,
          plays: 0,
          templateUrl: `${baseUrl}/games/templates/pacman-template/index.html?game=${gameId}`,
          publicUrl: `${baseUrl}/?game=${gameId}`
        })
      } catch (error) {
          console.warn('Failed to parse local Pacman game config:', key, error)
        }
        continue
      }

      if (key.startsWith(BLOCKS_STORAGE_PREFIX) && key.length > BLOCKS_STORAGE_PREFIX.length) {
        if (key === 'blocks_brand_config') continue
        try {
          const gameId = key.replace(BLOCKS_STORAGE_PREFIX, '')
          const config = JSON.parse(localStorage.getItem(key) || '{}')
          if (!config) continue
          const storyText = typeof config.story === 'string' ? config.story : ''
          
          results.push({
            source: 'localStorage',
            templateId: BLOCKS_TEMPLATE_ID,
            gameId,
            title: storyText ? `Blocks 8x8 - ${storyText.slice(0, 24)}` : 'Blocks 8x8 Game',
            creator: 'Blocks 8x8',
            mapColor: config.mapColor || '#0a0a0a',
            fragmentLogoUrl: config.fragmentLogoUrl || '',
            mapIndex: 0,
            stories: storyText ? [storyText] : [],
            likes: 0,
            comments: 0,
            plays: 0,
          templateUrl: `${baseUrl}/games/crypto-blocks/index.html?game=${gameId}`,
            publicUrl: `${baseUrl}/?game=${gameId}`
          })
        } catch (error) {
          console.warn('Failed to parse local Blocks game config:', key, error)
        }
      }
    }
    return results
  }

  function cachePacmanBrandConfig(game) {
    if (!game?.gameId) return
    const id = game.gameId
    if (!id.startsWith('pacman-') || id.startsWith('pacman-game-')) return
    try {
      const payload = {
        fragmentLogoUrl: game.fragmentLogoUrl || '',
        title: game.title || 'Pacman Game',
        mapColor: game.mapColor || '#1a1a2e',
        mapIndex: Number.isInteger(game.mapIndex) ? game.mapIndex : 0,
        stories: Array.isArray(game.stories) ? game.stories : []
      }
      localStorage.setItem(`pacman_brand_config_${id}`, JSON.stringify(payload))
      console.log(`[cachePacmanBrandConfig] Cached config for ${id}`)
    } catch (error) {
      console.warn('[cachePacmanBrandConfig] Failed to cache Pacman config:', error)
    }
  }

  function cacheBlocksBrandConfig(game) {
    if (!game?.gameId || !game.gameId.startsWith('blocks-')) return
    try {
      const payload = {
        fragmentLogoUrl: game.fragmentLogoUrl || '',
        story: Array.isArray(game.stories) && game.stories.length > 0
          ? game.stories[0]
          : (typeof game.story === 'string' ? game.story : ''),
        mapColor: game.mapColor || '#0a0a0a'
      }
      localStorage.setItem(`${BLOCKS_STORAGE_PREFIX}${game.gameId}`, JSON.stringify(payload))
      console.log(`[cacheBlocksBrandConfig] Cached Blocks config for ${game.gameId}`)
    } catch (error) {
      console.warn('[cacheBlocksBrandConfig] Failed to cache Blocks config:', error)
    }
  }

  async function fetchSupabaseUserGames(baseUrl) {
    if (typeof supabase === 'undefined') {
      console.warn('⚠️ [fetchSupabaseUserGames] Supabase client not available')
      return []
    }

    const fetchByTemplate = async (templateId) => {
    try {
      const { data, error } = await supabase.rpc('list_user_created_games', {
          p_template_id: templateId
      })
      if (error) {
          console.error(`❌ [fetchSupabaseUserGames] RPC error (${templateId}):`, error.message || error)
        return []
      }
        if (!Array.isArray(data) || data.length === 0) {
          console.log(`ℹ️ [fetchSupabaseUserGames] No ${templateId} games found`)
        return []
      }

        const isBlocksTemplate = templateId === BLOCKS_TEMPLATE_ID

        return data
        .map(item => {
          const gameId = item?.game_id || item?.id
          if (!gameId) {
            console.warn('⚠️ [fetchSupabaseUserGames] Item missing game_id:', item)
            return null
          }

            let stories = []
            if (isBlocksTemplate) {
              const story = typeof item.story_one === 'string' ? item.story_one.trim() : ''
              if (story) stories.push(story)
            } else {
              stories = Array.isArray(item.stories) ? item.stories : []
              if (typeof item.stories === 'string') {
            try {
                  stories = JSON.parse(item.stories)
            } catch (e) {
              console.warn('⚠️ [fetchSupabaseUserGames] Failed to parse stories as JSON:', e)
              stories = []
            }
          }
              if (!Array.isArray(stories)) stories = []
              const legacyStories = [item.story_one, item.story_two, item.story_three]
                .filter(story => typeof story === 'string' && story.trim() !== '')
                .map(story => story.trim())
              if (legacyStories.length > 0) {
                stories = [...stories, ...legacyStories]
              }
              stories = stories
                .map(story => (typeof story === 'string' ? story.trim() : ''))
                .filter(story => story !== '')
            }

            const defaultTemplateUrl = isBlocksTemplate
              ? `${baseUrl}/games/crypto-blocks/index.html?game=${gameId}`
              : `${baseUrl}/games/templates/pacman-template/index.html?game=${gameId}`
            const templateUrl = item.template_url || defaultTemplateUrl
          const publicUrl = item.public_url || `${baseUrl}/?game=${gameId}`
          
          const isLocalGame = templateUrl.includes('localhost') || templateUrl.includes('127.0.0.1') || templateUrl.includes('192.168.')
          if (isLocalGame) {
            console.log(`🗑️ [fetchSupabaseUserGames] Filtering out localhost game: ${gameId} (template_url: ${templateUrl})`)
            return null
          }
          
            const game = {
            source: 'supabase',
              templateId,
            gameId,
              title: item.title || (isBlocksTemplate ? 'Blocks 8x8 Game' : 'Pacman Game'),
              creator: item.creator_name || item.creator_id || item.title || (isBlocksTemplate ? 'Blocks 8x8' : 'Creator'),
              mapColor: item.map_color || (isBlocksTemplate ? '#0a0a0a' : '#1a1a2e'),
            fragmentLogoUrl: item.fragment_logo_url || '',
              mapIndex: isBlocksTemplate ? 0 : (Number.isInteger(item.map_index) ? item.map_index : 0),
              stories,
            likes: item.likes_count ?? item.likes ?? 0,
            comments: item.comments_count ?? item.comments ?? 0,
            plays: item.plays_count ?? item.plays ?? 0,
              templateUrl,
              publicUrl
            }

            if (isBlocksTemplate) {
              cacheBlocksBrandConfig(game)
            } else {
              cachePacmanBrandConfig(game)
          }
            return game
        })
        .filter(Boolean)
    } catch (error) {
        console.error(`❌ [fetchSupabaseUserGames] Unexpected error (${templateId}):`, error)
      return []
    }
  }

    const [pacmanGames, blocksGames] = await Promise.all([
      fetchByTemplate(PACMAN_TEMPLATE_ID),
      fetchByTemplate(BLOCKS_TEMPLATE_ID)
    ])

    return [...pacmanGames, ...blocksGames]
  }

  function renderUserGameCard(game, container) {
    if (!game?.gameId) return
    
    // ✅ FIX: Skip rendering old format Pacman games (pacman-game-*)
    if (game.gameId.startsWith('pacman-game-')) {
      console.log(`🗑️ Skipping render for old format Pacman game: ${game.gameId}`)
      return
    }
    
    if (document.getElementById(game.gameId)) {
      console.log(`⏭️ Game ${game.gameId} already exists, skipping`)
      return
    }

    const gameCard = document.createElement('div')
    gameCard.className = 'game-card'
    gameCard.id = game.gameId
    gameCard.setAttribute('data-game-id', game.gameId)
    gameCard.setAttribute('data-user-created', 'true')
    gameCard.setAttribute('data-source', game.source || 'unknown')
    const isBlocksGame = (game.templateId === BLOCKS_TEMPLATE_ID) || (game.gameId && game.gameId.startsWith('blocks-'))
    gameCard.setAttribute('data-template-id', isBlocksGame ? BLOCKS_TEMPLATE_ID : (game.templateId || PACMAN_TEMPLATE_ID))

    const baseUrl = window.location.origin.replace(/\/$/, '')
    const sanitizeUrl = (url, fallbackPath) => {
      if (!url) return `${baseUrl}${fallbackPath}`
      let final = url
      if (/^https?:\/\//i.test(final)) {
        try {
          const parsed = new URL(final)
          if (parsed.hostname === '127.0.0.1' || parsed.hostname === 'localhost') {
            parsed.protocol = window.location.protocol
            parsed.host = window.location.host
            final = parsed.toString()
          }
        } catch (_) {}
      } else {
        final = final.startsWith('/') ? baseUrl + final : `${baseUrl}/${final}`
      }
      return final
    }

    const defaultPath = isBlocksGame
      ? `/games/crypto-blocks/index.html?game=${game.gameId}`
      : `/games/templates/pacman-template/index.html?game=${game.gameId}`
    let templateUrl = sanitizeUrl(game.templateUrl, defaultPath)
    if (!templateUrl) {
      console.warn(`⚠️ Missing templateUrl for ${game.gameId}, skipping render`)
      return
    }

    const cacheBuster = `v=${Date.now()}`
    const finalUrl = templateUrl.includes('?')
      ? `${templateUrl}&${cacheBuster}`
      : `${templateUrl}?${cacheBuster}`

    gameCard.innerHTML = `
      <div class="game-stage">
        <iframe
          data-game-url="${templateUrl || game.templateUrl}"
          src="${finalUrl}"
          width="720"
          height="1000"
          frameborder="0"
          scrolling="no"
          allow="autoplay; fullscreen; gamepad"
          style="overflow: hidden; border: none;"
          title="${game.title || (isBlocksGame ? 'Blocks 8x8 Game' : 'Pacman Game')}">
        </iframe>
        <button class="focus-toggle" type="button" aria-label="Toggle focus mode" aria-pressed="false">⤢</button>
      </div>
      <footer class="game-footer">
        <div class="game-icons">
          <div class="game-icons-left">
            <div class="icon-wrapper" data-role="like">
              <button type="button" title="Like" aria-label="Like">
                <svg viewBox="0 0 48 48" aria-hidden="true">
                  <path d="M24 40.5l-1.2-1.1C16 33 10 28 10 21.5 10 17 13.6 13.5 18 13.5c2.8 0 5.5 1.4 7 3.8 1.5-2.4 4.2-3.8 7-3.8 4.4 0 8 3.5 8 8 0 6.5-6 11.6-12.8 17.9L24 40.5z" />
                </svg>
              </button>
              <span class="icon-count" data-label="likes">${game.likes ?? 0}</span>
            </div>
            <div class="icon-wrapper" data-role="comment">
              <button type="button" title="Comments" aria-label="Comments">
                <svg viewBox="0 0 48 48" aria-hidden="true">
                  <path d="M9 20.5c0-7.2 7.5-12.5 16-12.5s16 5.3 16 12.5-7.5 12.5-16 12.5c-2.3 0-4.6-.3-6.7-.9l-5.8 4.7 1.7-6.3C11.5 27.4 9 24.2 9 20.5z" />
                </svg>
              </button>
              <span class="icon-count" data-label="comments">${game.comments ?? 0}</span>
            </div>
            <div class="icon-wrapper" data-role="share">
              <button type="button" title="Share" aria-label="Share">
                <svg viewBox="0 0 48 48" aria-hidden="true">
                  <path d="M10 36 Q16 24 24 18 Q32 12 40 14 M40 14 L35 10 M40 14 L35 18" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
            </div>
            <div class="icon-wrapper" data-role="leaderboard">
              <button type="button" title="Leaderboard & Rewards" aria-label="Leaderboard">
                <svg viewBox="0 0 48 48" aria-hidden="true">
                  <rect x="8" y="22" width="10" height="18" />
                  <rect x="19" y="12" width="10" height="28" />
                  <rect x="30" y="26" width="10" height="14" />
                </svg>
              </button>
            </div>
          </div>
          <div class="game-icons-right">
            <div class="icon-wrapper" data-role="marketcap">
              <button type="button" title="Market Cap" aria-label="Market Cap">
                <span>...</span>
              </button>
            </div>
          </div>
        </div>
        <div class="creator-text">
          Creator: <strong>${game.creator || game.title || 'User'}</strong>
        </div>
      </footer>
    `

    container.appendChild(gameCard)

    // ✅ Ensure iframe src is set (for browsers that strip inline attributes during DOM insertion)
    const iframeEl = gameCard.querySelector('iframe')
    if (iframeEl && !iframeEl.src) {
      iframeEl.src = finalUrl
    }
    if (isBlocksGame && iframeEl) {
      const blocksPayload = {
        type: 'CRYPTO_BLOCKS_CONFIG',
        payload: {
          story: (Array.isArray(game.stories) && game.stories.length > 0) ? game.stories[0] : '',
          mapColor: game.mapColor || '#0a0a0a',
          logoUrl: game.fragmentLogoUrl || ''
        }
      }
      const sendBlocksConfig = () => {
        try {
          iframeEl.contentWindow?.postMessage(blocksPayload, '*')
        } catch (err) {
          console.warn('[Blocks card] Failed to send config:', err)
        }
      }
      iframeEl.addEventListener('load', () => {
        sendBlocksConfig()
        setTimeout(sendBlocksConfig, 300)
      })
    }

    if (typeof setPlaysLabelForCard === 'function' && Number.isFinite(game.plays)) {
      setPlaysLabelForCard(game.gameId, game.plays)
    }
  }

  async function loadGameCards() {
    const container = document.querySelector('.game-container')
    if (!container) return
    try {
      const response = await fetch('games/game-list.html', { cache: 'no-cache' })
      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      const markup = await response.text()
      const parser = new DOMParser()
      const doc = parser.parseFromString(markup, 'text/html')
      const wrapper = doc.querySelector('[data-game-list]')
      container.innerHTML = wrapper ? wrapper.innerHTML : markup
      console.log('✅ Game cards loaded:', document.querySelectorAll('.game-card').length)
      
      // ✅ Apply virtual window immediately so hero + buffer remain visible while waiting for sort/data
      refreshVirtualVisibility('initial-static')
      
      // ✅ FIX: Remove old format Pacman games immediately after loading
      const oldFormatGames = container.querySelectorAll('.game-card[id^="pacman-game-"], .game-card[data-game-id^="pacman-game-"]')
      oldFormatGames.forEach(card => {
        const gameId = card.id || card.getAttribute('data-game-id') || ''
        console.log(`🗑️ Removing old format Pacman game from DOM: ${gameId}`)
        card.remove()
      })
      
      initFocusControls()
      
      // Load user-created games after loading static games
      await loadUserCreatedGames()
      
      // ✅ FIX: Final cleanup - remove any remaining old format Pacman games
      const remainingOldGames = container.querySelectorAll('.game-card[id^="pacman-game-"], .game-card[data-game-id^="pacman-game-"]')
      remainingOldGames.forEach(card => {
        const gameId = card.id || card.getAttribute('data-game-id') || ''
        console.log(`🗑️ Final cleanup - removing old format Pacman game: ${gameId}`)
        card.remove()
      })
      
      // ✅ FIXED: Get all games and wait for sort before loading first game
      // This ensures game with most likes is shown first
      const allCards = Array.from(document.querySelectorAll('.game-card'))
      const gameContainer = document.querySelector('.game-container')
      
      // ✅ DEBUG: Check if gameContainer exists
      if (!gameContainer) {
        console.error('❌ [INITIAL] game-container not found in DOM!')
        console.log('Available containers:', document.querySelectorAll('[class*="container"]'))
      } else {
        console.log('✅ [INITIAL] game-container found')
      }

      const focusGameCard = (targetGameId, {
        block = 'center',
        behavior = 'auto',
        activate = true,
        activateDelay = 150,
        reason = '',
        lockMs = 4000,
        afterActivate = null
      } = {}) => {
        if (!targetGameId) return false
        
        // ✅ FIX: Use container if exists, otherwise use document
        const searchContainer = container || document
        const targetCard = Array.from(searchContainer.querySelectorAll('.game-card')).find(card => {
          const cardId = card.id || card.getAttribute('data-game-id')
          return cardId === targetGameId
        })
        if (!targetCard) {
          console.warn(`⚠️ [FOCUS] Target game not found: ${targetGameId}`)
          return false
        }
        console.log(`🎯 [FOCUS] ${reason || 'direct'} → ${targetGameId}`)
        
        // ✅ FIX: Re-query gameContainer to ensure it exists after DOM reorder
        const currentGameContainer = document.querySelector('.game-container')
        if (!currentGameContainer) {
          console.warn(`⚠️ [FOCUS] game-container not found in DOM, skipping scroll but will still activate game`)
        } else {
          const previousSnap = currentGameContainer.style.scrollSnapType
          const previousBehavior = currentGameContainer.style.scrollBehavior
          currentGameContainer.style.scrollSnapType = 'none'
          currentGameContainer.style.scrollBehavior = behavior
          requestAnimationFrame(() => {
            try {
              targetCard.scrollIntoView({ behavior, block })
              console.log(`✅ [FOCUS] scrollIntoView called for ${targetGameId}`)
            } catch (err) {
              console.warn('[FOCUS] scrollIntoView failed:', err)
            }
            setTimeout(() => {
              if (currentGameContainer) {
                currentGameContainer.style.scrollSnapType = previousSnap || 'y mandatory'
                currentGameContainer.style.scrollBehavior = previousBehavior || 'smooth'
              }
            }, 800)
          })
        }
        if (activate && typeof activateGame === 'function') {
          const lockExpiresAt = Date.now() + lockMs
          if (lockMs > 0) {
            window.__memeplayLockObserverUntil = lockExpiresAt
            window.__memeplayPinnedGameId = targetGameId
          }
          setTimeout(() => {
            console.log(`🎮 [FOCUS] Activating game: ${targetGameId}`)
            activateGame(targetGameId)
            if (typeof afterActivate === 'function') {
              afterActivate()
            }
            console.log(`✅ [FOCUS] Game activated: ${targetGameId}`)
          }, activateDelay)
          if (lockMs > 0) {
            setTimeout(() => {
              if (window.__memeplayLockObserverUntil === lockExpiresAt) {
                window.__memeplayLockObserverUntil = 0
                window.__memeplayPinnedGameId = null
              }
            }, lockMs + 200)
          }
        } else {
          console.warn(`⚠️ [FOCUS] activateGame function not available or activate=false`)
        }
        return true
      }
      
      // STEP 2: Initialize game states
      if (typeof window.initializeGameStates === 'function') {
        window.initializeGameStates(allCards)
      } else {
        allCards.forEach(card => {
          const gid = card?.id || card?.dataset?.gameId
          if (gid) {
            card.dataset.gameState = card.dataset.gameState || 'hidden'
          }
        })
      }
      
      // STEP 3: Init social handlers only
      // ✅ CRITICAL: DO NOT init observer here - it will activate wrong game before sort
      initSocialHandlers()
      
      // STEP 4: Handle hash navigation (from share links)
      // ⚠️ SKIP hash navigation if in Recommended category - let STEP 6 handle it after sort
      // This ensures game with most likes is shown first, not hash game
      const allCardsWithUserCreated = Array.from(document.querySelectorAll('.game-card'))
      // Check ?game= parameter first (for Pacman games)
      const urlParams = new URLSearchParams(window.location.search)
      const gameIdFromQuery = urlParams.get('game')
      
      // If ?game= parameter exists, use it; otherwise use hash
      const hash = gameIdFromQuery || window.location.hash.slice(1)
      const isRecommended = currentFilter === 'Recommended'
      
      // ✅ OPTIMIZATION: If game was already activated by priority loading, skip this
      // Priority loading already activated the game, just need to scroll into view
      const wasPriorityLoaded = gameIdFromQuery && document.getElementById(gameIdFromQuery)?.dataset?.gameState === 'active'
      
      // Check if target game exists in all cards (including user-created games)
      const targetGameExists = hash && allCardsWithUserCreated.some(c => {
        const cardId = c.id || c.getAttribute('data-game-id')
        return cardId === hash
      })
      
      if (targetGameExists && !isRecommended) {
        // Only handle hash navigation if NOT in Recommended category
        if (wasPriorityLoaded) {
          // Game already activated by priority loading, just scroll into view
          console.log('🔗 [PRIORITY] Game already activated, scrolling into view:', hash)
          setTimeout(() => {
            focusGameCard(hash, { activate: false, behavior: 'smooth', block: 'center', reason: 'priority-loaded hash' })
          }, 200)
        } else {
          // Normal hash navigation (not priority loaded)
          console.log('🔗 Hash/Query detected (not Recommended):', hash)
          setTimeout(() => {
            focusGameCard(hash, { behavior: 'smooth', block: 'start', reason: 'hash navigation' })
          }, 1000)
        }
      } else if (hash && isRecommended) {
        if (gameIdFromQuery) {
          console.log('🔗 Query detected in Recommended category - will handle without resort')
        } else {
        console.log('🔗 Hash/Query detected in Recommended category, will be handled after sort:', hash)
        }
      } else if (hash && !targetGameExists) {
        console.log('⚠️ Hash/Query game not found in current games:', hash)
      }
      
      // STEP 5: MEMEPLAY logo click → Home (Game #1)
      const logoEl = document.getElementById('memeplayLogo')
      if (logoEl) {
        logoEl.addEventListener('click', () => {
          console.log('🏠 MEMEPLAY logo clicked → Go to Game #1')
          window.location.hash = ''
          const firstCard = Array.from(document.querySelectorAll('.game-card'))[0]
          if (firstCard && gameContainer) {
            gameContainer.style.scrollSnapType = 'none'
            gameContainer.scrollTop = 0
            firstCard.scrollIntoView({ behavior: 'smooth', block: 'start' })
            if (firstCard.id) activateGame(firstCard.id)
            setTimeout(() => {
              gameContainer.style.scrollSnapType = 'y mandatory'
            }, 1000)
          }
        })
      }
      
      // STEP 6: Sort games by likes FIRST, then load the game with most likes OR ?game= parameter
      // ✅ CRITICAL: Sort BEFORE loading first game to ensure game with most likes is shown
      const shouldSkipInitialSort = Boolean(gameIdFromQuery)
      console.log('📊 [INITIAL] Starting sort by likes (will load game with most likes after sort)...')
      sortGamesByLikes(allCards).then(sortedCards => {
        if (!Array.isArray(sortedCards) || sortedCards.length === 0) {
          console.warn('📊 [INITIAL] Sort returned no cards, skipping reorder')
          initGameObserver()
          return
        }
        console.log('📊 [INITIAL] Sort completed, evaluating order...')
        
        // ✅ DEBUG: Log top 3 games after sort
        const top3 = sortedCards.slice(0, 3).map((card, idx) => {
          const gameId = card.id || card.getAttribute('data-game-id')
          return `${idx + 1}. ${gameId}`
        })
        console.log('📊 [INITIAL] Top 3 games after sort:', top3.join(', '))
        
        const firstAfterSort = sortedCards[0]?.id || sortedCards[0]?.getAttribute('data-game-id')
        const firstBeforeSort = allCards[0]?.id || allCards[0]?.getAttribute('data-game-id')
        
        console.log(`📊 [INITIAL] First game before sort: ${firstBeforeSort}, after sort: ${firstAfterSort}`)
        
        if (shouldSkipInitialSort) {
          console.log('📊 [INITIAL] Skipping DOM reorder due to direct ?game target')
          const locked = focusGameCard(gameIdFromQuery, {
            reason: 'direct-link skip sort',
            lockMs: 5000
          })
          if (!locked) {
            const fallbackId = sortedCards[0]?.id || sortedCards[0]?.getAttribute('data-game-id')
            focusGameCard(fallbackId, { reason: 'fallback after skip' })
          }
          setTimeout(() => {
            initGameObserver()
            console.log('✅ [INITIAL] Game observer initialized after direct-link focus')
          }, 1200)
          return
        }
        
        // Reorder DOM
        sortedCards.forEach(card => {
          container.appendChild(card)
        })
        
        const handleAfterActivate = (targetId) => () => {
                  const secondAfterSort = sortedCards[1]?.id || sortedCards[1]?.getAttribute('data-game-id')
                  if (secondAfterSort && !isPacmanGame(secondAfterSort)) {
                    const secondCard = getGameCardElement(secondAfterSort)
                    if (secondCard) {
                      setGameState(secondAfterSort, GAME_STATES.WAITING)
                      loadGameIframe(secondAfterSort)
                    }
                  } else if (secondAfterSort && isPacmanGame(secondAfterSort)) {
                    console.log(`⏭️ [Pacman] Skipping preload of second Pacman game: ${secondAfterSort}`)
                  }
                  console.log(`✅ [INITIAL] Scrolled to target game: ${targetId} and activated`)
        }
        
        // ✅ PRIORITY: Check ?game= parameter first (for direct links)
        const urlParams = new URLSearchParams(window.location.search)
        const latestQueryId = urlParams.get('game')
        const targetGameId = latestQueryId || hash || firstAfterSort
        
        // ✅ DEBUG: Log target game selection
        console.log(`🔍 [INITIAL] Target game selection:`, {
          latestQueryId,
          hash,
          firstAfterSort,
          targetGameId,
          sortedCardsLength: sortedCards.length
        })
        
        // Check if target game exists in sorted cards
        const targetCard = sortedCards.find(card => {
          const cardId = card.id || card.getAttribute('data-game-id')
          return cardId === targetGameId
        })
        
        // ✅ DEBUG: Log target card search
        if (targetCard) {
          const targetCardId = targetCard.id || targetCard.getAttribute('data-game-id')
          console.log(`✅ [INITIAL] Target card found: ${targetCardId}`)
        } else {
          console.warn(`⚠️ [INITIAL] Target card NOT found for: ${targetGameId}`)
          console.log(`Available sorted cards:`, sortedCards.slice(0, 3).map(c => c.id || c.getAttribute('data-game-id')))
        }
        
        const focusAfterSort = (finalGameId, originLabel) => {
          if (!finalGameId) {
            console.warn(`⚠️ [FOCUS] No gameId provided for focusAfterSort`)
            return false
          }
          console.log(`🎯 [FOCUS] Attempting to focus: ${finalGameId} (${originLabel})`)
          // ✅ FIX: Increase lock time to 6s to ensure observer doesn't activate different game
          // Observer init after 2.5s, so 6s lock ensures it won't activate game thứ 2
          const ok = focusGameCard(finalGameId, {
            block: 'center',
            behavior: 'auto',
            reason: originLabel,
            lockMs: 6000, // Increased from 4000ms to 6000ms
            afterActivate: handleAfterActivate(finalGameId)
          })
          if (ok) {
            refreshVirtualVisibility(`focus-${originLabel}`)
          }
          if (!ok && firstAfterSort && finalGameId !== firstAfterSort) {
            console.warn(`⚠️ [FOCUS] focusGameCard failed for ${finalGameId}, trying fallback: ${firstAfterSort}`)
            focusGameCard(firstAfterSort, {
              block: 'center',
              behavior: 'auto',
              reason: 'fallback after sort',
              afterActivate: handleAfterActivate(firstAfterSort)
            })
          } else if (!ok) {
            console.error(`❌ [FOCUS] focusGameCard failed for ${finalGameId} and no fallback available`)
          }
          if (ok) {
            refreshVirtualVisibility(`focus-${originLabel}`)
          }
          return ok
        }
        
        let initialFocusHandled = false
        const hasShareTarget = Boolean(latestQueryId || hash)
        if (targetCard && hasShareTarget) {
          const finalGameId = targetCard.id || targetCard.getAttribute('data-game-id')
          console.log(`🎯 [INITIAL] Scrolling to hash/query target: ${finalGameId}`)
          initialFocusHandled = focusAfterSort(finalGameId, latestQueryId ? 'query after sort' : 'hash after sort')
        }
        
        if (!initialFocusHandled && firstAfterSort) {
          console.log(`🎯 [INITIAL] Using top liked after sort: ${firstAfterSort}`)
          initialFocusHandled = focusAfterSort(firstAfterSort, 'top liked default')
        }
        
        if (!initialFocusHandled) {
          // ✅ FALLBACK: If no game found, try to activate first visible game card
          console.warn('⚠️ [INITIAL] No game found after sort, trying fallback...')
          const fallbackCard = Array.from(document.querySelectorAll('.game-card')).find(card => {
            const cardId = card.id || card.getAttribute('data-game-id')
            return cardId && card.style.display !== 'none'
          })
          if (fallbackCard) {
            const fallbackId = fallbackCard.id || fallbackCard.getAttribute('data-game-id')
            console.log(`🔄 [INITIAL] Fallback: Activating first visible game: ${fallbackId}`)
            focusAfterSort(fallbackId, 'fallback first visible')
          } else {
            console.error('❌ [INITIAL] No game cards found in DOM!')
          }
        }
        
        // Reinitialize after reordering
        const allCardsReordered = Array.from(document.querySelectorAll('.game-card'))
        if (typeof window.initializeGameStates === 'function') {
          window.initializeGameStates(allCardsReordered)
        }
        
        // ✅ CRITICAL: Init observer ONLY after scroll complete
        // Wait for scroll animation (600ms) + buffer to ensure observer doesn't activate wrong game
        // ✅ FIX: Increase delay to ensure focusGameCard completes first
        setTimeout(() => {
          // ✅ DEBUG: Check which game is currently active before init observer
          const currentActive = window.__memeplayActiveGame || document.querySelector('.game-card.is-playing')?.id
          console.log(`👁️ [INITIAL] Initializing observer, current active game: ${currentActive || 'none'}`)
          initGameObserver()
          console.log('✅ [INITIAL] Game observer initialized after sort and scroll')
          refreshVirtualVisibility('after-observer-init')
        }, 2500) // Increased from 2000ms to 2500ms to ensure focusGameCard completes
      }).catch(error => {
        console.error('📊 [INITIAL] Sort failed:', error)
        // Continue with original order if sort fails
      })
      
      // ✅ REMOVED: Unload games logic - This was causing games 3+ to not display
      // Games are now managed by activateGame() function which properly loads/unloads games as needed
      // Only unload games that are very far away (more than 3 positions) to save memory
      
    } catch (error) {
      console.error('Load game list failed:', error)
      container.innerHTML = '<div style="padding:24px;text-align:center;color:#bbb;">Unable to load games. Please refresh.</div>'
    }
  }

  function updateFocusButtons() {
    const active = document.body.classList.contains('focus-mode')
    document.querySelectorAll('.focus-toggle').forEach(btn => {
      btn.setAttribute('aria-pressed', active ? 'true' : 'false')
      btn.textContent = active ? '⤡' : '⤢'
    })
  }

  const focusState = { scrollTop: 0, gameId: null }

  function toggleFocusMode(force) {
    const next = typeof force === 'boolean' ? force : !document.body.classList.contains('focus-mode')
    document.body.classList.toggle('focus-mode', !!next)
    const container = document.querySelector('.game-container')
    if (!next) {
      if (container) {
        container.style.scrollBehavior = 'auto'
        if (focusState.gameId) {
          const card = document.getElementById(focusState.gameId)
          if (card) {
            container.scrollTop = Math.max(0, card.offsetTop - container.offsetTop)
          } else {
            container.scrollTop = Math.max(0, focusState.scrollTop)
          }
        } else {
          container.scrollTop = Math.max(0, focusState.scrollTop)
        }
        container.style.scrollBehavior = ''
      }
      clearFocusActiveCard()
    } else {
      if (container) {
        focusState.scrollTop = container.scrollTop
      }
      const fallbackId = currentActiveGame || document.querySelector('.game-card')?.id
      let focusId = window.__memeplayActiveGame || fallbackId
      if (!focusId && fallbackId) focusId = fallbackId
      if (focusId) {
        focusState.gameId = focusId
        if (!window.__memeplayActiveGame) {
          try { window.__memeplayActiveGame = focusId } catch {}
        }
        applyFocusActiveCard(focusId)
      }
      requestAnimationFrame(scrollActiveGameIntoView)
    }
    updateFocusButtons()
    
    // Notify iframes about focus mode change
    // ✅ FIX: Hỗ trợ cả pixel-space-shooter và Pacman games
    const isFocus = document.body.classList.contains('focus-mode');
    document.querySelectorAll('iframe[data-game-url*="pixel-space-shooter"], iframe[data-game-url*="pacman"]').forEach(iframe => {
      if (iframe.contentWindow) {
        iframe.contentWindow.postMessage({
          type: 'FOCUS_MODE_CHANGED',
          isFocus: isFocus
        }, '*');
      }
    });
  }

  function initFocusControls() {
    const buttons = document.querySelectorAll('.focus-toggle')
    buttons.forEach(btn => {
      if (btn.dataset.bound === '1') return
      btn.dataset.bound = '1'
      btn.addEventListener('click', (event) => {
        event.preventDefault()
        event.stopPropagation()
        const ownerCard = btn.closest('.game-card')
        if (ownerCard) {
          const gid = ownerCard.getAttribute('data-game-id') || ownerCard.id
          if (gid) {
            try { window.__memeplayActiveGame = gid } catch {}
            focusState.gameId = gid
          }
        }
        toggleFocusMode()
      })
    })
    updateFocusButtons()
  }

  function scrollActiveGameIntoView() {
    const container = document.querySelector('.game-container')
    if (!container) return
    const targetId = window.__memeplayActiveGame || currentActiveGame || container.querySelector('.game-card')?.id
    if (!targetId) return
    const card = document.getElementById(targetId)
    if (!card) return
    container.style.scrollBehavior = 'auto'
    container.scrollTop = Math.max(0, card.offsetTop - container.offsetTop)
    container.style.scrollBehavior = ''
  }

  function clearFocusActiveCard() {
    document.querySelectorAll('.game-card.is-focus-active').forEach(card => card.classList.remove('is-focus-active'))
  }

  function applyFocusActiveCard(gameId) {
    if (!gameId) return
    const card = document.getElementById(gameId)
    if (!card) return
    clearFocusActiveCard()
    card.classList.add('is-focus-active')
  }

  function lockGameTouch(gameId) {
    const stage = document.querySelector(`.game-card[data-game-id="${gameId}"] .game-stage`)
    if (!stage || stage.dataset.touchLocked === '1') return
    stage.dataset.touchLocked = '1'
    const prevent = (event) => { if (event.cancelable) event.preventDefault() }
    // Only prevent touchmove to stop scrolling, don't interfere with touchstart
    stage.addEventListener('touchmove', prevent, { passive: false, capture: true })
  }

  document.addEventListener('memeplay:active-game-changed', (event) => {
    const gameId = event?.detail?.gameId
    if (gameId) {
      try { window.__memeplayActiveGame = gameId } catch {}
      focusState.gameId = gameId
      lockGameTouch(gameId)
      if (document.body.classList.contains('focus-mode')) {
        applyFocusActiveCard(gameId)
        requestAnimationFrame(scrollActiveGameIntoView)
      }
    }
  })

  window.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && document.body.classList.contains('focus-mode')) {
      toggleFocusMode(false)
    }
  })

  await loadGameCards()
  lockGameTouch('wojak-btc-blast')

  // ✅ Supabase already initialized at top of script (before loadGameCards)

  // 🚀 Helper: Send RPC with keepalive (prevents data loss on F5/close)
  async function rpcWithKeepalive(functionName, params) {
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/${functionName}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Prefer': 'return=representation'
        },
        body: JSON.stringify(params),
        keepalive: true  // ← Ensures delivery even if page closes!
      })
      
      if (!response.ok) {
        const errorText = await response.text()
        console.error(`❌ [RPC] ${functionName} failed (${response.status}):`, errorText)
        throw new Error(`RPC ${functionName} failed: ${response.status} ${response.statusText}`)
      }
      
      const data = await response.json()
      
      // Supabase RPC có thể return:
      // - Object trực tiếp: { is_new_best: true, ... }
      // - Array: [{ is_new_best: true, ... }]
      // - String (nếu function return TEXT): "result"
      // - Null nếu function không tồn tại
      
      // Log để debug
      if (data === null || (Array.isArray(data) && data.length === 0)) {
        console.warn(`⚠️ [RPC] ${functionName} returned null/empty. Function may not exist in Supabase.`)
      }
      
      return { data, error: null }
    } catch (error) {
      console.error(`❌ [RPC] rpcWithKeepalive(${functionName}) error:`, error.message)
      return { data: null, error }
    }
  }

  // =========================================================
  // 🔹 CREATE UNIQUE USER ID (stored in localStorage)
  // =========================================================
  // User identifier prefers wallet address if connected; falls back to random local id
  function generateLocalUuid() {
    try {
      const cryptoObj = globalThis.crypto || globalThis.msCrypto
      if (cryptoObj?.randomUUID) return cryptoObj.randomUUID()
      if (cryptoObj?.getRandomValues) {
        const buf = cryptoObj.getRandomValues(new Uint8Array(16))
        buf[6] = (buf[6] & 0x0f) | 0x40
        buf[8] = (buf[8] & 0x3f) | 0x80
        const hex = Array.from(buf, b => b.toString(16).padStart(2, '0')).join('')
        return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`
      }
    } catch (err) {
      console.warn('generateLocalUuid fallback', err)
    }
    const fallback = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0
      const v = c === 'x' ? r : ((r & 0x3) | 0x8)
      return v.toString(16)
    })
    return fallback
  }

  function getLocalUserId() {
    let id = localStorage.getItem('mp_user_id')
    if (!id) {
      id = 'u_' + generateLocalUuid()
      localStorage.setItem('mp_user_id', id)
    }
    return id
  }
  function getWalletAddress() {
    return localStorage.getItem('mp_user_wallet') || ''
  }
  let userId = getWalletAddress() || getLocalUserId()
  console.log('👤 Current user identifier:', userId)

  // =========================================================
  // 🔹 UI HELPERS (PLAY points header only)
  // =========================================================
  const els = {
    headerEarned: document.getElementById('headerEarned'),
    headerEarnedFlash: document.getElementById('headerEarnedFlash'),
    streak: document.getElementById('streakCount'),
    connectBtn: document.getElementById('walletConnectBtn'),
    walletBadge: document.getElementById('walletStatusBtn'),
    walletStatus: document.getElementById('walletStatusText')
  }

  function lsGetInt(key, fallback = 0) {
    const raw = localStorage.getItem(key)
    const num = raw == null ? NaN : Number(raw)
    return Number.isFinite(num) ? num : fallback
  }
  function lsSetInt(key, value) {
    localStorage.setItem(key, String(Math.max(0, Math.trunc(value))))
  }
  // No status bar counters

  function updateHeaderEarned() {
    const totalEarned = lsGetInt('mp_total_earned_plays')
    els.headerEarned && (els.headerEarned.textContent = String(totalEarned))
    if (typeof window.__updateStatsOverlay === 'function') window.__updateStatsOverlay()
  }

  // Show inline banner near PLAY points and apply increment after 3s
  // Confetti Engine
  function createConfetti() {
    const canvas = document.getElementById('confettiCanvas')
    if (!canvas) return
    const ctx = canvas.getContext('2d')
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    
    const particles = []
    const colors = ['#ffb642', '#ff9000', '#ffd700', '#ff6b6b', '#4ecdc4']
    
    for (let i = 0; i < 100; i++) {
      particles.push({
        x: canvas.width / 2,
        y: (canvas.height * 0.5) - 50, // 50px higher than toast (toast at 50%)
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 1) * 15,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: Math.random() * 8 + 4,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10
      })
    }
    
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      let active = false
      
      particles.forEach(p => {
        p.vy += 0.3 // Gravity
        p.x += p.vx
        p.y += p.vy
        p.rotation += p.rotationSpeed
        
        if (p.y < canvas.height + 50) {
          active = true
          ctx.save()
          ctx.translate(p.x, p.y)
          ctx.rotate(p.rotation * Math.PI / 180)
          ctx.fillStyle = p.color
          ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size)
          ctx.restore()
        }
      })
      
      if (active) requestAnimationFrame(animate)
      else canvas.style.opacity = '0'
    }
    
    canvas.style.opacity = '1'
    animate()
    
    setTimeout(() => {
      canvas.style.opacity = '0'
    }, 3000)
  }

  function showAchievementToast(achievementName, count, total, reward) {
    const toast = document.getElementById('achievementToast')
    const nameEl = document.getElementById('achievementName')
    const rewardEl = document.getElementById('achievementReward')
    
    if (!toast) return
    
    // ✅ "10s Play Reward" doesn't show (x/3) because it's not a 1-time achievement
    // ❌ 60s, 300s still show (x/3)
    const showProgress = achievementName !== '10s Play Reward'
    nameEl.textContent = showProgress ? `⭐ ${achievementName} (${count}/${total})` : `⭐ ${achievementName}`
    rewardEl.textContent = `+${reward} PLAY`
    
    toast.classList.add('show')
    
    // Auto-dismiss after 5s
    const autoHideTimeout = setTimeout(() => {
      toast.classList.remove('show')
    }, 5000)
    
    // Store timeout ID so X button can cancel it
    toast.dataset.autoHideTimeout = autoHideTimeout
  }
  
  // Achievement toast X button handler (close immediately)
  document.addEventListener('DOMContentLoaded', () => {
    const closeBtn = document.getElementById('achievementToastClose')
    const toast = document.getElementById('achievementToast')
    
    if (closeBtn && toast) {
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        console.log('✅ Close button clicked!');
        
        // Cancel auto-hide timeout
        if (toast.dataset.autoHideTimeout) {
          clearTimeout(parseInt(toast.dataset.autoHideTimeout))
        }
        // Hide immediately
        toast.classList.remove('show')
      }, { capture: true });
      
      // Also add touchend for mobile
      closeBtn.addEventListener('touchend', (e) => {
        e.stopPropagation();
        e.preventDefault();
        console.log('✅ Close button touched!');
        
        if (toast.dataset.autoHideTimeout) {
          clearTimeout(parseInt(toast.dataset.autoHideTimeout))
        }
        toast.classList.remove('show')
      }, { capture: true, passive: false });
    }
  })

  function celebrateAchievement(gameId, achievementName, count, reward) {
    console.log('🎯 [DEBUG] celebrateAchievement called!', { gameId, achievementName, count, reward })
    
    // 1. Fireworks explosion
    console.log('🎆 [DEBUG] Creating confetti...')
    createConfetti()
    
    // 2. Toast center
    console.log('🍞 [DEBUG] Showing achievement toast...')
    showAchievementToast(achievementName, count, 3, reward)
    
    // 3. Icon rung
    const card = document.querySelector(`.game-card[data-game-id="${gameId}"]`)
    const achievementIcon = card?.querySelector('.icon-wrapper[data-role="leaderboard"]')
    if (achievementIcon) {
      console.log('📍 [DEBUG] Shaking achievement icon...')
      achievementIcon.classList.add('shake')
      setTimeout(() => achievementIcon.classList.remove('shake'), 800)
      
    }

    const leaderboardOverlayEl = document.getElementById('leaderboardOverlay')
    if (leaderboardOverlayEl?.classList.contains('open')) {
      console.log('🏆 [DEBUG] Rendering rewards panel...')
      renderRewardsPanel(gameId)
    }
  }

  // Queue achievements to show after game over
  const pendingAchievements = {}
  let isGameOver = false // Flag to prevent showing rewards during gameplay
  
  // Show all pending achievements for a game
  // CRITICAL: Only show after game over, not during gameplay
  function showPendingAchievements(gameId) {
    // SECURITY: Only allow showing achievements after game over
    if (!isGameOver) {
      console.warn('⚠️ [SECURITY] showPendingAchievements called during gameplay - BLOCKED! Must wait for game over.')
      return
    }
    
    console.log('🔔 [DEBUG] showPendingAchievements called for:', gameId)
    console.log('🔔 [DEBUG] pendingAchievements object:', pendingAchievements)
    
    const achievements = pendingAchievements[gameId]
    console.log('🔔 [DEBUG] achievements for', gameId, ':', achievements)
    
    if (!achievements || achievements.length === 0) {
      console.log('❌ [DEBUG] No achievements to show!')
      return
    }
    
    console.log(`🎉 Showing ${achievements.length} pending achievement(s) for ${gameId}`)
    
    // Sort by threshold (10 → 60 → 300)
    achievements.sort((a, b) => a.threshold - b.threshold)
    
    // Show each achievement with delay
    achievements.forEach((ach, index) => {
      console.log(`🎊 [DEBUG] Scheduling achievement ${index + 1}:`, ach)
      setTimeout(() => {
        console.log(`🎊 [DEBUG] NOW showing achievement:`, ach.name)
        celebrateAchievement(gameId, ach.name, ach.count, ach.reward)
      }, index * 2500) // Each achievement 2.5s apart
    })
    
    // Clear queue after showing
    delete pendingAchievements[gameId]
    
    // Reset flag after showing (for next game)
    setTimeout(() => {
      isGameOver = false
    }, achievements.length * 2500 + 1000)
  }
  
  // Expose globally but with protection - games should NOT call this directly
  // Only game over handler should call this
  window.__showPendingAchievements = showPendingAchievements
  
  function showPlayAward(amount, label, isNewAchievement = false) {
    if (!amount || amount <= 0) return
    
    // Update total
    const newTotal = lsGetInt('mp_total_earned_plays') + amount
    lsSetInt('mp_total_earned_plays', newTotal)
    updateHeaderEarned()
    
    // If new achievement, QUEUE to show after game over
    if (isNewAchievement && activeGame) {
      const achievedCount = Object.values(getGameAwards(activeGame)).filter(Boolean).length
      // ✅ Rename: "Starter" → "10s Play Reward" (repeatable every time)
      const achievementNames = { 10: '10s Play Reward', 60: 'Engaged', 300: 'Champion' }
      const threshold = parseInt(label.replace('s', ''))
      
      // Add to pending queue
      if (!pendingAchievements[activeGame]) {
        pendingAchievements[activeGame] = []
      }
      pendingAchievements[activeGame].push({
        name: achievementNames[threshold],
        count: achievedCount,
        reward: amount,
        threshold
      })
      
      console.log(`🎖️ Achievement queued: ${achievementNames[threshold]} (+${amount} PLAY)`)
      console.log('   → Will show Toast after game over + Header flash NOW')
      console.log('   🔑 Queued for activeGame:', activeGame)
      console.log('   📦 Current queue:', pendingAchievements)
      // DON'T return - continue showing header flash!
    }
    
    // Header flash - ALWAYS SHOW for all rewards!
    const el = els.headerEarnedFlash
    if (!el) return
    el.textContent = `+${amount} PLAY${label ? ` for ${label}` : ''}`
    el.style.opacity = '1'
    setTimeout(() => {
      el.style.opacity = '0'
    }, 10000)
  }

  function updateStreak() {
    const streak = lsGetInt('mp_streak_count')
    els.streak && (els.streak.textContent = String(streak))
    if (typeof window.__updateStatsOverlay === 'function') window.__updateStatsOverlay()
  }

  // Initialize UI from localStorage
  updateHeaderEarned()
  updateStreak()

  // Load initial real play counts for all cards
  document.querySelectorAll('.game-card').forEach(card => {
    const gid = card.getAttribute('data-game-id') || card.id
    if (gid) {
      loadPlayCount(gid)
    }
  })

  // ==============================
  // Wallet Connect (MetaMask)
  // ==============================
  function shortAddr(addr) {
    if (!addr) return ''
    const lower = String(addr).toLowerCase()
    if (lower.length <= 6) return lower
    return `${lower.slice(0, 3)}...${lower.slice(-3)}`
  }
  function setWalletStatus(addr) {
    if (!els.walletStatus) return
    els.walletStatus.textContent = addr ? `connected :${shortAddr(addr)}` : ''
    if (typeof window.__updateWalletOverlay === 'function') window.__updateWalletOverlay()
  }
  setWalletStatus(getWalletAddress())

  async function connectWallet() {
    if (!window.ethereum) {
      const ua = navigator.userAgent || ''
      const isMobile = /iphone|ipad|ipod|android/i.test(ua)
      if (isMobile) {
        const rawUrl = window.location.href.split('#')[0]
        const cleaned = rawUrl.replace(/^https?:\/\//i, '')
        const deepLink = `https://metamask.app.link/dapp/${cleaned}`
        const proceed = confirm('MetaMask mobile not opened. Open MetaMask app to connect?')
        if (proceed) {
          window.location.href = deepLink
        }
      } else {
        alert('Please install MetaMask to connect your wallet.')
      }
      return
    }
    try {
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })
      const address = (accounts && accounts[0]) ? String(accounts[0]) : ''
      if (!address) return
      localStorage.setItem('mp_user_wallet', address)
      userId = address // prefer wallet as identifier
      setWalletStatus(address)
      setConnectButtonState()
      // Do not auto re-checkin on wallet switch; guard by daily window
      if (!hasCheckedInToday()) {
        try { await dailyCheckin() } catch {}
      }
    } catch (e) {
      console.warn('Wallet connect failed:', e?.message || e)
    }
  }
  function disconnectWallet() {
    localStorage.removeItem('mp_user_wallet')
    userId = getLocalUserId()
    setWalletStatus('')
    setConnectButtonState()
  }
  function ensureWalletBindings() {
    const connectBtn = els.connectBtn
    const statusBtn = els.walletBadge
    if (connectBtn && !connectBtn.__memeplayBound) {
      connectBtn.addEventListener('click', (event) => {
        event.preventDefault()
        connectWallet()
      })
      connectBtn.__memeplayBound = true
    }
    if (statusBtn && !statusBtn.__memeplayBound) {
      statusBtn.addEventListener('click', () => {
        if (typeof window.__openWalletOverlay === 'function') {
          window.__openWalletOverlay()
        }
      })
      statusBtn.__memeplayBound = true
    }
  }
  function setConnectButtonState() {
    if (!els.connectBtn || !els.walletBadge) return
    const address = getWalletAddress()
    const isConnected = !!address

    if (isConnected) {
      els.connectBtn.hidden = true
      els.walletBadge.hidden = false
      els.walletStatus.textContent = `connected :${shortAddr(address)}`
      ensureWalletBindings()
    } else {
      els.connectBtn.hidden = false
      els.walletBadge.hidden = true
      ensureWalletBindings()
    }
  }
  const walletApi = {
    connect: () => connectWallet(),
    disconnect: () => disconnectWallet(),
    isConnected: () => !!getWalletAddress(),
    getAddress: () => getWalletAddress(),
    getStreak: () => lsGetInt('mp_streak_count'),
    getPlayPoints: () => lsGetInt('mp_total_earned_plays'),
    openOverlay: () => {
        if (typeof window.__openWalletOverlay === 'function') {
          window.__openWalletOverlay()
        }
      }
    }
  try {
    const existing = (globalThis.memeplayWallet && typeof globalThis.memeplayWallet === 'object') ? globalThis.memeplayWallet : {}
    globalThis.memeplayWallet = Object.assign({}, existing, walletApi)
  } catch {
    globalThis.memeplayWallet = walletApi
  }
  ensureWalletBindings()
  els.connectBtn && setConnectButtonState()
  if (window.ethereum) {
    window.ethereum.on?.('accountsChanged', (accs) => {
      const addr = (accs && accs[0]) ? String(accs[0]) : ''
      if (addr) {
        localStorage.setItem('mp_user_wallet', addr)
        userId = addr
        setWalletStatus(addr)
      } else {
        localStorage.removeItem('mp_user_wallet')
        userId = getLocalUserId()
        setWalletStatus('')
      }
      setConnectButtonState()
    })
  }

  // =========================================================
  // 🔹 PER-GAME ACCUMULATED PLAYTIME & ONE-TIME REWARDS
  // =========================================================
  const REWARD_THRESHOLDS = [10, 60, 300] // seconds (10s so user quickly understands rewards)
  const REWARD_VALUES = { 10: 100, 60: 300, 300: 1000 }
  const MAX_ACCUM_SECONDS = 300

  function getGameSeconds(gameId) {
    return lsGetInt(`mp_game_seconds_${gameId}`)
  }
  function setGameSeconds(gameId, seconds) {
    lsSetInt(`mp_game_seconds_${gameId}`, Math.min(seconds, MAX_ACCUM_SECONDS))
  }
  function getGameAwards(gameId) {
    try {
      const raw = localStorage.getItem(`mp_game_awards_${gameId}`)
      return raw ? JSON.parse(raw) : {}
    } catch {
      return {}
    }
  }
  function setGameAwards(gameId, awardsObj) {
    localStorage.setItem(`mp_game_awards_${gameId}`, JSON.stringify(awardsObj || {}))
  }
  // Console helpers
  function listAllGameSeconds() {
    const cards = Array.from(document.querySelectorAll('.game-card'))
    const rows = cards.map(c => {
      const id = c.getAttribute('data-game-id') || c.id || 'unknown'
      return { gameId: id, seconds: getGameSeconds(id) }
    })
    console.table(rows)
    return rows
  }
  function resetGameProgress(gameId) {
    if (!gameId) return false
    lsSetInt(`mp_game_seconds_${gameId}`, 0)
    localStorage.removeItem(`mp_game_awards_${gameId}`)
    console.log(`🔄 Reset progress for ${gameId}`)
    return true
  }
  // Expose to window for activation script and dev console usage
  const helpers = Object.freeze({
    // inspectors
    getGameSeconds,
    listAllGameSeconds,
    resetGameProgress,
    // controls
    startGame,
    stopGame,
    forceStart
  })
  try { window.memeplay = helpers } catch {}
  try { self.memeplay = helpers } catch {}
  try { globalThis.memeplay = helpers } catch {}
  console.log('🧩 memeplay helpers ready:', Object.keys(helpers))
  function grantPlays(amount) {
    if (!amount || amount <= 0) return 0
    const newTotal = lsGetInt('mp_total_earned_plays') + amount
    lsSetInt('mp_total_earned_plays', newTotal)
    updateHeaderEarned()
    return amount
  }

  // ===== Real play counts (per game) =====
  function setPlaysLabelForCard(gameId, totalPlays) {
    const card = document.querySelector(`.game-card[data-game-id="${gameId}"]`) || document.getElementById(gameId)
    if (!card) return
    const creator = card.querySelector('.creator-text')
    if (!creator) return
    let span = creator.querySelector('[data-plays-count]')
    if (!span) {
      // insert separator dot and span once
      const sep = document.createTextNode(' • ')
      span = document.createElement('span')
      span.setAttribute('data-plays-count', gameId)
      creator.appendChild(sep)
      creator.appendChild(span)
    }
    span.textContent = `${totalPlays} plays`

    const statsCount = card.querySelector('.icon-wrapper[data-role="stats"] .icon-count')
    if (statsCount) statsCount.textContent = String(Math.max(0, totalPlays|0))
  }
  async function loadPlayCount(gameId) {
    try {
      console.log('📥 [PLAYS] loadPlayCount →', gameId)
      const { data, error } = await supabase.rpc('get_game_play_count', { p_game_id: gameId })
      if (error) { console.error('get_game_play_count error:', error.message); return }
      const val = (data && typeof data.total_plays === 'number') ? data.total_plays : 0
      setPlaysLabelForCard(gameId, val)
      console.log(`[plays] ${gameId}:`, val)
    } catch (e) { console.error('get_game_play_count error:', e?.message || e) }
  }
  async function incrementPlayCountIfEligible(gameId, seconds) {
    if (!gameId || !seconds || seconds < 5) return
    try {
      const { data, error } = await supabase.rpc('increment_play_count', {
        p_user_id: userId,
        p_game_id: gameId,
        p_seconds: seconds
      })
      if (error) { console.error('increment_play_count error:', error.message); return }
      const val = (data && typeof data.total_plays === 'number') ? data.total_plays : undefined
      if (val != null) {
        setPlaysLabelForCard(gameId, val)
        console.log(`[plays +1] ${gameId}:`, val)
      }
    } catch (e) {
      console.error('increment_play_count error:', e?.message || e)
    }
  }

  // =========================================================
  // 🔹 DAILY CHECK-IN (guarded once per day per device)
  // =========================================================
  function todayKey() {
    const d = new Date()
    return d.toISOString().slice(0,10)
  }
  function hasCheckedInToday() {
    return localStorage.getItem('mp_checkin_'+todayKey()) === '1'
  }
  function markCheckedInToday() {
    localStorage.setItem('mp_checkin_'+todayKey(), '1')
  }
  // Show daily check-in toast with stats
  function showDailyCheckInToast(streak, reward, totalDays = null) {
    // Remove old toast if exists
    const oldToast = document.querySelector('.daily-checkin-toast');
    if (oldToast) oldToast.remove();
    
    // Create toast element
    const toast = document.createElement('div');
    toast.className = 'daily-checkin-toast';
    
    // Build stats HTML
    let statsHTML = `
      <div class="daily-checkin-stat">
        <span class="daily-checkin-stat-value">${streak}</span>
        <span class="daily-checkin-stat-label">🔥 Day Streak</span>
      </div>
    `;
    
    // Add total days if available
    if (totalDays && totalDays > 0) {
      statsHTML += `
        <div class="daily-checkin-stat">
          <span class="daily-checkin-stat-value">${totalDays}</span>
          <span class="daily-checkin-stat-label">📅 Total Days</span>
        </div>
      `;
    }
    
    toast.innerHTML = `
      <div class="daily-checkin-icon">🎁</div>
      <div class="daily-checkin-title">Daily Check-in!</div>
      <div class="daily-checkin-stats">
        ${statsHTML}
      </div>
      <div class="daily-checkin-reward">+${reward} PLAY</div>
    `;
    
    document.body.appendChild(toast);
    
    // Show toast
    setTimeout(() => toast.classList.add('show'), 100);
    
    // Hide after 5 seconds
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => {
        toast.remove();
        // ✅ Show create game toast after daily reward is hidden
        showCreateGameToast();
      }, 500);
    }, 5000);
  }

  function showCreateGameToast() {
    // Remove old toast if exists
    const oldToast = document.querySelector('.create-game-toast');
    if (oldToast) oldToast.remove();
    
    // Create toast element
    const toast = document.createElement('div');
    toast.className = 'create-game-toast';
    
    toast.innerHTML = `
      <div class="create-game-toast-content">
        <div class="create-game-icon"></div>
        <span class="create-game-text">Create FREE game with your brand in 10s</span>
      </div>
    `;
    
    // Click handler to open editor
    toast.addEventListener('click', () => {
      window.location.href = '/games/templates/pacman-template/index.html#creatorScreen';
    });
    
    document.body.appendChild(toast);
    
    // Show toast
    setTimeout(() => toast.classList.add('show'), 100);
    
    // Hide after 3 seconds with fade out
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 500);
    }, 3000);
  }

  async function dailyCheckin() {
    const { data, error } = await supabase.rpc('daily_checkin', { p_user_id: userId })
    if (error) {
      console.error('❌ Daily check-in error:', error.message)
      return
    }
    console.log('✅ Daily check-in result:', data)
    if (data?.awarded > 0) {
      // Show new daily check-in toast
      const streak = Number(data.streak) || 1;
      const totalDays = Number(data.total_days) || null; // If backend provides it
      showDailyCheckInToast(streak, Number(data.awarded), totalDays);
      
      // Still update header (small notification)
      showPlayAward(Number(data.awarded), 'daily login')
      markCheckedInToday()
    }
    if (Number.isFinite(data?.streak)) {
      lsSetInt('mp_streak_count', Number(data.streak))
      updateStreak()
    }
  }

  // Only run on first load if not already checked in today (prevents wallet-switch abuse)
  if (!hasCheckedInToday()) dailyCheckin()
// ==============================
//  AUTO-TRACK PLAYTIME + FOCUS DELAY
// ==============================

// Global variable to track running game
let activeGame = null;
let activeStartTime = 0;
let progressInterval = null;

// Start timer
function startGame(gameId) {
  // If another game is running, stop it; if same game, reset ticker/time
  if (activeGame && activeGame !== gameId) stopGame();

  // Reset ticker before starting (even for same game)
  clearInterval(progressInterval);
  progressInterval = null;

  activeGame = gameId;
  activeStartTime = Date.now();
  console.log(`▶️ Game ${gameId} started`);
  
  // Mark game card as playing to disable animations/transitions
  document.querySelectorAll('.game-card').forEach(card => card.classList.remove('is-playing'));
  const activeCard = document.querySelector(`.game-card[data-game-id="${gameId}"]`);
  if (activeCard) activeCard.classList.add('is-playing');

  // Live progress ticker: log session and cumulative totals every 5 seconds (optimized for performance)
  clearInterval(progressInterval);
  progressInterval = setInterval(() => {
    if (!activeGame || !activeStartTime) return;
    
    // Use requestIdleCallback to avoid interrupting game
    if (window.requestIdleCallback) {
      window.requestIdleCallback(() => {
        updateProgress();
      }, { timeout: 1000 });
    } else {
      updateProgress();
    }
  }, 5000);
  
  function updateProgress() {
    if (!activeGame || !activeStartTime) return;
    const sessionSeconds = Math.max(0, Math.floor((Date.now() - activeStartTime) / 1000));
    const prevTotal = getGameSeconds(activeGame);
    const previewTotal = Math.min(prevTotal + sessionSeconds, MAX_ACCUM_SECONDS);

    // Early reward grant when crossing thresholds during play
    const awardedMap = getGameAwards(activeGame);
    const crossedNow = [];
    for (const t of REWARD_THRESHOLDS) {
      if (prevTotal < t && previewTotal >= t && !awardedMap[t]) {
        awardedMap[t] = true;
        crossedNow.push(t);
      }
    }
    if (crossedNow.length) {
      setGameAwards(activeGame, awardedMap);
      let grant = 0;
      for (const t of crossedNow) grant += REWARD_VALUES[t];
      if (grant > 0) {
        const last = crossedNow[crossedNow.length - 1]
        showPlayAward(grant, `${last}s`, true) // ← true = NEW achievement!
      }
    }

    console.log(`⏳ ${activeGame}: session ${sessionSeconds}s · total ${previewTotal}/${MAX_ACCUM_SECONDS}s`);
  }
}

// Force safe start when switching games
function forceStart(gameId) {
  try { stopGame(); } catch {}
  clearInterval(progressInterval);
  progressInterval = null;
  activeGame = null;
  activeStartTime = 0;
  startGame(gameId);
}

  // Stop timer + send data to Supabase
async function stopGame() {
  if (!activeGame || !activeStartTime) return;

    const seconds = Math.floor((Date.now() - activeStartTime) / 1000);
  if (seconds > 0) {
      // Optimistic UI bump (visible immediately), will be corrected after server refresh
      try {
        if (seconds >= 3) {
          const card = document.querySelector(`.game-card[data-game-id="${activeGame}"]`) || document.getElementById(activeGame)
          const creator = card?.querySelector('.creator-text')
          if (creator) {
            const span = creator.querySelector('[data-plays-count]')
            if (span && /\d+/.test(span.textContent || '')) {
              const cur = parseInt((span.textContent || '0').replace(/\D/g, ''), 10) || 0
              span.textContent = `${cur + 1} plays`
            }
          }
          const statsCount = card?.querySelector('.icon-wrapper[data-role="stats"] .icon-count')
          if (statsCount && /\d+/.test(statsCount.textContent || '')) {
            const cur = parseInt((statsCount.textContent || '0').replace(/\D/g, ''), 10) || 0
            statsCount.textContent = String(cur + 1)
          }
        }
      } catch {}
    console.log(`⏱ Played ${seconds}s on ${activeGame}`);

    // Calculate per-game accumulated time and threshold rewards
    const prevTotal = getGameSeconds(activeGame)
    const nextTotalRaw = prevTotal + seconds
    const prevCapped = Math.min(prevTotal, MAX_ACCUM_SECONDS)
    const nextCapped = Math.min(nextTotalRaw, MAX_ACCUM_SECONDS)
    setGameSeconds(activeGame, nextCapped)

    const awardedMap = getGameAwards(activeGame)
    const newlyAwarded = []
    for (const t of REWARD_THRESHOLDS) {
      if (prevCapped < t && nextCapped >= t && !awardedMap[t]) {
        awardedMap[t] = true
        newlyAwarded.push(t)
      }
    }
    console.log(`📈 Accumulated for ${activeGame}: ${nextCapped}s (was ${prevCapped}s)`) 
    if (newlyAwarded.length) {
      let totalGrant = 0
      for (const t of newlyAwarded) totalGrant += REWARD_VALUES[t]
      setGameAwards(activeGame, awardedMap)
      if (totalGrant > 0) {
        const last = newlyAwarded[newlyAwarded.length - 1]
        showPlayAward(totalGrant, `${last}s`, true) // ← true = NEW achievement!
      }
    }

    // Use keepalive to prevent data loss on F5/close tab
    try {
      const { data, error } = await rpcWithKeepalive('track_playtime_and_reward', {
        p_user_id: userId,
        p_game_id: activeGame,
        p_seconds: seconds
      });
      if (error) throw error;
      console.log(`🎮 [${activeGame}] reward result:`, data);
      
      // ❌ REMOVED: Backend reward display (duplicate with frontend achievement system!)
      // Frontend already handles rewards via threshold checking (line ~2356)
      // Backend RPC just saves to DB, no need to show notification again!
      // if (data?.awarded > 0) showPlayAward(Number(data.awarded))
    } catch (err) {
      console.error('Playtime tracking error:', err.message);
    }

    // Increment real play count if eligible with keepalive
    if (seconds >= 3) {
      try {
        // 🔁 Legacy games: always send a fixed 3s to ensure exactly +1 play per full session
        // (backend may derive plays from seconds, e.g. floor(seconds / 3))
        const secondsForRpc = isLegacyGame(activeGame) ? 3 : seconds;
        const payload = {
          p_user_id: userId,
          p_game_id: activeGame,
          p_seconds: secondsForRpc
        };
        console.log('📈 [PLAYS] increment_play_count (stopGame) →', payload);
        let { data, error } = await rpcWithKeepalive('increment_play_count', payload);
        if (error) throw error;
        
        // Update UI after server confirms (accurate count)
        if (data && typeof data.total_plays === 'number') {
          setPlaysLabelForCard(activeGame, data.total_plays)
          console.log(`📊 [plays +1] ${activeGame}: ${data.total_plays}`)
          try { loadPlayCount(activeGame) } catch {}
        }
      } catch (err) {
        console.error('Play count increment error:', err.message);
        // If backend already counted (409 Conflict), just refresh UI from server
        const msg = String(err?.message || '');
        if (msg.includes('409') || msg.toLowerCase().includes('conflict')) {
          try { await loadPlayCount(activeGame) } catch {}
        } else {
          // Retry once after a short delay
          try {
            await new Promise(r => setTimeout(r, 800));
            const retryPayload = {
              p_user_id: userId,
              p_game_id: activeGame,
              p_seconds: seconds
            };
            console.log('📈 [PLAYS] increment_play_count RETRY →', retryPayload);
            const { data, error } = await rpcWithKeepalive('increment_play_count', retryPayload);
            if (!error && data && typeof data.total_plays === 'number') {
              setPlaysLabelForCard(activeGame, data.total_plays)
              console.log(`📊 [plays +1 retry] ${activeGame}: ${data.total_plays}`)
              try { loadPlayCount(activeGame) } catch {}
            } else {
              try { await loadPlayCount(activeGame) } catch {}
            }
          } catch (e2) {
            console.error('Play count retry failed:', e2.message);
            try { await loadPlayCount(activeGame) } catch {}
          }
        }
      }
    }
  }

  // Remove any stray global refresh (handled inside stopGame now)

  // Remove is-playing class to re-enable animations
  document.querySelectorAll('.game-card').forEach(card => card.classList.remove('is-playing'));
  
  activeGame = null;
  activeStartTime = 0;
  clearInterval(progressInterval);
  progressInterval = null;
}

// When iframe finishes loading game → start tracking with delay
const iframes = document.querySelectorAll(".game-card iframe");
const fallbackTimers = {} // Track fallback timers for games without postMessage
window.fallbackTimers = fallbackTimers // Expose globally for GAME_SCORE handler

if (iframes && iframes.length) {
iframes.forEach((iframe) => {
  const gameId = iframe.closest(".game-card")?.dataset.gameId;
  if (!gameId) {
    console.warn("⚠️ Missing data-game-id for an iframe, tracking skipped.");
    return;
  }

  iframe.addEventListener("load", () => {
    // DON'T auto-start timer when iframe loads!
    // Timer only starts when user ACTUALLY plays (via GAME_SCORE message)
    console.log(`✅ Iframe loaded: ${gameId} (timer will start when user plays)`);
  });
  
  // 🔧 FALLBACK: Detect click on .game-stage (iframe wrapper)
  const gameStage = iframe.closest('.game-stage')
  if (gameStage) {
    gameStage.addEventListener('click', () => {
      console.log(`🖱️ [FALLBACK] User clicked game: ${gameId}`)
      
      // Clear previous fallback timer
      if (fallbackTimers[gameId]) {
        clearTimeout(fallbackTimers[gameId])
      }
      
      // If timer already running → skip
      if (activeGame === gameId && activeStartTime) {
        console.log(`⏭️ [FALLBACK] Timer already running for ${gameId}`)
        return
      }
      
      // Wait 2 seconds, if no GAME_SCORE → start timer
      fallbackTimers[gameId] = setTimeout(() => {
        if (activeGame !== gameId || !activeStartTime) {
          console.log(`⚠️ [FALLBACK] No GAME_SCORE after 2s → Auto-starting timer for ${gameId}`)
          startGame(gameId)
      }
      }, 2000)
    }, { passive: true })
  }
});
}

// Stop when tab hidden
document.addEventListener("visibilitychange", () => {
  if (document.hidden) {
    stopGame();
  } else if (activeGame && gameStartTime) {
    // ✅ ONLY resume timer if game IS PLAYING (has gameStartTime)
    // ❌ DON'T auto-start if only activeGame exists (haven't clicked play)
    startGame(activeGame);
  }
});

// Stop when leaving page
window.addEventListener("beforeunload", stopGame);

  // ==============================
  // Likes & Comments (Supabase RPC)
  function initSocialHandlers() {
    // Global overlay controller (single instance handlers)
    const overlay = document.getElementById('commentsOverlay')
    const listEl = document.getElementById('commentsList')
    const loadMoreBtn = document.getElementById('commentsLoadMore')
    const closeBtn = document.getElementById('commentsCloseBtn')
    const ta = document.getElementById('commentsTextarea')
    const postBtn = document.getElementById('commentsPostBtn')

    const paging = { gameId: null, offset: 0, limit: 10, loading: false, done: false }
    function shortAddr10(addr){ if(!addr) return ''; return addr.slice(0,6) + '…' + addr.slice(-3) }
    async function fetchMore(){
      if (paging.loading || paging.done || !paging.gameId) return
      paging.loading = true
      try {
        const { data, error } = await supabase.rpc('list_comments', {
          p_game_id: paging.gameId,
          p_limit: paging.limit,
          p_offset: paging.offset
        })
        if (error) throw error
        const rows = Array.isArray(data) ? data : []
        if (rows.length === 0) { paging.done = true; return }
        rows.forEach(r => {
          const item = document.createElement('div')
          item.className = 'comment-item'
          const meta = document.createElement('div')
          meta.className = 'comment-meta'
          const when = new Date(r.created_at).toLocaleString()
          meta.textContent = `${shortAddr10(r.user_id)} • ${when}`
          const text = document.createElement('div')
          text.className = 'comment-text'
          text.textContent = r.text
          item.appendChild(meta)
          item.appendChild(text)
          listEl.appendChild(item)
        })
        paging.offset += rows.length
        
        // ✅ Update comment count after loading comments
        const card = document.querySelector(`.game-card[data-game-id="${paging.gameId}"]`)
        if (card) {
          const cmtWrapper = card.querySelector('.icon-wrapper[data-role="comment"]')
          const cmtCountEl = cmtWrapper?.querySelector('.icon-count')
          if (cmtCountEl && paging.offset > 0) {
            // Only update if current count = 0 (wrong) but actually has comments
            const currentCount = parseInt(cmtCountEl.textContent) || 0
            if (currentCount === 0) {
              cmtCountEl.textContent = String(paging.offset)
              console.log('[COMMENT DEBUG] fetchMore - Fixed count from 0 to', paging.offset)
            }
          }
        }
      } catch(e){
        console.error('list_comments error:', e?.message || e)
      } finally { paging.loading = false }
    }
    // ✅ FIX: Init textarea handlers (chỉ 1 lần để tránh duplicate event listeners)
    let textareaHandlersInitialized = false
    function initTextareaHandlers() {
      if (textareaHandlersInitialized || !ta) return
      textareaHandlersInitialized = true
      
      // Prevent blur events from interfering
      ta.addEventListener('mousedown', (e) => {
        e.stopPropagation()
        ta.focus()
      }, { capture: true })
      
      ta.addEventListener('click', (e) => {
        e.stopPropagation()
        ta.focus()
      }, { capture: true })
      
      // Prevent blur khi click vào các element khác trong overlay
      ta.addEventListener('blur', (e) => {
        const relatedTarget = e.relatedTarget
        if (!relatedTarget || !overlay.contains(relatedTarget)) {
          setTimeout(() => {
            if (overlay.classList.contains('open') && document.activeElement !== ta) {
              ta.focus()
            }
          }, 10)
        }
      })
    }
    
    async function openPanel(forGame){
      paging.gameId = forGame
      paging.offset = 0
      paging.loading = false
      paging.done = false
      listEl.innerHTML = ''
      ta.value = ''
      overlay.classList.add('open')
      
      // ✅ FIX: Init textarea handlers (chỉ 1 lần)
      initTextareaHandlers()
      
      // ✅ FIX: Focus vào textarea ngay sau khi mở overlay (requestAnimationFrame để đảm bảo render)
      requestAnimationFrame(() => {
        setTimeout(() => {
          if (ta && overlay.classList.contains('open')) {
            ta.focus()
            // Set cursor vào cuối textarea nếu có content
            if (ta.value) {
              ta.setSelectionRange(ta.value.length, ta.value.length)
            }
          }
        }, 100)
      })
      
      // ✅ Load comments and update count based on actual data
      await fetchMore()
      
      // ✅ FIX: Re-focus vào textarea sau khi fetchMore (tránh mất focus do re-render)
      requestAnimationFrame(() => {
        setTimeout(() => {
          if (ta && overlay.classList.contains('open') && document.activeElement !== ta) {
            ta.focus()
          }
        }, 150)
      })
      
      // Update comment count based on loaded comments
      try {
        const { data, error } = await supabase.rpc('get_social_counts', { p_game_id: forGame })
        console.log('[COMMENT DEBUG] openPanel - Refreshing counts for', forGame, ':', data)
        if (!error && data) {
          const card = document.querySelector(`.game-card[data-game-id="${forGame}"]`)
          if (card) {
            const cmtWrapper = card.querySelector('.icon-wrapper[data-role="comment"]')
            const cmtCountEl = cmtWrapper?.querySelector('.icon-count')
            if (cmtCountEl) {
              const realCount = data.comments ?? 0
              cmtCountEl.textContent = String(Math.max(0, realCount))
              console.log('[COMMENT DEBUG] openPanel - Updated count to', realCount)
            }
          }
        }
      } catch (e) {
        console.error('[COMMENT DEBUG] openPanel - Error refreshing count:', e)
      }
    }
    loadMoreBtn.onclick = fetchMore
    closeBtn.onclick = () => overlay.classList.remove('open')
    
    // ✅ FIX: Click outside to close (desktop only) - nhưng không đóng khi click vào textarea/button
    overlay.addEventListener('click', (e) => {
      // Chỉ đóng nếu click vào overlay background, không phải vào comments-box hoặc children
      if (e.target === overlay) {
        overlay.classList.remove('open')
      }
    })
    
    // ✅ FIX: Prevent overlay click từ đóng khi click vào comments-box hoặc children
    const commentsBox = overlay.querySelector('.comments-box')
    if (commentsBox) {
      commentsBox.addEventListener('click', (e) => {
        e.stopPropagation() // Ngăn event bubble lên overlay để tránh đóng
      })
    }
    
    postBtn.onclick = async () => {
      const text = (ta.value || '').trim()
      if (!text || !paging.gameId) return
      postBtn.disabled = true
      try {
        const { data, error } = await supabase.rpc('add_comment', {
      p_user_id: userId,
          p_game_id: paging.gameId,
          p_text: text
        })
        if (error) throw error
        const item = document.createElement('div')
        item.className = 'comment-item'
        const meta = document.createElement('div')
        meta.className = 'comment-meta'
        meta.textContent = `${shortAddr10(userId)} • just now`
        const body = document.createElement('div')
        body.className = 'comment-text'
        body.textContent = text
        item.appendChild(meta)
        item.appendChild(body)
        listEl.prepend(item)
        ta.value = ''
        
        // ✅ Refresh comment count after successful post!
        console.log('[COMMENT DEBUG] Comment posted! Refreshing count for', paging.gameId)
        const card = document.querySelector(`.game-card[data-game-id="${paging.gameId}"]`)
        if (card) {
          const cmtWrapper = card.querySelector('.icon-wrapper[data-role="comment"]')
          const cmtCountEl = cmtWrapper?.querySelector('.icon-count')
          if (cmtCountEl) {
            const currentCount = parseInt(cmtCountEl.textContent) || 0
            cmtCountEl.textContent = String(currentCount + 1)
            console.log('[COMMENT DEBUG] Updated count from', currentCount, 'to', currentCount + 1)
          }
        }
      } catch(e){
        console.error('add_comment error:', e?.message || e)
      } finally { postBtn.disabled = false }
    }

    const cards = document.querySelectorAll('.game-card')
    cards.forEach(card => {
      const gameId = card.getAttribute('data-game-id') || card.id
      if (!gameId) return

      const likeWrapper = card.querySelector('.icon-wrapper[data-role="like"]')
      const commentWrapper = card.querySelector('.icon-wrapper[data-role="comment"]')
      const shareWrapper = card.querySelector('.icon-wrapper[data-role="share"]')
      const leaderboardWrapper = card.querySelector('.icon-wrapper[data-role="leaderboard"]')
      const marketcapWrapper = card.querySelector('.icon-wrapper[data-role="marketcap"]')

      const likeBtn = likeWrapper?.querySelector('button')
      const commentBtn = commentWrapper?.querySelector('button')
      const shareBtn = shareWrapper?.querySelector('button')
      const leaderboardBtn = leaderboardWrapper?.querySelector('button')
      const marketcapBtn = marketcapWrapper?.querySelector('button')

      if (!likeBtn || !commentBtn) return

      const ensureCountEl = (wrapper, selector, fallback = '0') => {
        if (!wrapper) return null
        const existing = wrapper.querySelector(selector)
        if (existing) return existing
        const span = document.createElement('span')
        span.className = 'icon-count'
        span.textContent = fallback
        wrapper.appendChild(span)
        return span
      }

      const likeCountEl = ensureCountEl(likeWrapper, '.icon-count')
      const cmtCountEl = ensureCountEl(commentWrapper, '.icon-count')

      function setCounts(likes, comments) {
        if (likeCountEl) likeCountEl.textContent = String(Math.max(0, likes|0))
        if (cmtCountEl) cmtCountEl.textContent = String(Math.max(0, comments|0))
      }
      function renderHeart(isLiked) {
        const wrapper = likeBtn.closest('.icon-wrapper')
        if (wrapper) {
          wrapper.classList.toggle('liked', !!isLiked)
          console.log(`❤️ [LIKE DEBUG] ${gameId} - renderHeart(${isLiked}) → wrapper.classList.liked = ${wrapper.classList.contains('liked')}`)
        }
        likeBtn.setAttribute('aria-pressed', isLiked ? 'true' : 'false')
        console.log(`❤️ [LIKE DEBUG] ${gameId} - renderHeart(${isLiked}) → aria-pressed = ${likeBtn.getAttribute('aria-pressed')}`)
      }
      
      // Load initial like status from localStorage and Supabase
      ;(async () => {
        try {
          // First, check localStorage
          const localLiked = localStorage.getItem('mp_like_' + gameId) === '1'
          console.log(`❤️ [LIKE DEBUG] ${gameId} - Initial load: localStorage = ${localLiked}`)
          
          // Then, sync with Supabase to get accurate counts
          const { data, error } = await supabase.rpc('get_social_counts', { p_game_id: gameId })
          console.log(`❤️ [LIKE DEBUG] ${gameId} - get_social_counts RPC response:`, { data, error })
          
          if (!error && data) {
            console.log(`❤️ [LIKE DEBUG] ${gameId} - Setting counts:`, { likes: data.likes ?? 0, comments: data.comments ?? 0 })
            setCounts(data.likes ?? 0, data.comments ?? 0)
          }
          
          // Render based on localStorage (will be synced with Supabase on first click)
          // Note: We don't check Supabase here to avoid unnecessary API calls
          // The first click will sync localStorage with Supabase
          renderHeart(localLiked)
        } catch (e) {
          console.error(`❤️ [LIKE DEBUG] ${gameId} - Error loading initial state:`, e)
          // Fallback to localStorage
          const localLiked = localStorage.getItem('mp_like_' + gameId) === '1'
          renderHeart(localLiked)
        }
      })()
      
      likeBtn.addEventListener('click', async () => {
        const beforeState = localStorage.getItem('mp_like_' + gameId) === '1'
        console.log(`❤️ [LIKE DEBUG] ${gameId} - LIKE BUTTON CLICKED!`)
        console.log(`   → Before: localStorage = ${beforeState}, userId = ${userId}`)
        
        likeBtn.disabled = true
        
        try {
          console.log(`   → Calling toggle_like RPC...`)
          const { data, error } = await supabase.rpc('toggle_like', {
            p_user_id: userId,
            p_game_id: gameId
          })
          
          console.log(`   → RPC Response:`, { data, error })
          
          if (error) {
            console.error(`   ❌ RPC Error:`, error)
            throw error
          }
          
          const isLiked = !!(data && (data.is_liked ?? data.liked))
          const totalLikes = (data && (data.total_likes ?? data.likes)) ?? 0
          
          console.log(`   → Parsed: isLiked = ${isLiked}, totalLikes = ${totalLikes}`)
          
          // Update localStorage
          localStorage.setItem('mp_like_' + gameId, isLiked ? '1' : '0')
          console.log(`   → Updated localStorage: mp_like_${gameId} = ${isLiked ? '1' : '0'}`)
          
          // Update UI
          renderHeart(isLiked)
          console.log(`   → UI updated: renderHeart(${isLiked})`)
          
          // Update like count
          if (totalLikes != null) {
            const currentComments = cmtCountEl ? Number(cmtCountEl.textContent) || 0 : 0
            setCounts(totalLikes, currentComments)
            console.log(`   → Updated counts: likes = ${totalLikes}, comments = ${currentComments}`)
          }
          
          // Only reload game list if user is currently viewing "Liked" filter
          // This prevents auto-switching to "Liked" filter when user likes a game
          if (currentFilter === 'Liked') {
            console.log(`   → User is viewing "Liked" filter - reloading list...`)
            setTimeout(() => {
              if (typeof window.applyGameFilter === 'function') {
                window.applyGameFilter('Liked')
              }
            }, 200)
          } else {
            console.log(`   → User is viewing "${currentFilter}" filter - keeping current view`)
          }
          
          console.log(`   ✅ Like toggle completed successfully!`)
        } catch (e) {
          console.error(`   ❌ toggle_like error:`, e?.message || e)
          console.error(`   → Stack:`, e?.stack)
        } finally {
          likeBtn.disabled = false
          console.log(`   → Button re-enabled`)
        }
      })
      commentBtn.addEventListener('click', () => openPanel(gameId))
      // Market cap click handler is set by updateMC() function
      // Don't add handler here to avoid conflicts
      if (marketcapBtn) {
        // Handler will be set when MC is loaded via updateMC()
        console.log('Market Cap button found for', gameId)
      }
      if (shareBtn) {
        shareBtn.addEventListener('click', () => {
          openShareOverlay(gameId)
        })
      }
      if (leaderboardBtn) {
        leaderboardBtn.addEventListener('click', () => {
          if (typeof window.__openLeaderboardOverlay === 'function') {
            window.__openLeaderboardOverlay(gameId)
          }
        })
      }
    })
  }
  // ❌ REMOVED: initSocialHandlers() - Already called in DOMContentLoaded (line 1555)
  // This was causing duplicate event listeners → like button flickering!

  // Listen for game scores via postMessage
  // Handle TOGGLE_FOCUS_MODE message from iframe (pixel-space-shooter)
  window.addEventListener('message', (event) => {
    if (event.data?.type === 'TOGGLE_FOCUS_MODE') {
      const { gameId } = event.data;
      console.log('📥 Received TOGGLE_FOCUS_MODE from iframe:', gameId);
      
      // Set active game
      if (gameId) {
        try { window.__memeplayActiveGame = gameId } catch {}
        focusState.gameId = gameId;
        const card = document.querySelector(`[data-game-id="${gameId}"]`) || document.getElementById(gameId);
        if (card) {
          applyFocusActiveCard(gameId);
        }
      }
      
      // Toggle focus mode
      toggleFocusMode();
      
      // Send FOCUS_MODE_CHANGED back to iframe
      // ✅ FIX: Hỗ trợ cả pixel-space-shooter và Pacman games
      const iframes = document.querySelectorAll('iframe[data-game-url*="pixel-space-shooter"], iframe[data-game-url*="pacman"]');
      iframes.forEach(iframe => {
        if (iframe.contentWindow) {
          iframe.contentWindow.postMessage({
            type: 'FOCUS_MODE_CHANGED',
            isFocus: document.body.classList.contains('focus-mode')
          }, '*');
        }
      });
    }
  });
  
  // Legacy games (hosted on Lovable, sử dụng protocol cũ)
  const LEGACY_GAME_IDS = new Set([
    'bird-squash',      // Game 1
    'inverse-cramer',   // Jim Cramer
    'moonshot-bnb'      // Game 2
  ]);

  function isLegacyGame(gameId) {
    return !!gameId && LEGACY_GAME_IDS.has(gameId);
  }

  window.addEventListener('message', async (event) => {
    // ✅ FIX: Only log messages that have type and gameId (filter out noise from extensions)
    const msgType = event.data?.type
    const msgGameId = event.data?.gameId
    // Only log if message has meaningful data (filter out undefined/extension messages)
    if (msgType && msgGameId) {
      console.log('📨 [DEBUG] Parent received:', msgType, 'from', msgGameId, '| Origin:', event.origin);
    }
    
    // ✅ ONLY sync activeGame when game is ACTUALLY PLAYING (GAME_SCORE only!)
    // ❌ DON'T sync with GAME_START/RESTART (may send automatically on iframe load)
    // ❌ DON'T sync with other messages (init, ready, etc.)
    if (event.data?.gameId && event.data?.type === 'GAME_SCORE') {
      const messageGameId = event.data.gameId
      
      if (activeGame !== messageGameId) {
        console.log('🔄 Syncing activeGame:', activeGame, '→', messageGameId)
        activeGame = messageGameId
      }
    }
    
    // Handle GAME_START message (start timer when user actually plays)
    if (event.data?.type === 'GAME_START' && event.data?.gameId) {
      const { gameId } = event.data;
      console.log('🎮 [TIMER DEBUG] GAME_START received:', { gameId, origin: event.origin });
      
      // Only start timer if not already running for this game
      if (!activeStartTime || (activeGame && activeGame !== gameId)) {
        // Stop previous game if different
        if (activeGame && activeGame !== gameId) {
          console.log('   ⏹️ Stopping previous game:', activeGame);
          await stopGame();
        }
        
        console.log('   ▶️ Starting timer for', gameId);
        startGame(gameId);
      } else if (activeGame === gameId) {
        console.log('   ℹ️ Timer already running for', gameId);
      }
    }
    
    if (event.data?.type === 'GAME_SCORE') {
      const { gameId, score, level } = event.data
      console.log('🎮 [TIMER DEBUG] GAME_SCORE received:', { gameId, score, origin: event.origin })
      
      // ✅ Clear fallback timer when receiving GAME_SCORE (game handles itself!)
      if (window.fallbackTimers && window.fallbackTimers[gameId]) {
        clearTimeout(window.fallbackTimers[gameId])
        delete window.fallbackTimers[gameId]
        console.log('🔄 [FALLBACK] Cleared fallback timer for', gameId, '(game sends GAME_SCORE)')
      }
      
      if (!gameId) {
        console.log('❌ [TIMER DEBUG] No gameId in message!')
        return
      }
      
      // Convert to integer (round down for fairness)
      const finalScore = Math.floor(Number(score))
      console.log('🎮 [TIMER DEBUG] Processing game:', gameId, 'score:', finalScore)
      
      // ✅ ALWAYS submit score first, then process timer logic
      // ✅ Ensure score is sent to leaderboard even if "Play Again" is detected
      console.log(`📊 Received score: ${score} → ${finalScore} for ${gameId}`)
      
      // Submit score immediately (don't wait for timer logic)
      try {
        const payload = {
          p_user_id: userId,
          p_game_id: gameId,
          p_score: finalScore
        }
        if (Number.isFinite(Number(level))) {
          payload.p_level = Math.max(1, Math.trunc(Number(level)))
        } else {
          payload.p_level = 1
        }

        console.log('📤 [SCORE] Submitting score immediately (keepalive):', payload)
        const { data, error } = await rpcWithKeepalive('submit_game_score', payload)
        
        if (error) {
          console.error('❌ [SCORE] RPC error:', error)
          // Không throw để không block game flow, nhưng log để debug
          console.warn('⚠️ [SCORE] Score submission failed. Make sure SQL function submit_game_score exists in Supabase.')
          return
        }
        
        // Supabase RPC có thể return array hoặc object
        let result = data
        if (Array.isArray(data)) {
          result = data.length > 0 ? data[0] : null
        }
        
        console.log('📊 [SCORE] RPC response:', { raw: data, parsed: result })
        
        if (!result || typeof result !== 'object') {
          console.error('❌ [SCORE] Invalid response format:', result)
          console.warn('⚠️ [SCORE] SQL function submit_game_score may not exist. Run LEADERBOARD-SQL.sql in Supabase.')
          return
        }
        
        // Verify required fields
        if (result.best_score === undefined || result.user_rank === undefined) {
          console.warn('⚠️ [SCORE] Response missing fields:', result)
          console.warn('⚠️ [SCORE] Expected: { is_new_best, user_rank, total_players, best_score }')
        }
        
        if (result.is_new_best) {
          console.log(`🏆 New high score! Rank #${result.user_rank}/${result.total_players || 'N/A'}`)
          // TODO: Show toast/animation "New Best!"
        } else {
          console.log(`✓ Score submitted. Best: ${result.best_score || 'N/A'}, Rank: #${result.user_rank || 'N/A'}`)
        }
      } catch (err) {
        console.error('❌ [SCORE] Submit score error:', err)
      }

      // Ensure a play is counted even if timer didn't start properly.
      // Chỉ chạy safeguard khi timer KHÔNG chạy (ví dụ fallback hoặc iframe không gửi GAME_START).
      // Nếu timer đang chạy bình thường, stopGame() sẽ tự increment → tránh double-count.
      const timerRunningForGame = activeGame === gameId && !!activeStartTime;
      if (!isLegacyGame(gameId)) {
        if (timerRunningForGame) {
          console.log('⏭️ [PLAYS SAFEGUARD] Skip for', gameId, '- timer đã chạy, stopGame sẽ cộng.');
        } else {
          console.log('⏱ [PLAYS SAFEGUARD] GAME_SCORE đến khi chưa start timer (game hiện đại) → bỏ qua để tránh double-count.');
        }
      } else if (!timerRunningForGame) {
        try {
          // Legacy fallback: game không gửi GAME_START nên ép cộng tối thiểu 3s
          const sgPayload = {
            p_user_id: userId,
            p_game_id: gameId,
            p_seconds: 3
          };
          console.log('📈 [PLAYS] increment_play_count (legacy safeguard) →', sgPayload);
          const { data: incData, error: incErr } = await rpcWithKeepalive('increment_play_count', sgPayload)
          if (incErr) {
            console.warn('⏱ [PLAYS SAFEGUARD] increment_play_count failed:', incErr.message)
          } else if (incData && typeof incData.total_plays === 'number') {
            setPlaysLabelForCard(gameId, incData.total_plays)
            console.log(`📊 [plays safeguard +1] ${gameId}:`, incData.total_plays)
          }
        } catch (e) {
          console.warn('⏱ [PLAYS SAFEGUARD] error:', e?.message || e)
          try { await loadPlayCount(gameId) } catch {}
        }
      } else if (timerRunningForGame) {
        console.log('⏭️ [PLAYS SAFEGUARD] Skip for', gameId, '- timer already running (stopGame handles increment)');
      }
      
      // LEGACY GAMES (Lovable): Always treat GAME_SCORE as full session end (old behavior)
      if (isLegacyGame(gameId)) {
        console.log('🕒 [LEGACY] Handling GAME_SCORE with legacy flow for', gameId);
      
        // Nếu timer chưa chạy hoặc đang chạy cho game khác, backfill start time tối thiểu
        if (!activeGame || activeGame !== gameId || !activeStartTime) {
          activeGame = gameId;
          // Backdate 5s để đảm bảo có thời gian >0 cho reward (increment_play_count dùng 3s cố định)
          activeStartTime = Date.now() - 5000;
          console.log('🕒 [LEGACY] Backfilled start time for', gameId, 'at', new Date(activeStartTime).toISOString());
        }
      
        // Dừng game ngay để finalize playtime + achievements như cũ
        try {
          await stopGame();
          console.log('✅ [LEGACY] stopGame() completed for', gameId);
        } catch (e) {
          console.error('❌ [LEGACY] stopGame error for', gameId, e);
        }
        // Không return; tiếp tục xuống logic GAME OVER chung để nổ toast giữa màn hình
      }
      
      // DETECT PLAY AGAIN: chỉ áp dụng cho game mới, không áp dụng cho legacy games
      if (!isLegacyGame(gameId)) {
        const hasScore = score > 0  // Score > 0 = game is being played
        const timerNotRunningForThisGame = !activeStartTime || (activeGame && activeGame !== gameId)
        
        const isPlayAgain = hasScore && timerNotRunningForThisGame && finalScore < 15  // ✅ Only detect Play Again if score < 15
        console.log('🎮 [TIMER DEBUG] isPlayAgain check:', { hasScore, timerNotRunningForThisGame, activeStartTime, activeGame, isPlayAgain })
        
        if (isPlayAgain) {
          console.log('🔄 [TIMER DEBUG] ✅ Play Again detected! Starting timer for:', gameId)
          
          // Stop previous session if exists (different game)
          if (activeGame && activeStartTime && activeGame !== gameId) {
            console.log('   ⏹️ Stopping previous game session:', activeGame)
            await stopGame()
          }
          
          console.log('   ▶️ Starting timer for', gameId)
          startGame(gameId)
          // Return early, wait for higher score to process game over
          return
        }
      }
      
      // HIGH SCORE = GAME OVER
      console.log('🎮 Game Over detected! Stopping game to finalize achievements...')
      
      // Set flag to allow showing achievements (ONLY after game over)
      isGameOver = true
      
      // Stop game = finalize playtime + queue any remaining achievements
      if (activeGame === gameId || activeGame) {
        console.log('   ⏹️ Calling stopGame() to finalize playtime...')
        await stopGame()
        console.log('   ✅ stopGame() completed - achievements finalized!')
      }
      
      // NOW check pending achievements (after stopGame finalized them)
      console.log('   🔍 Checking pending achievements...')
      console.log('   🔑 gameId from GAME_SCORE message:', gameId)
      console.log('   📦 pendingAchievements:', pendingAchievements)
      console.log('   📦 Keys in pending:', Object.keys(pendingAchievements))
      
      // Try BOTH gameId and any pending
      const achievementsToShow = pendingAchievements[gameId] || pendingAchievements[Object.keys(pendingAchievements)[0]]
      
      if (achievementsToShow && achievementsToShow.length > 0) {
        const keyUsed = pendingAchievements[gameId] ? gameId : Object.keys(pendingAchievements)[0]
        console.log('   ✅ Found', achievementsToShow.length, 'achievement(s) under key:', keyUsed)
        // Wait 1s after game over, then show achievements
        setTimeout(() => {
          console.log('   🎉 NOW showing achievements (isGameOver=true)...')
          showPendingAchievements(keyUsed)
        }, 1000)
      } else {
        console.log('   ❌ NO pending achievements found after stopGame!')
        // Reset flag if no achievements to show
        isGameOver = false
      }
    }
  })

  // Format count helper (1K, 10.5K, 1.2M)
  function formatCount(num) {
    const n = Number(num) || 0
    if (n >= 1000000) return (n / 1000000).toFixed(1).replace(/\.0$/, '') + 'M'
    if (n >= 1000) return (n / 1000).toFixed(1).replace(/\.0$/, '') + 'K'
    return String(n)
  }

  function shortAddrLeaderboard(addr) {
    if (!addr || addr.length <= 10) return addr || 'Anonymous'
    return addr.slice(0, 6) + '…' + addr.slice(-4)
  }

  // Format score based on game type
  function formatScore(score, gameId) {
    const num = Number(score) || 0;
    
    // Wojak game shows percentage
    if (gameId === 'wojak-btc-blast') {
      return num + '%';
    }
    
    // Other games use normal format (1K, 1M...)
    return formatCount(num);
  }

  function setLeaderboardActivePanel(panel) {
    const overlay = document.getElementById('leaderboardOverlay')
    if (!overlay) return
    const tabs = overlay.querySelectorAll('.leaderboard-tab')
    const scoresPanel = document.getElementById('leaderboardPanelScores')
    const rewardsPanel = document.getElementById('leaderboardPanelRewards')

    const target = panel === 'rewards' ? 'rewards' : 'scores'
    tabs.forEach(btn => {
      const isActive = btn.dataset.panel === target
      btn.classList.toggle('active', isActive)
    })
    scoresPanel?.classList.toggle('active', target === 'scores')
    rewardsPanel?.classList.toggle('active', target === 'rewards')
    overlay.dataset.activePanel = target
  }

  function renderRewardsPanel(gameId) {
    const summaryEl = document.getElementById('leaderboardRewardSummary')
    const listEl = document.getElementById('leaderboardRewardList')
    if (!summaryEl || !listEl) return

    const awardedMap = getGameAwards(gameId)
    const totalSeconds = getGameSeconds(gameId)
    const achievements = [
      { threshold: 10, name: '10s Play Reward', reward: 100 },
      { threshold: 60, name: 'Engaged', reward: 300 },
      { threshold: 300, name: 'Champion', reward: 1000 }
    ]

    const progress = Math.min(100, (totalSeconds / 300) * 100)
    summaryEl.innerHTML = `
      <div style="font-size:18px;">Total Playtime</div>
      <div class="reward-total">${totalSeconds}s / 300s</div>
      <div class="leaderboard-reward-progress"><span style="width:${progress}%"></span></div>
      <div style="margin-top:6px;font-size:13px;color:#a9b1c4;">Play more to unlock bonus PLAY rewards</div>
    `

    listEl.innerHTML = ''
    achievements.forEach(ach => {
      const unlocked = awardedMap[ach.threshold] || totalSeconds >= ach.threshold
      const secondsLeft = Math.max(0, ach.threshold - totalSeconds)
      const card = document.createElement('div')
      card.className = 'leaderboard-reward-card' + (unlocked ? ' unlocked' : '')
      card.innerHTML = `
        <div style="flex:1;">
          <div class="reward-name">${unlocked ? '✅' : '🔒'} ${ach.name}</div>
          <div class="reward-status">${unlocked ? 'Unlocked!' : `${secondsLeft}s remaining`}</div>
        </div>
        <div class="reward-amount">+${ach.reward}</div>
      `
      listEl.appendChild(card)
    })
  }

  async function openLeaderboardOverlay(gameId) {
    const overlay = document.getElementById('leaderboardOverlay')
    const list = document.getElementById('leaderboardList')
    const rewardSummary = document.getElementById('leaderboardRewardSummary')
    const rewardList = document.getElementById('leaderboardRewardList')
    if (!overlay || !list || !rewardSummary || !rewardList) return

    overlay.dataset.gameId = gameId
    setLeaderboardActivePanel('scores')
    renderRewardsPanel(gameId)

    list.innerHTML = '<div style="padding:24px;text-align:center;color:#bbb;">Loading...</div>'
    overlay.classList.add('open')

    try {
      const { data, error } = await supabase.rpc('get_game_leaderboard_with_user', {
        p_game_id: gameId,
        p_user_id: userId,
        p_limit: 100
      })

      if (error) {
        console.error('❌ [LEADERBOARD] RPC error:', error)
        list.innerHTML = '<div style="padding:24px;text-align:center;color:#f88;">Failed to load leaderboard. Make sure SQL function get_game_leaderboard_with_user exists in Supabase.</div>'
        return
      }

      console.log('📊 [LEADERBOARD] RPC response:', data)

      list.innerHTML = ''

      // Supabase RPC có thể return array hoặc object
      let result = data
      if (Array.isArray(data)) {
        result = data.length > 0 ? data[0] : null
      }
      
      if (!result || typeof result !== 'object') {
        console.error('❌ [LEADERBOARD] Invalid response format:', result)
        console.warn('⚠️ [LEADERBOARD] SQL function get_game_leaderboard_with_user may not exist. Run LEADERBOARD-SQL.sql in Supabase.')
        list.innerHTML = '<div style="padding:24px;text-align:center;color:#f88;">Failed to load leaderboard (invalid response). Run LEADERBOARD-SQL.sql in Supabase.</div>'
        return
      }

      // Parse current_user (có thể là JSON string hoặc object)
      let userEntry = null
      if (result.current_user) {
        if (typeof result.current_user === 'string') {
          try {
            userEntry = result.current_user === 'null' ? null : JSON.parse(result.current_user)
          } catch {
            userEntry = null
          }
        } else if (typeof result.current_user === 'object') {
          userEntry = result.current_user
        }
      }
      if (userEntry) {
        const userItem = document.createElement('div')
        userItem.className = 'leaderboard-item user-highlight'
        userItem.innerHTML = `
          <div class="leaderboard-rank">${userEntry.rank ? '#' + userEntry.rank : '-'}</div>
          <div class="leaderboard-user">You</div>
          <div class="leaderboard-score">${formatScore(userEntry.best_score, gameId)}</div>
        `
        list.appendChild(userItem)
      }

      const divider = document.createElement('div')
      divider.className = 'leaderboard-divider'
      divider.textContent = 'Top 100 Players'
      list.appendChild(divider)

      // Parse top_players (có thể là JSON string hoặc array)
      let topPlayers = []
      if (result.top_players) {
        if (Array.isArray(result.top_players)) {
          topPlayers = result.top_players
        } else if (typeof result.top_players === 'string') {
          try {
            topPlayers = JSON.parse(result.top_players) || []
          } catch {
            topPlayers = []
          }
        }
      }
      if (topPlayers.length === 0) {
        const empty = document.createElement('div')
        empty.style.cssText = 'padding:24px;text-align:center;color:#888;'
        empty.textContent = 'No scores yet. Be the first!'
        list.appendChild(empty)
        return
      }

      topPlayers.forEach(player => {
        const item = document.createElement('div')
        item.className = 'leaderboard-item'
        if (player.user_id === userId) {
          item.classList.add('is-current-user')
        }

        let rankDisplay = `#${player.rank}`
        if (player.rank === 1) rankDisplay = '🥇'
        else if (player.rank === 2) rankDisplay = '🥈'
        else if (player.rank === 3) rankDisplay = '🥉'

        item.innerHTML = `
          <div class="leaderboard-rank">${rankDisplay}</div>
          <div class="leaderboard-user">${shortAddrLeaderboard(player.user_id)}</div>
          <div class="leaderboard-score">${formatScore(player.best_score, gameId)}</div>
        `
        list.appendChild(item)
      })
    } catch (err) {
      console.error('Leaderboard error:', err)
      list.innerHTML = '<div style="padding:24px;text-align:center;color:#f88;">Failed to load leaderboard</div>'
    }
  }

  ;(function initLeaderboardOverlay(){
    const overlay = document.getElementById('leaderboardOverlay')
    if (!overlay) return
    const closeBtn = document.getElementById('leaderboardCloseBtn')
    const tabButtons = overlay.querySelectorAll('.leaderboard-tab')

    if (!overlay.dataset.activePanel) overlay.dataset.activePanel = 'scores'

    function closeLeaderboardOverlay() {
      overlay.classList.remove('open')
    }

    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const panel = btn.dataset.panel
        if (panel) setLeaderboardActivePanel(panel)
      })
    })

    closeBtn?.addEventListener('click', closeLeaderboardOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeLeaderboardOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeLeaderboardOverlay()
    })

    window.__openLeaderboardOverlay = openLeaderboardOverlay
    window.__closeLeaderboardOverlay = closeLeaderboardOverlay
  })()

  // Share Modal Logic
  let currentShareGameId = null
  
  function openShareOverlay(gameId) {
    currentShareGameId = gameId
    const overlay = document.getElementById('shareOverlay')
    if (overlay) overlay.classList.add('open')
  }

  // Build correct share URL based on game type
  function buildShareUrl(gameId) {
    if (!gameId) return `${window.location.origin}/`
    
    // Pacman games use ?game= parameter, other games use hash navigation
    if (gameId.startsWith('pacman-')) {
      return `${window.location.origin}/?game=${gameId}`
    }
    
    // All other games use hash navigation
    // This ensures consistent behavior: /#brick-fallen-crypto
    return `${window.location.origin}/#${gameId}`
  }

  ;(function initShareOverlay(){
    const overlay = document.getElementById('shareOverlay')
    if (!overlay) return
    
    const closeBtn = document.getElementById('shareCloseBtn')
    const copyBtn = document.getElementById('shareCopyBtn')
    const telegramBtn = document.getElementById('shareTelegramBtn')
    const xBtn = document.getElementById('shareXBtn')

    function closeShareOverlay() {
      overlay.classList.remove('open')
    }

    // Close handlers
    closeBtn?.addEventListener('click', closeShareOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeShareOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeShareOverlay()
    })

    // Copy Link Button
    copyBtn?.addEventListener('click', async () => {
      const shareUrl = buildShareUrl(currentShareGameId)
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(shareUrl)
          const originalHTML = copyBtn.innerHTML
          copyBtn.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            <span>✓ Copied!</span>
          `
          setTimeout(() => {
            copyBtn.innerHTML = originalHTML
          }, 2000)
        }
      } catch (err) {
        console.error('Copy failed:', err)
      }
    })

    // Telegram Button
    telegramBtn?.addEventListener('click', () => {
      const shareUrl = buildShareUrl(currentShareGameId)
      const text = `🎮 Check out this awesome game on MemePlay Arcade! Play and earn PLAY points! 🚀`
      const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(text)}`
      window.open(telegramUrl, '_blank')
      closeShareOverlay()
    })

    // X/Twitter Button
    xBtn?.addEventListener('click', () => {
      const shareUrl = buildShareUrl(currentShareGameId)
      const text = `🎮 Just played an awesome game on MemePlay! Play & earn PLAY points! 🚀`
      const xUrl = `https://twitter.com/intent/tweet?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(text)}`
      window.open(xUrl, '_blank')
      closeShareOverlay()
    })
  })()

  ;(function initStatsOverlay(){
    const overlay = document.getElementById('statsOverlay')
    if (!overlay) return
    const closeBtn = document.getElementById('statsCloseBtn')
    const streakEl = document.getElementById('statsStreak')
    const playsEl = document.getElementById('statsPlays')

    function updateStatsOverlay() {
      const streakSource = document.getElementById('streakCount')
      const playsSource = document.getElementById('headerEarned')
      if (streakSource) streakEl.textContent = streakSource.textContent || '0'
      if (playsSource) playsEl.textContent = playsSource.textContent || '0'
    }

    function openStatsOverlay() {
      updateStatsOverlay()
      overlay.classList.add('open')
    }

    function closeStatsOverlay() {
      overlay.classList.remove('open')
    }

    closeBtn?.addEventListener('click', closeStatsOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeStatsOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeStatsOverlay()
    })

    window.__openStatsOverlay = openStatsOverlay
    window.__updateStatsOverlay = updateStatsOverlay
  })()
 
   
  </script>

  <!-- Global helpers shim (non-module) to guarantee console access -->
  <script>
    (function installMemeplayShim(){
      function lsGetInt(key){
        const raw = localStorage.getItem(key);
        const num = raw == null ? NaN : Number(raw);
        return Number.isFinite(num) ? num : 0;
      }
      function getIds(){
        return Array.from(document.querySelectorAll('.game-card')).map(c => c.getAttribute('data-game-id') || c.id || 'unknown');
      }
      const shim = {
        getGameSeconds: function(gameId){ return lsGetInt('mp_game_seconds_' + gameId); },
        listAllGameSeconds: function(){
          const rows = getIds().map(id => ({ gameId: id, seconds: lsGetInt('mp_game_seconds_' + id) }));
          try { console.table(rows); } catch {}
          return rows;
        },
        resetGameProgress: function(gameId){
          if (!gameId) return false;
          localStorage.setItem('mp_game_seconds_' + gameId, '0');
          localStorage.removeItem('mp_game_awards_' + gameId);
          console.log('🔄 Reset progress for', gameId);
          return true;
        },
        startGame: function(gameId){
          try { if (window.memeplay && window.memeplay.startGame) return window.memeplay.startGame(gameId); } catch {}
          console.warn('startGame bridge: module not ready');
        },
        stopGame: function(){
          try { if (window.memeplay && window.memeplay.stopGame) return window.memeplay.stopGame(); } catch {}
          console.warn('stopGame bridge: module not ready');
        }
      };
      try { window.memeplay = Object.assign({}, shim, window.memeplay || {}); } catch {}
      try { self.memeplay = window.memeplay; } catch {}
      try { globalThis.memeplay = window.memeplay; } catch {}
      console.log('🧩 memeplay console shim ready');
    })();
  </script>

  <!-- Desktop scroll: Redirect scroll from full page into .game-container with scroll-snap -->
  <script>
    (function enableDesktopScroll(){
      const gameContainer = document.querySelector('.game-container');
      if (!gameContainer) return;
      
      // Redirect wheel events from document into .game-container
      let scrollLock = false;
      function scheduleSnap() {
            clearTimeout(gameContainer._snapTimeout);
        gameContainer._snapTimeout = setTimeout(runSnapToNearestCard, 350);
      }
      
      function runSnapToNearestCard() {
              const cards = Array.from(document.querySelectorAll('.game-card'));
              if (!cards.length) return;
              
              const containerTop = gameContainer.scrollTop;
              const containerHeight = gameContainer.clientHeight;
              const viewportCenter = containerTop + containerHeight / 2;
              
              let bestCard = null;
              let bestDistance = Infinity;
              
              cards.forEach(card => {
                const cardTop = card.offsetTop - gameContainer.offsetTop;
                const cardHeight = card.offsetHeight;
                const cardCenter = cardTop + cardHeight / 2;
                const distance = Math.abs(cardCenter - viewportCenter);
                
                if (distance < bestDistance) {
                  bestDistance = distance;
                  bestCard = card;
                }
              });
              
              // ✅ FIX #4: Check nếu đang scroll TỪ Pacman sang game khác - không snap
              // Nhưng vẫn cho phép snap VÀO Pacman (bestCard là Pacman) để game không bị đẩy ra
              if (bestCard) {
                const bestCardId = bestCard.id || bestCard.getAttribute('data-game-id') || ''
                const bestCardIsPacman = bestCardId.startsWith('pacman-') || bestCardId === 'pacman-memeplay'
                
                const currentActiveCard = document.querySelector('.game-card[id="' + (window.__memeplayActiveGame || currentActiveGame || '') + '"]') ||
                                          document.querySelector('.game-card[data-game-id="' + (window.__memeplayActiveGame || currentActiveGame || '') + '"]')
                const currentActiveGameId = currentActiveCard?.id || currentActiveCard?.getAttribute('data-game-id') || ''
                const isCurrentActivePacman = currentActiveGameId && (
                  currentActiveGameId.startsWith('pacman-') || 
                  currentActiveGameId === 'pacman-memeplay'
                )
                
                // Chỉ skip snap nếu: (1) current active là Pacman VÀ (2) bestCard KHÔNG phải Pacman
                // Điều này cho phép snap VÀO Pacman nhưng không snap TỪ Pacman ra
                if (isCurrentActivePacman && !bestCardIsPacman) {
                  gameContainer.classList.remove('is-scrolling');
                  return;
                }
              }
              
        if (bestCard && bestDistance > containerHeight * 0.25) {
                const cardTop = bestCard.offsetTop - gameContainer.offsetTop;
                const cardHeight = bestCard.offsetHeight;
                const cardCenter = cardTop + cardHeight / 2;
          const targetScroll = Math.max(0, cardCenter - containerHeight / 2);
          gameContainer.classList.remove('is-scrolling');
          gameContainer.style.scrollBehavior = 'smooth';
                gameContainer.scrollTo({
                  top: targetScroll,
                  behavior: 'smooth'
                });
        } else {
          gameContainer.classList.remove('is-scrolling');
        }
      }
      
      document.addEventListener('wheel', (e) => {
        // Only handle vertical scroll
        if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
          const target = e.target;
          // Check if click is inside .game-container
          const isInGameContainer = gameContainer.contains(target) || 
                                    target.closest('.game-card') ||
                                    target.closest('.game-container') ||
                                    target.closest('.main-header');
          
          // ✅ FIX: Check if current active game is Pacman
          const currentActiveCard = document.querySelector('.game-card[id="' + (window.__memeplayActiveGame || currentActiveGame || '') + '"]') ||
                                    document.querySelector('.game-card[data-game-id="' + (window.__memeplayActiveGame || currentActiveGame || '') + '"]')
          const currentActiveGameId = currentActiveCard?.id || currentActiveCard?.getAttribute('data-game-id') || ''
          const isCurrentActivePacman = currentActiveGameId && (
            currentActiveGameId.startsWith('pacman-') || 
            currentActiveGameId === 'pacman-memeplay'
          )
          
          // If click outside game-container (black area), redirect scroll into .game-container
          if (!isInGameContainer && !scrollLock) {
          e.preventDefault();
            e.stopPropagation();
            
            // ✅ FIX: Tắt scroll-snap tạm thời khi scroll từ Pacman game (cho phép scroll mượt hơn)
            if (isCurrentActivePacman) {
              gameContainer.style.scrollSnapType = 'none';
              // Bật lại sau 1.5s (đủ thời gian để scroll qua game khác)
              clearTimeout(gameContainer._scrollSnapTimeout);
              gameContainer._scrollSnapTimeout = setTimeout(() => {
                gameContainer.style.scrollSnapType = '';
              }, 1500);
            }
            
            // ✅ FIXED: Slower, smoother scroll with animation
            // Reduce scroll speed for smoother transition between games
            const scrollAmount = Math.abs(e.deltaY) * 0.4; // Reduced from 0.6 to 0.4 for smoother scroll
            const scrollDirection = e.deltaY > 0 ? 1 : -1; // Down = 1, Up = -1
            
            gameContainer.classList.add('is-scrolling');
            gameContainer.style.scrollBehavior = 'auto';
            gameContainer.scrollTop += scrollAmount * scrollDirection;
            clearTimeout(gameContainer._scrollingClassTimeout);
            gameContainer._scrollingClassTimeout = setTimeout(() => {
              gameContainer.classList.remove('is-scrolling');
            }, 600);
            
            scrollLock = true;
            setTimeout(() => { scrollLock = false; }, 120);
            
            // ✅ FIX: Không schedule snap nếu đang scroll từ Pacman game
            // Chỉ schedule snap cho non-Pacman games
            if (!isCurrentActivePacman) {
              scheduleSnap();
            }
          }
        }
      }, { passive: false });
      
    })();
  </script>

  <!-- Swipe navigation: up/down moves to next/prev game (loops) -->
  <script>
    (function swipeNavigation(){
      const sc = document.querySelector('.game-container');
      const cards = Array.from(document.querySelectorAll('.game-card'));
      if (!cards.length) return;

      let tops = [];
      function recalc(){
        tops = cards.map(el => el.offsetTop);
      }
      function currentIndex(){
        const y = sc.scrollTop + sc.clientHeight * 0.25; // focus upper quarter
        let best = 0, bestDiff = Infinity;
        for (let i=0;i<tops.length;i++){
          const d = Math.abs(tops[i]-y);
          if (d < bestDiff){ best = i; bestDiff = d; }
        }
        return best;
      }
      function scrollToIndex(i){
        const n = cards.length;
        const idx = ((i % n) + n) % n; // safe modulo
        const y = tops[idx] ?? 0;
        sc.scrollTo({ top: y, behavior: 'smooth' });
      }

      recalc();
      window.addEventListener('resize', recalc, { passive: true });
      window.addEventListener('orientationchange', recalc, { passive: true });

      let startY = 0, moved = false;
      const THRESHOLD = 60; // px - chỉ cần vuốt 60px là chuyển game

      sc.addEventListener('touchstart', (e) => {
        if (!e.touches || !e.touches.length) return;
        startY = e.touches[0].clientY; 
        moved = false;
      }, { passive: true });

      sc.addEventListener('touchmove', (e) => {
        moved = true;
      }, { passive: true });

      sc.addEventListener('touchend', (e) => {
        if (!moved) return;
        const endY = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY : startY;
        const dy = endY - startY; // down = positive
        
        // ✅ Chỉ cần vuốt 60px (lên hoặc xuống) là chuyển game
        if (Math.abs(dy) < THRESHOLD) return;

        const cur = currentIndex();
        if (dy < 0) scrollToIndex(cur + 1); // swipe up -> next game
        else scrollToIndex(cur - 1);        // swipe down -> prev game
      }, { passive: true });

      // ✅ FIXED: Longer timeout for smoother scroll animation
      // Force snap to nearest after inertial scrolling stops (prevents resting between cards)
      let snapTimer = null;
      sc.addEventListener('scroll', () => {
        if (snapTimer) clearTimeout(snapTimer);
        
        // ✅ FIX: Tăng timeout khi scroll từ Pacman (300ms → 800ms)
        // snapTimer quá ngắn → force snap về Pacman trước khi scroll animation xong
        const currentActiveCard = document.querySelector('.game-card[id="' + (window.__memeplayActiveGame || currentActiveGame || '') + '"]') ||
                                  document.querySelector('.game-card[data-game-id="' + (window.__memeplayActiveGame || currentActiveGame || '') + '"]')
        const currentActiveGameId = currentActiveCard?.id || currentActiveCard?.getAttribute('data-game-id') || ''
        const isCurrentActivePacman = currentActiveGameId && (
          currentActiveGameId.startsWith('pacman-') || 
          currentActiveGameId === 'pacman-memeplay'
        )
        
        // Nếu đang scroll từ Pacman → tăng timeout lên 800ms (để scroll animation xong)
        // Nếu không phải Pacman → giữ 300ms như cũ
        const timeout = isCurrentActivePacman ? 800 : 300;
        
        snapTimer = setTimeout(() => {
          // ✅ FIX CRITICAL: Check nếu current active game là Pacman - không force snap về nearest game
          // Điều này ngăn Pacman tự cuộn về màn hình khi đã scroll sang game khác
          const currentActiveCard2 = document.querySelector('.game-card[id="' + (window.__memeplayActiveGame || currentActiveGame || '') + '"]') ||
                                    document.querySelector('.game-card[data-game-id="' + (window.__memeplayActiveGame || currentActiveGame || '') + '"]')
          const currentActiveGameId2 = currentActiveCard2?.id || currentActiveCard2?.getAttribute('data-game-id') || ''
          const isCurrentActivePacman2 = currentActiveGameId2 && (
            currentActiveGameId2.startsWith('pacman-') || 
            currentActiveGameId2 === 'pacman-memeplay'
          )
          
          // Nếu đang scroll từ Pacman, không force snap về nearest game
          if (isCurrentActivePacman2) {
            return; // Không snap về game nào, để user scroll tự do
          }
          
          recalc();
          const idx = currentIndex();
          scrollToIndex(idx);
        }, timeout);
      }, { passive: true });
    })();
  </script>

  <script>
    ;(function initWalletOverlay(){
      const overlay = document.getElementById('walletOverlay')
      if (!overlay) return
      const closeBtn = document.getElementById('walletCloseBtn')
      const copyBtn = document.getElementById('walletCopyBtn')
      const disconnectBtn = document.getElementById('walletDisconnectBtn')
      const addressEl = document.getElementById('walletOverlayAddress')
      const streakEl = document.getElementById('walletOverlayStreak')
      const playsEl = document.getElementById('walletOverlayPlays')

      function updateWalletOverlay() {
        const api = globalThis.memeplayWallet || {}
        const address = api.getAddress?.() || ''
        addressEl.textContent = address ? address : 'Not connected'
        const streak = api.getStreak?.()
        const plays = api.getPlayPoints?.()
        streakEl.textContent = String(Number.isFinite(streak) ? streak : 0)
        playsEl.textContent = String(Number.isFinite(plays) ? plays : 0)
      }

      function openWalletOverlay() {
        updateWalletOverlay()
        overlay.classList.add('open')
      }

      function closeWalletOverlay() {
        overlay.classList.remove('open')
      }

      closeBtn?.addEventListener('click', closeWalletOverlay)
      overlay.addEventListener('click', (event) => {
        if (event.target === overlay) closeWalletOverlay()
      })
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && overlay.classList.contains('open')) closeWalletOverlay()
      })

      copyBtn?.addEventListener('click', async () => {
        const api = globalThis.memeplayWallet || {}
        const address = api.getAddress?.() || ''
        if (!address) return
        try {
          await navigator.clipboard.writeText(address)
          copyBtn.textContent = 'Copied!'
          setTimeout(() => { copyBtn.textContent = 'Copy address' }, 1500)
        } catch (err) {
          console.warn('Clipboard copy failed', err)
          copyBtn.textContent = 'Copy failed'
          setTimeout(() => { copyBtn.textContent = 'Copy address' }, 1500)
        }
      })

      disconnectBtn?.addEventListener('click', () => {
        const api = globalThis.memeplayWallet || {}
        api.disconnect?.()
        closeWalletOverlay()
      })

      window.__openWalletOverlay = openWalletOverlay
    window.__updateWalletOverlay = updateWalletOverlay
  })()

  ;(function initCreatorOverlay(){
    const overlay = document.getElementById('creatorOverlay')
    if (!overlay) return
    const closeBtn = document.getElementById('creatorCloseBtn')

    function openCreatorOverlay() {
      overlay.classList.add('open')
    }

    function closeCreatorOverlay() {
      overlay.classList.remove('open')
    }

    closeBtn?.addEventListener('click', closeCreatorOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeCreatorOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeCreatorOverlay()
    })

    window.__openCreatorOverlay = openCreatorOverlay
    window.__closeCreatorOverlay = closeCreatorOverlay
  })()

  // ==========================================
  // MARKET CAP - 4meme Integration
  // ==========================================
  setTimeout(() => {
    console.log('🚀 MC script start')
    
    if (!window.ethers) return console.error('❌ No ethers.js')
    console.log('✅ Ethers OK')
    
    // Contract addresses for each game
    // Game 1 (bird-squash) - contract address
    const GAME_CONTRACTS = {
      'bird-squash': '0xdb26dcc0cac3253a516398d60fd53e6f7c284444', // Game 1 - bird squash token
      // Add other games here as needed
      // 'wojak-btc-blast': '0x...',
      // 'moonshot-bnb': '0x...',
    }
    
    const HELPER = '0xF251F83e40a78868FcfA3FA4599Dad6494E46034'
    
    function fmt(n) {
      if (!n) return '--'
      if (n >= 1e9) return (n/1e9).toFixed(1)+'B'
      if (n >= 1e6) return (n/1e6).toFixed(1)+'M'
      if (n >= 1e3) return (n/1e3).toFixed(1)+'K'
      return n.toFixed(0)
    }
    
    // Get BNB price
    async function getBNB() {
      try {
        const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=binancecoin&vs_currencies=usd')
        const data = await res.json()
        return data.binancecoin?.usd || 600
      } catch {
        return 600
      }
    }
    
    async function update(id) {
      const btn = document.querySelector(`#${id} [data-role="marketcap"] button span`)
      if (!btn) return console.log(`[MC] No span: ${id}`)
      
      // Get contract address for this game - NO FALLBACK, must be in GAME_CONTRACTS
      const TOKEN = GAME_CONTRACTS[id]
      
      if (!TOKEN) {
        console.warn(`⚠️ [MC] No contract address configured for game: ${id}`)
        btn.textContent = '--' // Only show number, MC comes from CSS ::before
        return // Don't fetch MC if no contract configured
      }
      
      console.log(`📝 [MC] Using contract for ${id}: ${TOKEN}`)
      
      const wrap = document.querySelector(`#${id} [data-role="marketcap"] button`)
      if (!wrap) return console.log(`[MC] No button: ${id}`)
      
      btn.textContent = '...' // Only show loading number, MC comes from CSS ::before
      
      try {
        // Init provider & contract
        const p = new ethers.providers.JsonRpcProvider('https://bsc-dataseed.binance.org/')
        const h = new ethers.Contract(HELPER, ['function getTokenInfo(address) view returns (uint256,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool)'], p)
        
        // Get token info
        const info = await h.getTokenInfo(TOKEN)
        const graduated = info[11] // liquidityAdded
        
        let mc = 0
        
        if (graduated) {
          // CASE 1: Already on PancakeSwap → DexScreener
          // Market cap graduated to DexScreener
          
          const dex = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${TOKEN}`)
          const dexData = await dex.json()
          
          if (dexData.pairs && dexData.pairs.length > 0) {
            mc = dexData.pairs[0].fdv || dexData.pairs[0].marketCap || 0
            console.log(`✅ [MC] ${id}: $${fmt(mc)} (DexScreener)`)
          } else {
            throw new Error('No DEX data')
          }
          
        } else {
          // CASE 2: Bonding curve → 4meme contract
          // Market cap from bonding curve
          
          const bnb = await getBNB()
          const priceBNB = Number(info[3]) / 1e18
          const priceUSD = priceBNB * bnb
          mc = priceUSD * 1e9
          
          console.log(`✅ [MC] ${id}: $${fmt(mc)} (4meme contract)`)
        }
        
        // Update UI - Show MC value after "MC" text (from ::before)
        // Format: "MC 43.5K" (MC from CSS ::before, number from span)
        btn.textContent = fmt(mc) // Show formatted number (e.g., "43.5K")
        wrap.style.cursor = 'pointer'
        
        // Remove ALL existing click handlers by cloning and replacing
        const newWrap = wrap.cloneNode(true)
        wrap.parentNode.replaceChild(newWrap, wrap)
        
        // Update btn reference to new element after clone
        const newBtn = newWrap.querySelector('span')
        if (newBtn) {
          // Update text content on new element
          newBtn.textContent = fmt(mc)
        }
        
        // Add click handler to open 4meme link
        newWrap.addEventListener('click', (e) => {
          e.preventDefault()
          e.stopPropagation()
          console.log(`🔗 Opening 4meme link for ${id}:`, TOKEN)
          window.open(`https://four.meme/token/${TOKEN}`, '_blank', 'noopener,noreferrer')
        })
        
        newWrap.style.cursor = 'pointer'
        newWrap.title = `Market Cap: $${mc.toLocaleString()} - Click to view on 4meme`
        mcCache[id] = mc // Cache result
        
      } catch (e) {
        console.error(`❌ [MC] ${id}:`, e)
        btn.textContent = '--' // Only show number, MC comes from CSS ::before
        mcCache[id] = 'error' // Cache error to avoid retry
      }
    }
    
    // Cache to avoid refetching
    const mcCache = {}
    const mcLoading = {}
    
    // Lazy load MC when game visible AND iframe loaded
    const mcObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
          const gameId = entry.target.id
          
          // Check if iframe has loaded
          const iframe = entry.target.querySelector('iframe')
          const iframeLoaded = iframe && iframe.src && !iframe.src.includes('about:blank')
          
          if (iframeLoaded && !mcCache[gameId] && !mcLoading[gameId]) {
            // Wait 2s for game to stabilize, THEN fetch MC
            setTimeout(() => {
              mcLoading[gameId] = true
              update(gameId)
            }, 2000)
          }
        }
      })
    }, { 
      threshold: 0.5, // Increased from 0.3 → 0.5 (visible 50%)
      rootMargin: '0px' // Remove preload, only fetch when actually visible
    })
    
    // Wait 5s after page load, then start observing
    setTimeout(() => {
      // Start lazy load observer after 5s delay
      document.querySelectorAll('.game-card').forEach(card => {
        mcObserver.observe(card)
      })
    }, 5000)
    
    // Manual trigger
    window.__updateMC = () => {
      update('bird-squash')
      update('wojak-btc-blast')
      update('moonshot-bnb')
      update('valley-explorer-3d')
      update('hodl-tower-stack')
    }
  }, 5000)
  
  </script>
</body>
</html>