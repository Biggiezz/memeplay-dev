<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MemePlay Arcade</title>
  <!-- Favicon files (desktop + mobile) -->
  <link rel="icon" type="image/svg+xml" href="assets/favicon.svg?v=2">
  <link rel="shortcut icon" href="assets/favicon.svg?v=2">
  <link rel="apple-touch-icon" href="assets/favicon.svg?v=2">
  <link rel="stylesheet" href="style.css">
  <link rel="preconnect" href="https://moonshot-bnb.lovable.app" crossorigin>
  <link rel="preconnect" href="https://bird-squash-dev.lovable.app" crossorigin>
  <link rel="preconnect" href="https://wojak-btc-blast.lovable.app" crossorigin>
  <link rel="preconnect" href="https://hodl-tower-stack.lovable.app" crossorigin>
  <link rel="preconnect" href="https://hook-pull-crypto.lovable.app" crossorigin>
  <link rel="preconnect" href="https://game-detective-clone.lovable.app" crossorigin>
  <link rel="preconnect" href="https://monkey-crypto-climb.lovable.app" crossorigin>
  <link rel="preconnect" href="https://crypto-arrow1.lovable.app" crossorigin>
  <link rel="preconnect" href="https://inverse-cramer.lovable.app" crossorigin>
  <link rel="preconnect" href="https://rosebud.ai" crossorigin>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Debug console for mobile - Remove sau khi fix xong -->
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
  <style>
    :root { --header-h: 60px; }
    /* ===== HEADER (Docs link left, actions right) ===== */
    .main-header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: var(--header-h);
      background: #111;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      box-sizing: border-box;
      z-index: 9999;
      border-bottom: 2px solid #222;
    }
    .logo {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 1.4px;
      color: #ffb642;
      text-shadow: 0 0 12px rgba(255, 182, 66, 0.45);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      position: relative;
      transition: transform 0.18s ease;
    }
    .logo:hover {
      transform: translateY(-1px);
      color: #ffd678;
    }
    .header-flash {
      position: absolute;
      top: 50%;
      right: -18px;
      transform: translateY(-50%);
      font-size: 12px;
      font-weight: 600;
      color: #ffb642;
      padding: 4px 10px;
      border: 1px solid rgba(255, 182, 66, 0.35);
      border-radius: 999px;
      background: rgba(255, 182, 66, 0.12);
      box-shadow: 0 0 8px rgba(255, 182, 66, 0.35);
      opacity: 0;
      transition: opacity .18s ease;
      white-space: nowrap;
    }
    .header-actions {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .search-wrapper {
      position: relative;
    }
    .icon-button {
      width: 44px;
      height: 44px;
      border-radius: 14px;
      border: 1px solid #2a2f38;
      background: #1b1f24;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.18s ease, transform 0.18s ease;
      padding: 0;
    }
    .icon-button[hidden] {
      display: none !important;
    }
    .icon-button:hover {
      background: #273040;
      transform: translateY(-1px);
    }
    .icon-button svg.header-icon {
      width: 22px;
      height: 22px;
      stroke: #ffb642;
      fill: none;
      stroke-width: 2.1;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.18s ease;
    }
    .icon-button:hover svg.header-icon,
    .icon-button:focus-visible svg.header-icon {
      stroke: #ffd678;
    }
    .icon-button img {
      width: 22px;
      height: 22px;
    }
    .icon-button .icon-plus {
      font-size: 24px;
      font-weight: 600;
      color: #ffb642;
      line-height: 1;
      transition: color 0.18s ease;
    }
    .icon-button:hover .icon-plus {
      color: #ffd678;
    }
    .nav-dropdown {
      position: absolute;
      top: calc(100% + 12px);
      right: 0;
      width: 210px;
      background: #1a1f28;
      color: #fff;
      border-radius: 16px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.6);
      display: none;
      flex-direction: column;
      padding: 10px 0;
      z-index: 10000;
    }
    .nav-dropdown.open {
      display: flex;
      animation: fadeIn 0.18s ease;
    }
    .dropdown-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .dropdown-item {
      padding: 12px 22px;
      cursor: pointer;
      transition: background 0.18s ease;
      font-weight: 500;
      font-size: 16px;
      letter-spacing: 0.5px;
    }
    .dropdown-item:hover,
    .dropdown-item.active {
      background: #273e66;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px);}
      to { opacity: 1; transform: none;}
    }
    .wallet-connect img {
      width: 26px;
      height: 24px;
    }
    .wallet-status-button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 0 14px;
      height: 44px;
      border-radius: 14px;
      border: 1px solid #2a2f38;
      background: #1b1f24;
      color: #0ff;
      font-weight: 600;
      letter-spacing: 0.3px;
      cursor: pointer;
      transition: background 0.18s ease, transform 0.18s ease;
    }
    .wallet-status-button[hidden] {
      display: none !important;
    }
    .wallet-status-button:hover {
      background: #273040;
      transform: translateY(-1px);
    }
    .wallet-status-icon {
      width: 22px;
      height: 18px;
    }

    /* ===== PAGE LAYOUT SPACING ===== */
    body {
      margin: 0;
      padding-top: calc(var(--header-h) + env(safe-area-inset-top));
      min-height: 100svh;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      scroll-behavior: smooth;
      overflow: hidden; /* scroll inside .game-container for snap */
    }
    /* Move the game container below the header */
    .game-container {
      margin-top: 0; /* Bỏ margin để game căn giữa chính xác */
    }

    .game-card {
      position: relative;
    }
    
    /* Đảm bảo html và body cũng ẩn scrollbar */
    html {
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
    }
    html::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
    body {
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    body::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
    .allow-text-select,
    .allow-text-select * {
      user-select: text !important;
      -webkit-user-select: text !important;
      -webkit-touch-callout: default !important;
    }
    textarea,
    input,
    .comments-input,
    .comments-input * {
      user-select: text !important;
      -webkit-user-select: text !important;
      -webkit-touch-callout: default !important;
    }
    .game-container {
      height: calc(100svh - var(--header-h) - env(safe-area-inset-top));
      overflow-y: auto;
      overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
      scroll-snap-type: y mandatory;
      scroll-padding-top: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 2px 0 28px;
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
    }
    .game-container::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
    .game-card {
      width: min(calc(100vw - 8px), 720px);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      margin: 0 auto 6px;
      padding: 0 3px 6px;
      box-sizing: border-box;
      scroll-snap-align: center;
      scroll-snap-stop: always;
      contain: layout;
    }
    .game-card.is-playing {
      will-change: contents;
    }
    .game-card.is-playing .game-footer *,
    .game-card.is-playing .focus-toggle {
      transition: none !important;
      animation: none !important;
    }
    .game-card iframe {
      touch-action: pan-y;
    }
    .game-stage {
      position: relative;
      width: 100%;
      aspect-ratio: 720 / 1000;
      border-radius: 28px;
      background: linear-gradient(145deg, rgba(14,19,30,0.92), rgba(6,9,15,0.92));
      border: 1px solid rgba(40,58,90,0.35);
      overflow: hidden;
      box-shadow: 0 20px 55px rgba(0,0,0,0.6);
      user-select: none;
      -webkit-user-select: none;
      contain: layout style paint;
      content-visibility: auto;
    }
    .game-stage iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
      will-change: transform;
      transform: translateZ(0);
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      pointer-events: auto;
    }
    .focus-toggle {
      position: absolute;
      top: 14px;
      right: 14px;
      width: 44px;
      height: 44px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(6, 9, 15, 0.3);
      color: #eef4ff;
      font-size: 22px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0.32;
      transition: background 0.18s ease, transform 0.18s ease, opacity 0.18s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      user-select: none;
      -webkit-user-select: none;
    }
    .focus-toggle:hover,
    .focus-toggle:focus-visible {
      background: rgba(6, 9, 15, 0.72);
      opacity: 0.95;
      transform: translateY(-1px);
      outline: none;
    }
    .game-footer {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 4px 10px 6px;
      background: rgba(9, 14, 22, 0.94);
      border: 1px solid rgba(40,58,90,0.25);
      border-radius: 14px;
      box-shadow: 0 5px 16px rgba(0,0,0,0.35);
      color: #e3ecff;
      font-size: 9.8px;
      user-select: none;
      -webkit-user-select: none;
      text-align: center;
    }
    .game-icons {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: nowrap;
      gap: 14px;
    }
    .game-icons-left {
      display: flex;
      align-items: center;
      gap: 14px;
    }
    .game-icons-right {
      display: flex;
      align-items: center;
      gap: 14px;
    }
    .icon-wrapper {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }
    .icon-wrapper button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      border: none;
      background: none;
      padding: 0;
      cursor: pointer;
      transition: transform 0.18s ease, opacity 0.18s ease;
    }
    .icon-wrapper button:hover {
      transform: translateY(-2px);
    }
    .icon-wrapper button:focus-visible {
      outline: 2px solid rgba(255,182,66,0.45);
      outline-offset: 3px;
    }
    .icon-wrapper[data-role="marketcap"] {
      margin-right: -10px;
    }
    .icon-wrapper[data-role="marketcap"] button {
      width: auto;
      min-width: 26px;
      padding: 0;
    }
    .icon-wrapper[data-role="marketcap"] button span {
      white-space: nowrap;
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.5px;
      line-height: 1;
      color: #ffffff;
    }
    .icon-wrapper[data-role="donate"] svg {
      stroke: #ffffff;
      stroke-width: 3.5;
      width: 20px;
      height: 20px;
    }
    .icon-wrapper[data-role="donate"] .icon-count {
      color: #ffffff;
      font-weight: 700;
    }
    @media (max-width: 768px) {
      .icon-wrapper[data-role="marketcap"] {
        transform: translateX(-30px);
      }
      .icon-wrapper[data-role="marketcap"] button span {
        font-size: 8.5px;
        letter-spacing: 0.1px;
      }
      .game-footer {
        padding: 4px 14px 6px 14px !important;
        position: relative;
      }
      .creator-text {
        font-size: 8.25px !important;
        margin-left: 0px !important;
        padding-right: 36px !important;
        text-align: left !important;
        display: block !important;
        width: 100%;
      }
      .creator-text strong {
        font-size: 8.25px !important;
        font-weight: 600;
      }
      .icon-wrapper[data-role="leaderboard"] {
        position: absolute !important;
        bottom: 6px !important;
        right: 14px !important;
        transform: scale(1) !important;
      }
    }
    .icon-wrapper svg {
      width: 22px;
      height: 22px;
      stroke: #ffb642;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.18s ease, fill 0.18s ease;
    }
    .icon-wrapper:hover svg,
    .icon-wrapper:active svg {
      stroke: #ffd678;
    }
    .icon-wrapper.liked svg {
      stroke: #ffb642;
      fill: #ffb642;
    }
    .icon-count {
      color: #ffb642;
      font-size: 11px;
      font-weight: 600;
      line-height: 1;
      min-width: 20px;
      text-align: right;
    }
    .creator-text {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      color: #d4def5;
      font-size: 11px;
      letter-spacing: 0.2px;
      line-height: 1.2;
    }
    .creator-box {
      max-width: 540px;
      padding: 36px 32px;
      gap: 0;
      background: #0b0b0b;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }
    .creator-box .wallet-header {
      border-bottom: none;
      margin-bottom: 16px;
      padding-bottom: 0;
    }
    .creator-hero {
      color: #ffb642;
      font-size: 34px;
      font-weight: 700;
      line-height: 1.2;
      text-align: left;
      margin-bottom: 32px;
      border-bottom: none;
    }
    .creator-points {
      display: flex;
      flex-direction: column;
      gap: 18px;
      margin-bottom: 32px;
      color: #f3c978;
      font-size: 18px;
      line-height: 1.5;
    }
    .creator-point {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .creator-point-icon {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 2px solid #ffb642;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: 700;
    }
    .creator-cta {
      margin-top: auto;
      border: 2px solid #ffb642;
      border-radius: 16px;
      padding: 18px 24px;
      text-align: center;
      color: #ffb642;
      font-size: 22px;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      opacity: 0.45;
      transition: opacity 0.2s ease;
    }
    .creator-cta span {
      display: block;
      font-size: 14px;
      font-weight: 500;
      color: #e5c37a;
      letter-spacing: 0;
      text-transform: none;
      opacity: 0.75;
    }
    .leaderboard-box {
      max-width: 520px;
      padding: 20px 24px;
      background: #0b0b0b;
      border: 1px solid rgba(255,182,66,0.35);
    }
    .leaderboard-header {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .leaderboard-tabs {
      display: flex;
      gap: 10px;
      background: rgba(255,182,66,0.08);
      padding: 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,182,66,0.25);
    }
    .leaderboard-tab {
      background: transparent;
      border: none;
      color: #ffce7a;
      font-weight: 700;
      font-size: 16px;
      padding: 8px 18px;
      border-radius: 999px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.1s ease;
      letter-spacing: 0.5px;
    }
    .leaderboard-tab:hover {
      background: rgba(255,182,66,0.12);
      transform: scale(1.02);
    }
    .leaderboard-tab.active {
      background: rgba(255,182,66,0.35);
      color: #ffffff;
      text-shadow: 0 0 12px rgba(255,182,66,0.6);
      font-weight: 700;
    }
    .leaderboard-panels {
      margin-top: 18px;
    }
    .leaderboard-panel {
      display: none;
    }
    .leaderboard-panel.active {
      display: block;
    }
    .leaderboard-list {
      max-height: 65vh;
      overflow-y: auto;
      padding: 12px 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .leaderboard-list::-webkit-scrollbar {
      display: none;
    }
    .leaderboard-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #15191f;
      border: 1px solid rgba(255,182,66,0.15);
      border-radius: 10px;
      padding: 12px 16px;
      gap: 12px;
      transition: background 0.2s ease;
    }
    .leaderboard-item:hover {
      background: #1a1f28;
    }
    .leaderboard-item.user-highlight {
      background: linear-gradient(135deg, rgba(255,182,66,0.2), rgba(255,206,122,0.15));
      border: 2px solid #ffb642;
      margin-bottom: 12px;
    }
    .leaderboard-rank {
      font-size: 18px;
      font-weight: 700;
      color: #ffb642;
      min-width: 48px;
      text-align: center;
    }
    .leaderboard-user {
      flex: 1;
      color: #d5d9e6;
      font-size: 15px;
      font-weight: 500;
    }
    .leaderboard-score {
      font-size: 17px;
      font-weight: 700;
      color: #ffb642;
      min-width: 60px;
      text-align: right;
    }
    .leaderboard-divider {
      text-align: center;
      color: #f0c67a;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin: 20px 0 6px;
    }
    .leaderboard-reward-summary {
      text-align: center;
      color: #f0c67a;
      margin-bottom: 18px;
    }
    .leaderboard-reward-summary .reward-total {
      font-size: 30px;
      font-weight: 700;
      color: #ffb642;
      margin-top: 6px;
    }
    .leaderboard-reward-progress {
      width: 100%;
      height: 8px;
      background: rgba(255,182,66,0.2);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 12px;
    }
    .leaderboard-reward-progress span {
      display: block;
      height: 100%;
      background: #ffb642;
      transition: width 0.3s ease;
    }
    .leaderboard-reward-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .leaderboard-reward-card {
      padding: 16px 20px;
      border-radius: 12px;
      border: 1px solid rgba(60, 90, 138, 0.4);
      background: rgba(39, 62, 102, 0.3);
      display: flex;
      align-items: center;
      gap: 12px;
      transition: border 0.2s ease, background 0.2s ease;
    }
    .leaderboard-reward-card.unlocked {
      background: rgba(255, 182, 66, 0.15);
      border-color: rgba(255, 182, 66, 0.4);
    }
    .leaderboard-reward-card .reward-name {
      font-size: 18px;
      font-weight: 700;
      color: #999;
    }
    .leaderboard-reward-card.unlocked .reward-name {
      color: #ffb642;
    }
    .leaderboard-reward-card .reward-status {
      font-size: 14px;
      color: #bbb;
      margin-top: 4px;
    }
    .leaderboard-reward-card .reward-amount {
      font-size: 18px;
      font-weight: 700;
      color: #666;
    }
    .leaderboard-reward-card.unlocked .reward-amount {
      color: #ffb642;
    }
    /* Share Modal Buttons */
    .share-option-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: rgba(39, 62, 102, 0.4);
      border: 1px solid rgba(60, 90, 138, 0.5);
      border-radius: 12px;
      color: #fff;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      width: 100%;
      box-sizing: border-box;
    }
    .share-option-btn:hover {
      background: rgba(39, 62, 102, 0.7);
      border-color: rgba(60, 90, 138, 0.8);
      transform: translateY(-2px);
    }
    .share-option-btn:active {
      transform: translateY(0);
    }
    .share-option-btn svg {
      flex-shrink: 0;
    }
    .share-option-btn span {
      flex: 1;
      text-align: left;
    }
    #shareCopyBtn svg {
      stroke: #ffb642;
    }
    #shareTelegramBtn svg {
      fill: #0088cc;
    }
    #shareXBtn svg {
      fill: #fff;
    }
    /* Achievement Toast Center */
    .achievement-toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100000;
      background: linear-gradient(135deg, rgba(255, 182, 66, 0.95) 0%, rgba(255, 144, 0, 0.95) 100%);
      border: 3px solid #ffb642;
      border-radius: 20px;
      padding: 24px 32px;
      text-align: center;
      box-shadow: 0 10px 50px rgba(255, 182, 66, 0.6);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    .achievement-toast.show {
      opacity: 1;
      animation: bounceIn 0.5s ease-out;
    }
    .achievement-toast-title {
      font-size: 28px;
      font-weight: 700;
      color: #000;
      margin-bottom: 12px;
      text-shadow: 0 2px 4px rgba(255,255,255,0.3);
    }
    .achievement-toast-subtitle {
      font-size: 20px;
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
    }
    .achievement-toast-reward {
      font-size: 32px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 2px 6px rgba(0,0,0,0.5);
    }
    @keyframes bounceIn {
      0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.05); }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    /* Achievement Icon Shake */
    @keyframes shakeIcon {
      0%, 100% { transform: rotate(0deg); }
      10%, 30%, 50%, 70%, 90% { transform: rotate(-15deg); }
      20%, 40%, 60%, 80% { transform: rotate(15deg); }
    }
    .icon-wrapper[data-role="leaderboard"].shake {
      animation: shakeIcon 0.8s ease-in-out;
    }
    .icon-wrapper[data-role="leaderboard"] svg {
      transform: scale(1); /* Bằng kích thước trái tim */
    }
    .icon-wrapper[data-role="leaderboard"].shake svg {
      fill: #ffb642;
      filter: drop-shadow(0 0 8px rgba(255, 182, 66, 0.8));
    }
    /* Confetti Canvas */
    .confetti-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 99999;
    }
    body.focus-mode {
      padding-top: env(safe-area-inset-top);
      overscroll-behavior: none;
      overflow: hidden;
      height: 100svh;
      position: fixed;
      inset: 0;
      width: 100%;
    }
    body.focus-mode .main-header,
    body.focus-mode .page-footer {
      display: none !important;
    }
    body.focus-mode .game-container {
      height: calc(100svh - env(safe-area-inset-top));
      padding: 0;
      overflow: hidden;
      scroll-snap-type: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: fixed;
      top: env(safe-area-inset-top);
      left: 50%;
      transform: translateX(-50%);
      width: min(calc(100vw - 4px), 780px);
    }
    body.focus-mode .game-card {
      width: 100%;
      margin: 0;
      padding: 0;
    }
    body.focus-mode .game-stage {
      border-radius: 18px;
      box-shadow: 0 12px 48px rgba(0,0,0,0.7);
      touch-action: none !important;
      -ms-touch-action: none !important;
      overscroll-behavior: contain;
    }
    body.focus-mode .game-card:not(.is-focus-active) {
      display: none !important;
    }
    body.focus-mode .game-footer {
      display: none !important;
    }
    body.focus-mode .focus-toggle {
      background: rgba(0, 0, 0, 0.55);
      opacity: 0.55;
    }
    body.focus-mode .game-card:not(.is-focus-active) {
      display: none !important;
    }

    @media (max-width: 800px) {
      /* HEADER - Thu hẹp 25% */
      :root { --header-h: 39px; } /* Giảm từ 52px */
      .main-header {
        height: var(--header-h);
        padding: 0 14px;
      }
      .logo {
        font-size: 17px; /* Giảm 25% từ 22px */
        letter-spacing: 0.8px;
      }
      .header-actions {
        gap: 8px;
      }
      .icon-button {
        width: 30px; /* Giảm 25% từ 40px */
        height: 30px; /* Giảm 25% từ 40px */
        border-radius: 9px;
      }
      .icon-button svg.header-icon {
        width: 16px; /* Giảm tương ứng */
        height: 16px;
      }
      .wallet-status-button {
        height: 30px; /* Giảm 25% từ 40px */
        padding: 0 10px;
        font-size: 12px;
      }
      .wallet-status-icon {
        width: 14px;
        height: 12px;
      }
      .nav-dropdown {
        width: 180px;
        right: 0;
      }
      
      /* FOOTER - Tăng 25% */
      .game-footer {
        gap: 5px; /* Tăng từ 4px */
        padding: 5px 12px 8px; /* Tăng từ 4px 10px 6px */
      }
      .game-icons {
        padding: 0; /* Xóa padding để sát lề */
      }
      .game-icons-left {
        gap: 8px;
        margin-left: -8px; /* Kéo sát lề trái hơn 50% */
      }
      .game-icons-right {
        gap: 8px;
        margin-right: -8px; /* Kéo sát lề phải hơn 50% */
      }
      .icon-wrapper {
        gap: 6px; /* Giảm từ 8px để icon+text gần nhau */
      }
      .icon-wrapper button {
        width: 25px; /* Giảm 25% từ 33px */
        height: 25px;
      }
      .icon-wrapper svg {
        width: 21px; /* Giảm 25% từ 28px */
        height: 21px;
        stroke-width: 2.2;
      }
      .icon-wrapper button span {
        font-size: 19px !important; /* MC text giảm 25% từ 25px */
      }
      .icon-count {
        font-size: 11px; /* Giảm 25% từ 14px */
        min-width: 20px;
      }
      .creator-text {
        font-size: 11px; /* Giữ size nhỏ gọn trên mobile */
      }
    }

    /* Like button active state */
    .game-icons button.liked {
      color: #ff4d4d;
      transform: scale(1.08);
    }
    /* Comments overlay */
    .comments-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:100000}
    .comments-overlay.open{display:flex}
    .comments-box{width:720px;max-width:95vw;background:#0b0b0b;border:1px solid #1f1f1f;border-radius:12px;box-shadow:0 10px 30px #000a;display:flex;flex-direction:column}
    .comments-header{display:flex;align-items:center;justify-content:flex-end;padding:10px 14px;border-bottom:1px solid #1f1f1f}
    .comments-title{display:none}
    .comments-list{height:50vh;overflow:auto;padding:10px 14px;display:flex;flex-direction:column;gap:10px;scrollbar-width:none;-ms-overflow-style:none}
    .comments-list::-webkit-scrollbar{display:none}
    .comment-item{background:#101010;border:1px solid #1f1f1f;border-radius:10px;padding:10px}
    .comment-meta{color:#8aa; font-size:24px;margin-bottom:8px}
    .comment-text{font-size:28px;line-height:1.6;white-space:pre-wrap}
    .comments-input{display:flex;gap:8px;padding:10px 14px;border-top:1px solid #1f1f1f}
    .comments-input textarea{flex:1;min-height:60px;max-height:160px;background:#0e0e0e;color:#fff;border:1px solid #2a2a2a;border-radius:8px;padding:10px;font-size:20px;resize:vertical}
    .comments-input button{height:56px;background:#273e66;color:#fff;border:1px solid #3c5a8a;border-radius:8px;padding:0 16px;cursor:pointer;font-size:32px}
    .comments-footer{display:flex;justify-content:center;padding:10px 14px}
    .comments-footer button{background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:8px;padding:8px 16px;cursor:pointer;font-size:16px}
    #statsOverlay .comments-box{max-width:460px;padding:24px 28px;background:#0b0b0b;border:1px solid rgba(255,182,66,0.35)}
    .stats-header{display:flex;align-items:center;justify-content:space-between;padding-bottom:12px;margin-bottom:12px;border-bottom:1px solid rgba(255,182,66,0.25)}
    .stats-title{font-size:20px;font-weight:600;color:#ffb642;letter-spacing:1px;text-transform:uppercase}
    .stats-content{display:flex;flex-direction:column;gap:18px;align-items:center;text-align:center;padding:12px 0 8px}
    .stats-item{display:flex;flex-direction:column;gap:6px;align-items:center}
    .stats-label{font-size:16px;color:#f0c67a;letter-spacing:1px;text-transform:uppercase}
    .stats-metric{font-size:42px;font-weight:700;color:#ffb642;text-shadow:0 0 18px rgba(255,182,66,0.35)}
    .stats-divider{width:80%;height:1px;background:rgba(255,182,66,0.2)}
    .stats-note{font-size:14px;color:#bfa36a}
    .stats-data-cache {
      position: absolute;
      width: 0;
      height: 0;
      overflow: hidden;
      opacity: 0;
    }
    #walletOverlay .comments-box{max-width:520px;padding:20px 24px;gap:0}
    .wallet-sheet{display:flex;flex-direction:column;gap:16px}
    .wallet-header{display:flex;align-items:center;justify-content:space-between;padding-bottom:12px;border-bottom:1px solid #1f1f1f}
    .wallet-title{font-size:20px;font-weight:600;color:#0ff;letter-spacing:0.8px;text-transform:uppercase}
    .wallet-body{display:flex;flex-direction:column;gap:12px;color:#d5d9e6}
    .wallet-row{display:flex;align-items:center;justify-content:space-between;background:#15191f;border:1px solid #1f242c;border-radius:12px;padding:12px 16px}
    .wallet-row span:first-child{font-size:14px;color:#9aa}
    .wallet-row span:last-child{font-size:16px;font-weight:600;color:#0ff}
    .wallet-actions{display:flex;justify-content:flex-end;gap:12px;margin-top:8px}
    .wallet-actions button{background:#273e66;color:#fff;border:1px solid #3c5a8a;border-radius:10px;padding:10px 18px;font-size:15px;font-weight:600;cursor:pointer}
    .wallet-actions button.secondary{background:none;border:1px solid #2a2f38;color:#bbb}
    @media (min-width: 1024px) {
      .game-footer {
        gap: 10px;
        padding: 8px 16px 12px;
        font-size: 15.5px;
      }
      .game-icons {
        gap: 22px;
      }
      .icon-wrapper button {
        width: 42px;
        height: 42px;
      }
      .icon-wrapper svg {
        width: 36px;
        height: 36px;
        stroke-width: 2.6;
      }
      .icon-count {
        font-size: 17px;
        min-width: 28px;
      }
      .creator-text {
        font-size: 17px;
        line-height: 1.4;
        letter-spacing: 0.25px;
      }
    }
  </style>
</head>
<body>
  <!-- HEADER: Logo left, Dropdown right, single row -->
  <div class="main-header">
    <a class="logo" href="docs.html" target="_blank" rel="noopener noreferrer">
      MEMEPLAY
      <span id="headerEarnedFlash" class="header-flash"></span>
    </a>
    <div class="header-actions">
      <div class="search-wrapper">
        <button id="searchToggleButton" class="icon-button search-button" aria-haspopup="true" aria-expanded="false" title="Browse categories">
          <svg class="header-icon" viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="10.5" cy="10.5" r="6.5"></circle>
            <path d="M15.5 15.5L21 21"></path>
          </svg>
        </button>
        <div class="nav-dropdown" id="navDropdown" role="menu" aria-hidden="true">
          <div class="dropdown-list" id="dropdownList">
            <div class="dropdown-item active" data-category="Recommended">Recommended</div>
            <div class="dropdown-item" data-category="Liked">Liked</div>
            <div class="dropdown-item" data-category="Trending">Trending</div>
            <div class="dropdown-item" data-category="Popular">Popular</div>
          </div>
        </div>
      </div>
      <div class="search-wrapper">
        <button id="quickActionsButton" class="icon-button" aria-haspopup="true" aria-expanded="false" title="Quick actions">
          <span class="icon-plus">＋</span>
        </button>
        <div class="nav-dropdown" id="quickActionsDropdown" role="menu" aria-hidden="true">
          <div class="dropdown-list" id="quickActionsList">
            <div class="dropdown-item" data-action="stats">Stats</div>
            <div class="dropdown-item" data-action="creator">Creator</div>
          </div>
        </div>
      </div>
      <button id="walletConnectBtn" class="icon-button wallet-connect" aria-label="Connect MetaMask">
        <img src="assets/icons/metamask.svg" alt="MetaMask" />
      </button>
      <button id="walletStatusBtn" class="wallet-status-button" hidden aria-label="Wallet details">
        <img src="assets/icons/wallet.svg" alt="Wallet" class="wallet-status-icon" />
        <span id="walletStatusText"></span>
      </button>
    </div>
    <div class="stats-data-cache" aria-hidden="true">
      <span id="streakCount">0</span>
      <span id="headerEarned">0</span>
    </div>
  </div>

  

  <div class="game-container"></div>
    

  
  <div id="commentsOverlay" class="comments-overlay">
    <div class="comments-box">
      <div class="comments-header">
        <div class="comments-title"></div>
        <button id="commentsCloseBtn" style="background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:6px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:42px;line-height:1;font-weight:700;">×</button>
      </div>
      <div id="commentsList" class="comments-list"></div>
      <div class="comments-footer">
        <button id="commentsLoadMore">Load more</button>
      </div>
      <div class="comments-input">
        <textarea id="commentsTextarea" placeholder="Write a comment..."></textarea>
        <button id="commentsPostBtn">Post</button>
      </div>
    </div>
  </div>
  
  <div id="walletOverlay" class="comments-overlay">
    <div class="comments-box wallet-sheet">
      <div class="wallet-header">
        <div class="wallet-title">Wallet</div>
        <button id="walletCloseBtn" style="background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:6px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:42px;line-height:1;font-weight:700;">×</button>
      </div>
      <div class="wallet-body">
        <div class="wallet-row">
          <span>Address</span>
          <span id="walletOverlayAddress">-</span>
        </div>
        <div class="wallet-row">
          <span>Streak</span>
          <span id="walletOverlayStreak">0</span>
        </div>
        <div class="wallet-row">
          <span>PLAY points</span>
          <span id="walletOverlayPlays">0</span>
        </div>
      </div>
      <div class="wallet-actions">
        <button class="secondary" id="walletCopyBtn">Copy address</button>
        <button id="walletDisconnectBtn">Disconnect</button>
      </div>
    </div>
  </div>
  
  <div id="creatorOverlay" class="comments-overlay">
    <div class="comments-box creator-box">
      <div class="wallet-header" style="justify-content:flex-end;">
        <button id="creatorCloseBtn" style="background:none;border:1px solid #2a2a2a;color:#bbb;border-radius:6px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:42px;line-height:1;font-weight:700;">×</button>
      </div>
      <div class="creator-hero">Build your game with MemePlay AI studio.</div>
      <div class="creator-points">
        <div class="creator-point">
          <div class="creator-point-icon">↑</div>
          <div>Instantly public + meme coin exposure for featured drops.</div>
        </div>
        <div class="creator-point">
          <div class="creator-point-icon">$</div>
          <div>Earn additional airdrop tokens every time players engage.</div>
        </div>
      </div>
      <div class="creator-cta">
        Create game
        <span>(coming soon)</span>
      </div>
    </div>
  </div>

  <div id="statsOverlay" class="comments-overlay">
    <div class="comments-box">
      <div class="stats-header">
        <div class="stats-title">MemePlay Stats</div>
        <button id="statsCloseBtn" style="background:none;border:1px solid rgba(255,182,66,0.4);color:#ffce7a;border-radius:8px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:36px;line-height:1;font-weight:700;">×</button>
      </div>
      <div class="stats-content">
        <div class="stats-item">
          <div class="stats-label">Current Streak</div>
          <div class="stats-metric" id="statsStreak">0</div>
        </div>
        <div class="stats-divider"></div>
        <div class="stats-item">
          <div class="stats-label">Play Points</div>
          <div class="stats-metric" id="statsPlays">0</div>
        </div>
        <div class="stats-note">Lifetime PLAY points keep growing — keep gaming daily!</div>
      </div>
    </div>
  </div>

  <div id="leaderboardOverlay" class="comments-overlay">
    <div class="comments-box leaderboard-box">
      <div class="stats-header leaderboard-header">
        <div class="leaderboard-tabs">
          <button class="leaderboard-tab active" data-panel="scores">🏆 SCORES</button>
          <button class="leaderboard-tab" data-panel="rewards">🎖 REWARDS</button>
        </div>
        <button id="leaderboardCloseBtn" style="background:none;border:1px solid rgba(255,182,66,0.4);color:#ffce7a;border-radius:8px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:36px;line-height:1;font-weight:700;margin-left:auto;">×</button>
      </div>
      <div class="leaderboard-panels">
        <div id="leaderboardPanelScores" class="leaderboard-panel active">
          <div id="leaderboardList" class="leaderboard-list"></div>
        </div>
        <div id="leaderboardPanelRewards" class="leaderboard-panel">
          <div id="leaderboardRewardSummary" class="leaderboard-reward-summary"></div>
          <div id="leaderboardRewardList" class="leaderboard-reward-list"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="shareOverlay" class="comments-overlay">
    <div class="comments-box" style="max-width:420px;padding:28px 32px;">
      <div class="stats-header">
        <div class="stats-title">Share Game</div>
        <button id="shareCloseBtn" style="background:none;border:1px solid rgba(255,182,66,0.4);color:#ffce7a;border-radius:8px;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:36px;line-height:1;font-weight:700;">×</button>
      </div>
      <div style="display:flex;flex-direction:column;gap:14px;padding:20px 0 10px;">
        <button id="shareCopyBtn" class="share-option-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
          </svg>
          <span>Copy Link</span>
        </button>
        <button id="shareTelegramBtn" class="share-option-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.64 6.8c-.15 1.58-.8 5.42-1.13 7.19-.14.75-.42 1-.68 1.03-.58.05-1.02-.38-1.58-.75-.88-.58-1.38-.94-2.23-1.5-.99-.65-.35-1.01.22-1.59.15-.15 2.71-2.48 2.76-2.69a.2.2 0 00-.05-.18c-.06-.05-.14-.03-.21-.02-.09.02-1.49.95-4.22 2.79-.4.27-.76.41-1.08.4-.36-.01-1.04-.2-1.55-.37-.63-.2-1.12-.31-1.08-.66.02-.18.27-.36.74-.55 2.92-1.27 4.86-2.11 5.83-2.51 2.78-1.16 3.35-1.36 3.73-1.36.08 0 .27.02.39.12.1.08.13.19.14.27-.01.06.01.24 0 .38z"/>
          </svg>
          <span>Share on Telegram</span>
        </button>
        <button id="shareXBtn" class="share-option-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
          </svg>
          <span>Share on X</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Achievement Toast -->
  <div id="achievementToast" class="achievement-toast">
    <div class="achievement-toast-title">🎉 Achievement Unlocked!</div>
    <div class="achievement-toast-subtitle" id="achievementName">⭐ Starter (1/3)</div>
    <div class="achievement-toast-reward" id="achievementReward">+100 PLAY</div>
  </div>

  <!-- Confetti Canvas -->
  <canvas id="confettiCanvas" class="confetti-canvas"></canvas>

  <script>
    // Game management system (auto-activate visible card)
    let currentActiveGame = null;
    const preloadedGames = new Set(); // Track preloaded games
    
    // Game URLs mapping (active games only)
    const gameUrls = {
      'bird-squash': 'https://bird-squash-dev.lovable.app',
      'wojak-btc-blast': 'https://wojak-btc-blast.lovable.app',
      'moonshot-bnb': 'https://moonshot-bnb.lovable.app',
      'valley-explorer-3d': 'https://rosebud.ai/p/85b0b137-33c2-40a0-bdce-dbb9abee3493',
      'hodl-tower-stack': 'https://hodl-tower-stack.lovable.app',
      'hook-pull-crypto': 'https://hook-pull-crypto.lovable.app',
      'game-detective': 'https://game-detective-clone.lovable.app',
      'monkey-crypto-climb': 'https://monkey-crypto-climb.lovable.app',
      'crypto-arrow': 'https://crypto-arrow1.lovable.app',
      'inverse-cramer': 'https://inverse-cramer.lovable.app'
    };
  
    function activateGame(gameId, isPreload = false) {
      // Nếu là preload, không check currentActiveGame
      if (!isPreload && currentActiveGame === gameId) return;
      
      // Chỉ stop previous game nếu KHÔNG phải preload
      if (!isPreload && currentActiveGame && !preloadedGames.has(currentActiveGame)) {
        // Ensure previous session is stopped (module exposes on window)
        try { window.memeplay && window.memeplay.stopGame && window.memeplay.stopGame(); } catch {}
        const prevCard = document.getElementById(currentActiveGame);
        if (prevCard) {
          const prevIframe = prevCard.querySelector('iframe');
          if (prevIframe) prevIframe.src = 'about:blank';
        }
      }
  

      const card = document.getElementById(gameId);
      if (!card) return;
      const iframe = card.querySelector('iframe');
      if (iframe && gameUrls[gameId]) {
        // Chỉ load nếu chưa có src
        if (!iframe.src || iframe.src === '' || iframe.src.includes('about:blank')) {
          // Bust cache to guarantee a load event even if same URL
          const sep = gameUrls[gameId].includes('?') ? '&' : '?'
          iframe.src = gameUrls[gameId] + sep + 'v=' + Date.now();
          console.log(isPreload ? '🔄 Preloaded' : '🎮 Activated', gameId);
        }
        
        if (isPreload) {
          preloadedGames.add(gameId);
        } else {
          currentActiveGame = gameId;
          try { window.__memeplayActiveGame = gameId } catch {}
          document.dispatchEvent(new CustomEvent('memeplay:active-game-changed', { detail: { gameId } }));
        }
        
        // Proactively start session ticker in case load fired earlier (module-exposed)
        setTimeout(() => {
          try {
            if (window.memeplay && window.memeplay.forceStart) window.memeplay.forceStart(gameId);
            else if (window.memeplay && window.memeplay.startGame) window.memeplay.startGame(gameId);
          } catch {}
        }, 500);
      }
    }

    // Observe which game card is visible and activate early for snappier switching
  function initGameObserver() {
    const thresholds = Array.from({ length: 10 }, (_, i) => (i + 1) / 10);
    const observer = new IntersectionObserver((entries) => {
        const visible = entries.filter(e => e.isIntersecting);
        if (!visible.length) return;

        // Pick the entry with the greatest intersection; this favors the one you're scrolling to
        const best = visible.reduce((a, b) => a.intersectionRatio >= b.intersectionRatio ? a : b);
        const gameId = best.target.id;
        activateGame(gameId);
    }, {
        // Observe inside the snapping container
        root: document.querySelector('.game-container') || null,
        rootMargin: '25% 0px -55% 0px',
        threshold: thresholds
      });

    document.querySelectorAll('.game-card').forEach(card => observer.observe(card));
    console.log('✅ Game observer initialized for', document.querySelectorAll('.game-card').length, 'games')
  }
    
    // Dropdown nav logic
    const navDropdown = document.getElementById('navDropdown');
    const dropdownList = document.getElementById('dropdownList');
    const items = dropdownList ? dropdownList.querySelectorAll('.dropdown-item') : [];
    const searchToggleButton = document.getElementById('searchToggleButton');
    const quickToggleButton = document.getElementById('quickActionsButton');
    const quickDropdown = document.getElementById('quickActionsDropdown');
    const quickItems = quickDropdown ? quickDropdown.querySelectorAll('.dropdown-item') : [];

    function closeNavDropdown() {
      navDropdown.classList.remove('open');
      navDropdown.setAttribute('aria-hidden', 'true');
      searchToggleButton?.setAttribute('aria-expanded', 'false');
    }

    function closeQuickDropdown() {
      quickDropdown?.classList.remove('open');
      quickDropdown?.setAttribute('aria-hidden', 'true');
      quickToggleButton?.setAttribute('aria-expanded', 'false');
    }

    searchToggleButton?.addEventListener('click', (event) => {
      event.stopPropagation();
      closeQuickDropdown();
      const willOpen = !navDropdown.classList.contains('open');
      if (willOpen) {
        navDropdown.classList.add('open');
        navDropdown.setAttribute('aria-hidden', 'false');
        searchToggleButton.setAttribute('aria-expanded', 'true');
      } else {
        closeNavDropdown();
      }
    });

    items.forEach(item => {
      item.addEventListener('click', function(e) {
        items.forEach(i => i.classList.remove('active'));
        this.classList.add('active');
        closeNavDropdown();
        e.stopPropagation();
        // Optionally hook category filtering here.
      });
    });

    quickToggleButton?.addEventListener('click', (event) => {
      event.stopPropagation();
      closeNavDropdown();
      const willOpen = !quickDropdown.classList.contains('open');
      if (willOpen) {
        quickDropdown.classList.add('open');
        quickDropdown.setAttribute('aria-hidden', 'false');
        quickToggleButton.setAttribute('aria-expanded', 'true');
      } else {
        closeQuickDropdown();
      }
    });

    quickItems.forEach(item => {
      item.addEventListener('click', (event) => {
        event.stopPropagation();
        const action = item.getAttribute('data-action');
        switch(action) {
          case 'stats':
            if (typeof window.__openStatsOverlay === 'function') {
              window.__openStatsOverlay();
            }
            break;
          case 'creator':
            if (typeof window.__openCreatorOverlay === 'function') {
              window.__openCreatorOverlay();
            }
            break;
          default:
            document.querySelector('.game-container')?.scrollTo({ top: 0, behavior: 'smooth' });
        }
        closeQuickDropdown();
      });
    });

    document.addEventListener('click', function(e) {
      if (navDropdown.contains(e.target) || searchToggleButton.contains(e.target)) {
        closeQuickDropdown();
        return;
      }
      if (quickDropdown?.contains(e.target) || quickToggleButton?.contains(e.target)) {
      closeNavDropdown();
        return;
      }
      closeNavDropdown();
      closeQuickDropdown();
    });
  </script>

  <!-- main.js disabled (conflicts with embedded iframes) -->

  <!-- === SUPABASE DAILY CHECK-IN & REWARD === -->

<script type="module">
  async function loadGameCards() {
    const container = document.querySelector('.game-container')
    if (!container) return
    try {
      const response = await fetch('games/game-list.html', { cache: 'no-cache' })
      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      const markup = await response.text()
      const parser = new DOMParser()
      const doc = parser.parseFromString(markup, 'text/html')
      const wrapper = doc.querySelector('[data-game-list]')
      container.innerHTML = wrapper ? wrapper.innerHTML : markup
      console.log('✅ Game cards loaded:', document.querySelectorAll('.game-card').length)
      initFocusControls()
      
      // 🚀 PHƯƠNG ÁN B: Preload 4 games đầu - SCROLL TRƯỚC, LOAD SAU
      
      // Lấy 4 games đầu tiên trong DOM (không hard-code)
      const allCards = Array.from(document.querySelectorAll('.game-card'))
      const firstFourGames = allCards.slice(0, 4).map(c => c.id).filter(Boolean)
      
      // DEBUG: Check game order
      console.log('📋 Game order in DOM:')
      allCards.forEach((card, idx) => {
        console.log(`  ${idx + 1}. ${card.id}`)
      })
      
      // BƯỚC 1: FORCE SCROLL ĐẾN GAME ĐẦU TIÊN (disable snap trước)
      const firstCard = allCards[0]
      const gameContainer = document.querySelector('.game-container')
      
      if (firstCard && gameContainer) {
        // Disable scroll-snap tạm thời để force position
        gameContainer.style.scrollSnapType = 'none'
        gameContainer.style.scrollBehavior = 'auto'
        
        // Force scroll to absolute top
        gameContainer.scrollTop = 0
        
        // Scroll to first card explicitly
        requestAnimationFrame(() => {
          firstCard.scrollIntoView({ block: 'start' })
          console.log('📍 Force scrolled to:', firstCard.id)
          
          // Re-enable scroll-snap sau 500ms
          setTimeout(() => {
            gameContainer.style.scrollSnapType = 'y mandatory'
            gameContainer.style.scrollBehavior = 'smooth'
            console.log('✅ Scroll-snap re-enabled')
          }, 500)
        })
      }
      
      // BƯỚC 2: Init observers
      initGameObserver()
      initSocialHandlers()
      
      // BƯỚC 3: PRELOAD 2 GAMES ĐẦU TIÊN (optimal balance)
      setTimeout(() => {
        const firstTwo = firstFourGames.slice(0, 2)
        console.log('🎮 Preloading first 2 games IN PARALLEL:', firstTwo)
        
        // Load 2 games CÙNG LÚC (true parallel - different subdomains)
        firstTwo.forEach((gameId) => {
          if (gameId) {
            // isPreload = true → Load parallel, không stop nhau
            activateGame(gameId, true)
          }
        })
        
        // Set game đầu tiên làm "current" ngay
        if (firstFourGames[0]) {
          currentActiveGame = firstFourGames[0]
          console.log('  ✅ Current game:', firstFourGames[0])
          console.log('  🎯 Strategy: First 2 preloaded (parallel), others load on scroll')
        }
      }, 300)
      
    } catch (error) {
      console.error('Load game list failed:', error)
      container.innerHTML = '<div style="padding:24px;text-align:center;color:#bbb;">Unable to load games. Please refresh.</div>'
    }
  }
  
  // Load games on page load
  loadGameCards()

  function updateFocusButtons() {
    const active = document.body.classList.contains('focus-mode')
    document.querySelectorAll('.focus-toggle').forEach(btn => {
      btn.setAttribute('aria-pressed', active ? 'true' : 'false')
      btn.textContent = active ? '⤡' : '⤢'
    })
  }

  const focusState = { scrollTop: 0, gameId: null }

  function toggleFocusMode(force) {
    const next = typeof force === 'boolean' ? force : !document.body.classList.contains('focus-mode')
    document.body.classList.toggle('focus-mode', !!next)
    const container = document.querySelector('.game-container')
    if (!next) {
      if (container) {
        container.style.scrollBehavior = 'auto'
        if (focusState.gameId) {
          const card = document.getElementById(focusState.gameId)
          if (card) {
            container.scrollTop = Math.max(0, card.offsetTop - container.offsetTop)
          } else {
            container.scrollTop = Math.max(0, focusState.scrollTop)
          }
        } else {
          container.scrollTop = Math.max(0, focusState.scrollTop)
        }
        container.style.scrollBehavior = ''
      }
      clearFocusActiveCard()
    } else {
      if (container) {
        focusState.scrollTop = container.scrollTop
      }
      const fallbackId = currentActiveGame || document.querySelector('.game-card')?.id
      let focusId = window.__memeplayActiveGame || fallbackId
      if (!focusId && fallbackId) focusId = fallbackId
      if (focusId) {
        focusState.gameId = focusId
        if (!window.__memeplayActiveGame) {
          try { window.__memeplayActiveGame = focusId } catch {}
        }
        applyFocusActiveCard(focusId)
      }
      requestAnimationFrame(scrollActiveGameIntoView)
    }
    updateFocusButtons()
  }

  function initFocusControls() {
    const buttons = document.querySelectorAll('.focus-toggle')
    buttons.forEach(btn => {
      if (btn.dataset.bound === '1') return
      btn.dataset.bound = '1'
      btn.addEventListener('click', (event) => {
        event.preventDefault()
        event.stopPropagation()
        const ownerCard = btn.closest('.game-card')
        if (ownerCard) {
          const gid = ownerCard.getAttribute('data-game-id') || ownerCard.id
          if (gid) {
            try { window.__memeplayActiveGame = gid } catch {}
            focusState.gameId = gid
          }
        }
        toggleFocusMode()
      })
    })
    updateFocusButtons()
  }

  function scrollActiveGameIntoView() {
    const container = document.querySelector('.game-container')
    if (!container) return
    const targetId = window.__memeplayActiveGame || currentActiveGame || container.querySelector('.game-card')?.id
    if (!targetId) return
    const card = document.getElementById(targetId)
    if (!card) return
    container.style.scrollBehavior = 'auto'
    container.scrollTop = Math.max(0, card.offsetTop - container.offsetTop)
    container.style.scrollBehavior = ''
  }

  function clearFocusActiveCard() {
    document.querySelectorAll('.game-card.is-focus-active').forEach(card => card.classList.remove('is-focus-active'))
  }

  function applyFocusActiveCard(gameId) {
    if (!gameId) return
    const card = document.getElementById(gameId)
    if (!card) return
    clearFocusActiveCard()
    card.classList.add('is-focus-active')
  }

  function lockGameTouch(gameId) {
    const stage = document.querySelector(`.game-card[data-game-id="${gameId}"] .game-stage`)
    if (!stage || stage.dataset.touchLocked === '1') return
    stage.dataset.touchLocked = '1'
    const prevent = (event) => { if (event.cancelable) event.preventDefault() }
    // Only prevent touchmove to stop scrolling, don't interfere with touchstart
    stage.addEventListener('touchmove', prevent, { passive: false, capture: true })
  }

  document.addEventListener('memeplay:active-game-changed', (event) => {
    const gameId = event?.detail?.gameId
    if (gameId) {
      try { window.__memeplayActiveGame = gameId } catch {}
      focusState.gameId = gameId
      lockGameTouch(gameId)
      if (document.body.classList.contains('focus-mode')) {
        applyFocusActiveCard(gameId)
        requestAnimationFrame(scrollActiveGameIntoView)
      }
    }
  })

  window.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && document.body.classList.contains('focus-mode')) {
      toggleFocusMode(false)
    }
  })

  await loadGameCards()
  lockGameTouch('wojak-btc-blast')

  // 1️⃣ Import SDK Supabase (thư viện kết nối Supabase trực tiếp trên web)
  import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

  // 2️⃣ Khai báo thông tin kết nối (URL & Anon Key của dự án bạn)
  const SUPABASE_URL = 'https://iikckrcdrvnqctzacxgx.supabase.co'    // ← URL của bạn
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlpa2NrcmNkcnZucWN0emFjeGd4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE3Mzc3NDgsImV4cCI6MjA3NzMxMzc0OH0.nIPvf11YfFlWH0XHDZdxI496zaP431QOJCuQ-5XX4DQ'             // ← Dán key thật tại đây

  // 3️⃣ Tạo đối tượng "supabase" để sử dụng RPC, truy vấn, insert, v.v.
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

  // 🚀 Helper: Send RPC with keepalive (prevents data loss on F5/close)
  async function rpcWithKeepalive(functionName, params) {
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/${functionName}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Prefer': 'return=representation'
        },
        body: JSON.stringify(params),
        keepalive: true  // ← Ensures delivery even if page closes!
      })
      
      if (!response.ok) {
        throw new Error(`RPC ${functionName} failed: ${response.statusText}`)
      }
      
      const data = await response.json()
      return { data, error: null }
    } catch (error) {
      console.error(`rpcWithKeepalive(${functionName}) error:`, error.message)
      return { data: null, error }
    }
  }

  // =========================================================
  // 🔹 TẠO USER ID DUY NHẤT (ghi trong localStorage)
  // =========================================================
  // User identifier prefers wallet address if connected; falls back to random local id
  function generateLocalUuid() {
    try {
      const cryptoObj = globalThis.crypto || globalThis.msCrypto
      if (cryptoObj?.randomUUID) return cryptoObj.randomUUID()
      if (cryptoObj?.getRandomValues) {
        const buf = cryptoObj.getRandomValues(new Uint8Array(16))
        buf[6] = (buf[6] & 0x0f) | 0x40
        buf[8] = (buf[8] & 0x3f) | 0x80
        const hex = Array.from(buf, b => b.toString(16).padStart(2, '0')).join('')
        return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`
      }
    } catch (err) {
      console.warn('generateLocalUuid fallback', err)
    }
    const fallback = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0
      const v = c === 'x' ? r : ((r & 0x3) | 0x8)
      return v.toString(16)
    })
    return fallback
  }

  function getLocalUserId() {
    let id = localStorage.getItem('mp_user_id')
    if (!id) {
      id = 'u_' + generateLocalUuid()
      localStorage.setItem('mp_user_id', id)
    }
    return id
  }
  function getWalletAddress() {
    return localStorage.getItem('mp_user_wallet') || ''
  }
  let userId = getWalletAddress() || getLocalUserId()
  console.log('👤 Current user identifier:', userId)

  // =========================================================
  // 🔹 UI HELPERS (PLAY points header only)
  // =========================================================
  const els = {
    headerEarned: document.getElementById('headerEarned'),
    headerEarnedFlash: document.getElementById('headerEarnedFlash'),
    streak: document.getElementById('streakCount'),
    connectBtn: document.getElementById('walletConnectBtn'),
    walletBadge: document.getElementById('walletStatusBtn'),
    walletStatus: document.getElementById('walletStatusText')
  }

  function lsGetInt(key, fallback = 0) {
    const raw = localStorage.getItem(key)
    const num = raw == null ? NaN : Number(raw)
    return Number.isFinite(num) ? num : fallback
  }
  function lsSetInt(key, value) {
    localStorage.setItem(key, String(Math.max(0, Math.trunc(value))))
  }
  // No status bar counters

  function updateHeaderEarned() {
    const totalEarned = lsGetInt('mp_total_earned_plays')
    els.headerEarned && (els.headerEarned.textContent = String(totalEarned))
    if (typeof window.__updateStatsOverlay === 'function') window.__updateStatsOverlay()
  }

  // Show inline banner near PLAY points and apply increment after 3s
  // Confetti Engine
  function createConfetti() {
    const canvas = document.getElementById('confettiCanvas')
    if (!canvas) return
    const ctx = canvas.getContext('2d')
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    
    const particles = []
    const colors = ['#ffb642', '#ff9000', '#ffd700', '#ff6b6b', '#4ecdc4']
    
    for (let i = 0; i < 100; i++) {
      particles.push({
        x: canvas.width / 2,
        y: canvas.height * 0.8, // Từ vị trí icon ⭐
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 1) * 15,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: Math.random() * 8 + 4,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10
      })
    }
    
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      let active = false
      
      particles.forEach(p => {
        p.vy += 0.3 // Gravity
        p.x += p.vx
        p.y += p.vy
        p.rotation += p.rotationSpeed
        
        if (p.y < canvas.height + 50) {
          active = true
          ctx.save()
          ctx.translate(p.x, p.y)
          ctx.rotate(p.rotation * Math.PI / 180)
          ctx.fillStyle = p.color
          ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size)
          ctx.restore()
        }
      })
      
      if (active) requestAnimationFrame(animate)
      else canvas.style.opacity = '0'
    }
    
    canvas.style.opacity = '1'
    animate()
    
    setTimeout(() => {
      canvas.style.opacity = '0'
    }, 3000)
  }

  function showAchievementToast(achievementName, count, total, reward) {
    const toast = document.getElementById('achievementToast')
    const nameEl = document.getElementById('achievementName')
    const rewardEl = document.getElementById('achievementReward')
    
    if (!toast) return
    
    nameEl.textContent = `⭐ ${achievementName} (${count}/${total})`
    rewardEl.textContent = `+${reward} PLAY`
    
    toast.classList.add('show')
    
    setTimeout(() => {
      toast.classList.remove('show')
    }, 2000)
  }

  function celebrateAchievement(gameId, achievementName, count, reward) {
    // 1. Pháo hoa nổ
    createConfetti()
    
    // 2. Toast center
    showAchievementToast(achievementName, count, 3, reward)
    
    // 3. Icon rung
    const card = document.querySelector(`.game-card[data-game-id="${gameId}"]`)
    const achievementIcon = card?.querySelector('.icon-wrapper[data-role="leaderboard"]')
    if (achievementIcon) {
      achievementIcon.classList.add('shake')
      setTimeout(() => achievementIcon.classList.remove('shake'), 800)
      
    }

    const leaderboardOverlayEl = document.getElementById('leaderboardOverlay')
    if (leaderboardOverlayEl?.classList.contains('open')) {
      renderRewardsPanel(gameId)
    }
  }

  function showPlayAward(amount, label, isNewAchievement = false) {
    if (!amount || amount <= 0) return
    
    // Update total
    const newTotal = lsGetInt('mp_total_earned_plays') + amount
    lsSetInt('mp_total_earned_plays', newTotal)
    updateHeaderEarned()
    
    // If new achievement, celebrate!
    if (isNewAchievement && activeGame) {
      const achievedCount = Object.values(getGameAwards(activeGame)).filter(Boolean).length
      const achievementNames = { 10: 'Starter', 60: 'Engaged', 300: 'Champion' }
      const threshold = parseInt(label.replace('s', ''))
      celebrateAchievement(activeGame, achievementNames[threshold], achievedCount, amount)
      return
    }
    
    // Old header flash (fallback)
    const el = els.headerEarnedFlash
    if (!el) return
    el.textContent = `+${amount} PLAY${label ? ` for ${label}` : ''}`
    el.style.opacity = '1'
    setTimeout(() => {
      el.style.opacity = '0'
    }, 3000)
  }

  function updateStreak() {
    const streak = lsGetInt('mp_streak_count')
    els.streak && (els.streak.textContent = String(streak))
    if (typeof window.__updateStatsOverlay === 'function') window.__updateStatsOverlay()
  }

  // Initialize UI from localStorage
  updateHeaderEarned()
  updateStreak()

  // Load initial real play counts for all cards
  document.querySelectorAll('.game-card').forEach(card => {
    const gid = card.getAttribute('data-game-id') || card.id
    if (gid) {
      loadPlayCount(gid)
    }
  })

  // ==============================
  // Wallet Connect (MetaMask)
  // ==============================
  function shortAddr(addr) {
    if (!addr) return ''
    const lower = String(addr).toLowerCase()
    if (lower.length <= 6) return lower
    return `${lower.slice(0, 3)}...${lower.slice(-3)}`
  }
  function setWalletStatus(addr) {
    if (!els.walletStatus) return
    els.walletStatus.textContent = addr ? `connected :${shortAddr(addr)}` : ''
    if (typeof window.__updateWalletOverlay === 'function') window.__updateWalletOverlay()
  }
  setWalletStatus(getWalletAddress())

  async function connectWallet() {
    if (!window.ethereum) {
      const ua = navigator.userAgent || ''
      const isMobile = /iphone|ipad|ipod|android/i.test(ua)
      if (isMobile) {
        const rawUrl = window.location.href.split('#')[0]
        const cleaned = rawUrl.replace(/^https?:\/\//i, '')
        const deepLink = `https://metamask.app.link/dapp/${cleaned}`
        const proceed = confirm('MetaMask mobile chưa mở. Mở ứng dụng MetaMask để kết nối?')
        if (proceed) {
          window.location.href = deepLink
        }
      } else {
        alert('Please install MetaMask to connect your wallet.')
      }
      return
    }
    try {
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })
      const address = (accounts && accounts[0]) ? String(accounts[0]) : ''
      if (!address) return
      localStorage.setItem('mp_user_wallet', address)
      userId = address // prefer wallet as identifier
      setWalletStatus(address)
      setConnectButtonState()
      // Do not auto re-checkin on wallet switch; guard by daily window
      if (!hasCheckedInToday()) {
        try { await dailyCheckin() } catch {}
      }
    } catch (e) {
      console.warn('Wallet connect failed:', e?.message || e)
    }
  }
  function disconnectWallet() {
    localStorage.removeItem('mp_user_wallet')
    userId = getLocalUserId()
    setWalletStatus('')
    setConnectButtonState()
  }
  function ensureWalletBindings() {
    const connectBtn = els.connectBtn
    const statusBtn = els.walletBadge
    if (connectBtn && !connectBtn.__memeplayBound) {
      connectBtn.addEventListener('click', (event) => {
        event.preventDefault()
        connectWallet()
      })
      connectBtn.__memeplayBound = true
    }
    if (statusBtn && !statusBtn.__memeplayBound) {
      statusBtn.addEventListener('click', () => {
        if (typeof window.__openWalletOverlay === 'function') {
          window.__openWalletOverlay()
        }
      })
      statusBtn.__memeplayBound = true
    }
  }
  function setConnectButtonState() {
    if (!els.connectBtn || !els.walletBadge) return
    const address = getWalletAddress()
    const isConnected = !!address

    if (isConnected) {
      els.connectBtn.hidden = true
      els.walletBadge.hidden = false
      els.walletStatus.textContent = `connected :${shortAddr(address)}`
      ensureWalletBindings()
    } else {
      els.connectBtn.hidden = false
      els.walletBadge.hidden = true
      ensureWalletBindings()
    }
  }
  const walletApi = {
    connect: () => connectWallet(),
    disconnect: () => disconnectWallet(),
    isConnected: () => !!getWalletAddress(),
    getAddress: () => getWalletAddress(),
    getStreak: () => lsGetInt('mp_streak_count'),
    getPlayPoints: () => lsGetInt('mp_total_earned_plays'),
    openOverlay: () => {
        if (typeof window.__openWalletOverlay === 'function') {
          window.__openWalletOverlay()
        }
      }
    }
  try {
    const existing = (globalThis.memeplayWallet && typeof globalThis.memeplayWallet === 'object') ? globalThis.memeplayWallet : {}
    globalThis.memeplayWallet = Object.assign({}, existing, walletApi)
  } catch {
    globalThis.memeplayWallet = walletApi
  }
  ensureWalletBindings()
  els.connectBtn && setConnectButtonState()
  if (window.ethereum) {
    window.ethereum.on?.('accountsChanged', (accs) => {
      const addr = (accs && accs[0]) ? String(accs[0]) : ''
      if (addr) {
        localStorage.setItem('mp_user_wallet', addr)
        userId = addr
        setWalletStatus(addr)
      } else {
        localStorage.removeItem('mp_user_wallet')
        userId = getLocalUserId()
        setWalletStatus('')
      }
      setConnectButtonState()
    })
  }

  // =========================================================
  // 🔹 PER-GAME ACCUMULATED PLAYTIME & ONE-TIME REWARDS
  // =========================================================
  const REWARD_THRESHOLDS = [10, 60, 300] // seconds (10s để user nhanh hiểu có thưởng)
  const REWARD_VALUES = { 10: 100, 60: 300, 300: 1000 }
  const MAX_ACCUM_SECONDS = 300

  function getGameSeconds(gameId) {
    return lsGetInt(`mp_game_seconds_${gameId}`)
  }
  function setGameSeconds(gameId, seconds) {
    lsSetInt(`mp_game_seconds_${gameId}`, Math.min(seconds, MAX_ACCUM_SECONDS))
  }
  function getGameAwards(gameId) {
    try {
      const raw = localStorage.getItem(`mp_game_awards_${gameId}`)
      return raw ? JSON.parse(raw) : {}
    } catch {
      return {}
    }
  }
  function setGameAwards(gameId, awardsObj) {
    localStorage.setItem(`mp_game_awards_${gameId}`, JSON.stringify(awardsObj || {}))
  }
  // Console helpers
  function listAllGameSeconds() {
    const cards = Array.from(document.querySelectorAll('.game-card'))
    const rows = cards.map(c => {
      const id = c.getAttribute('data-game-id') || c.id || 'unknown'
      return { gameId: id, seconds: getGameSeconds(id) }
    })
    console.table(rows)
    return rows
  }
  function resetGameProgress(gameId) {
    if (!gameId) return false
    lsSetInt(`mp_game_seconds_${gameId}`, 0)
    localStorage.removeItem(`mp_game_awards_${gameId}`)
    console.log(`🔄 Reset progress for ${gameId}`)
    return true
  }
  // Expose to window for activation script and dev console usage
  const helpers = Object.freeze({
    // inspectors
    getGameSeconds,
    listAllGameSeconds,
    resetGameProgress,
    // controls
    startGame,
    stopGame,
    forceStart
  })
  try { window.memeplay = helpers } catch {}
  try { self.memeplay = helpers } catch {}
  try { globalThis.memeplay = helpers } catch {}
  console.log('🧩 memeplay helpers ready:', Object.keys(helpers))
  function grantPlays(amount) {
    if (!amount || amount <= 0) return 0
    const newTotal = lsGetInt('mp_total_earned_plays') + amount
    lsSetInt('mp_total_earned_plays', newTotal)
    updateHeaderEarned()
    return amount
  }

  // ===== Real play counts (per game) =====
  function setPlaysLabelForCard(gameId, totalPlays) {
    const card = document.querySelector(`.game-card[data-game-id="${gameId}"]`) || document.getElementById(gameId)
    if (!card) return
    const creator = card.querySelector('.creator-text')
    if (!creator) return
    let span = creator.querySelector('[data-plays-count]')
    if (!span) {
      // insert separator dot and span once
      const sep = document.createTextNode(' • ')
      span = document.createElement('span')
      span.setAttribute('data-plays-count', gameId)
      creator.appendChild(sep)
      creator.appendChild(span)
    }
    span.textContent = `${totalPlays} plays`

    const statsCount = card.querySelector('.icon-wrapper[data-role="stats"] .icon-count')
    if (statsCount) statsCount.textContent = String(Math.max(0, totalPlays|0))
  }
  async function loadPlayCount(gameId) {
    try {
      const { data, error } = await supabase.rpc('get_game_play_count', { p_game_id: gameId })
      if (error) { console.error('get_game_play_count error:', error.message); return }
      const val = (data && typeof data.total_plays === 'number') ? data.total_plays : 0
      setPlaysLabelForCard(gameId, val)
      console.log(`[plays] ${gameId}:`, val)
    } catch (e) { console.error('get_game_play_count error:', e?.message || e) }
  }
  async function incrementPlayCountIfEligible(gameId, seconds) {
    if (!gameId || !seconds || seconds < 5) return
    try {
      const { data, error } = await supabase.rpc('increment_play_count', {
        p_user_id: userId,
        p_game_id: gameId,
        p_seconds: seconds
      })
      if (error) { console.error('increment_play_count error:', error.message); return }
      const val = (data && typeof data.total_plays === 'number') ? data.total_plays : undefined
      if (val != null) {
        setPlaysLabelForCard(gameId, val)
        console.log(`[plays +1] ${gameId}:`, val)
      }
    } catch (e) {
      console.error('increment_play_count error:', e?.message || e)
    }
  }

  // =========================================================
  // 🔹 DAILY CHECK-IN (guarded once per day per device)
  // =========================================================
  function todayKey() {
    const d = new Date()
    return d.toISOString().slice(0,10)
  }
  function hasCheckedInToday() {
    return localStorage.getItem('mp_checkin_'+todayKey()) === '1'
  }
  function markCheckedInToday() {
    localStorage.setItem('mp_checkin_'+todayKey(), '1')
  }
  async function dailyCheckin() {
    const { data, error } = await supabase.rpc('daily_checkin', { p_user_id: userId })
    if (error) {
      console.error('❌ Daily check-in error:', error.message)
      return
    }
    console.log('✅ Daily check-in result:', data)
    if (data?.awarded > 0) {
      showPlayAward(Number(data.awarded), 'daily login')
      markCheckedInToday()
    }
    if (Number.isFinite(data?.streak)) {
      lsSetInt('mp_streak_count', Number(data.streak))
      updateStreak()
    }
  }

  // Only run on first load if not already checked in today (prevents wallet-switch abuse)
  if (!hasCheckedInToday()) dailyCheckin()
// ==============================
//  AUTO-TRACK PLAYTIME + FOCUS DELAY
// ==============================

// Biến toàn cục để theo dõi game đang chạy
let activeGame = null;
let activeStartTime = 0;
let progressInterval = null;

// Bắt đầu đếm thời gian
function startGame(gameId) {
  // Nếu đang có game khác thì dừng nó, còn nếu cùng game thì reset lại ticker/time
  if (activeGame && activeGame !== gameId) stopGame();

  // Reset ticker trước khi start (kể cả cùng game)
  clearInterval(progressInterval);
  progressInterval = null;

  activeGame = gameId;
  activeStartTime = Date.now();
  console.log(`▶️ Game ${gameId} started`);
  
  // Mark game card as playing to disable animations/transitions
  document.querySelectorAll('.game-card').forEach(card => card.classList.remove('is-playing'));
  const activeCard = document.querySelector(`.game-card[data-game-id="${gameId}"]`);
  if (activeCard) activeCard.classList.add('is-playing');

  // Live progress ticker: log session and cumulative totals every 5 seconds (optimized for performance)
  clearInterval(progressInterval);
  progressInterval = setInterval(() => {
    if (!activeGame || !activeStartTime) return;
    
    // Use requestIdleCallback to avoid interrupting game
    if (window.requestIdleCallback) {
      window.requestIdleCallback(() => {
        updateProgress();
      }, { timeout: 1000 });
    } else {
      updateProgress();
    }
  }, 5000);
  
  function updateProgress() {
    if (!activeGame || !activeStartTime) return;
    const sessionSeconds = Math.max(0, Math.floor((Date.now() - activeStartTime) / 1000));
    const prevTotal = getGameSeconds(activeGame);
    const previewTotal = Math.min(prevTotal + sessionSeconds, MAX_ACCUM_SECONDS);

    // Early reward grant when crossing thresholds during play
    const awardedMap = getGameAwards(activeGame);
    const crossedNow = [];
    for (const t of REWARD_THRESHOLDS) {
      if (prevTotal < t && previewTotal >= t && !awardedMap[t]) {
        awardedMap[t] = true;
        crossedNow.push(t);
      }
    }
    if (crossedNow.length) {
      setGameAwards(activeGame, awardedMap);
      let grant = 0;
      for (const t of crossedNow) grant += REWARD_VALUES[t];
      if (grant > 0) {
        const last = crossedNow[crossedNow.length - 1]
        showPlayAward(grant, `${last}s`, true) // ← true = NEW achievement!
      }
    }

    console.log(`⏳ ${activeGame}: session ${sessionSeconds}s · total ${previewTotal}/${MAX_ACCUM_SECONDS}s`);
  }
}

// Ép start an toàn khi chuyển game
function forceStart(gameId) {
  try { stopGame(); } catch {}
  clearInterval(progressInterval);
  progressInterval = null;
  activeGame = null;
  activeStartTime = 0;
  startGame(gameId);
}

// Dừng đếm + gửi dữ liệu Supabase
async function stopGame() {
  if (!activeGame || !activeStartTime) return;

  const seconds = Math.floor((Date.now() - activeStartTime) / 1000);
  if (seconds > 0) {
    console.log(`⏱ Played ${seconds}s on ${activeGame}`);

    // Calculate per-game accumulated time and threshold rewards
    const prevTotal = getGameSeconds(activeGame)
    const nextTotalRaw = prevTotal + seconds
    const prevCapped = Math.min(prevTotal, MAX_ACCUM_SECONDS)
    const nextCapped = Math.min(nextTotalRaw, MAX_ACCUM_SECONDS)
    setGameSeconds(activeGame, nextCapped)

    const awardedMap = getGameAwards(activeGame)
    const newlyAwarded = []
    for (const t of REWARD_THRESHOLDS) {
      if (prevCapped < t && nextCapped >= t && !awardedMap[t]) {
        awardedMap[t] = true
        newlyAwarded.push(t)
      }
    }
    console.log(`📈 Accumulated for ${activeGame}: ${nextCapped}s (was ${prevCapped}s)`) 
    if (newlyAwarded.length) {
      let totalGrant = 0
      for (const t of newlyAwarded) totalGrant += REWARD_VALUES[t]
      setGameAwards(activeGame, awardedMap)
      if (totalGrant > 0) {
        const last = newlyAwarded[newlyAwarded.length - 1]
        showPlayAward(totalGrant, `${last}s`, true) // ← true = NEW achievement!
      }
    }

    // Use keepalive to prevent data loss on F5/close tab
    try {
      const { data, error } = await rpcWithKeepalive('track_playtime_and_reward', {
        p_user_id: userId,
        p_game_id: activeGame,
        p_seconds: seconds
      });
      if (error) throw error;
      console.log(`🎮 [${activeGame}] reward result:`, data);
      if (data?.awarded > 0) showPlayAward(Number(data.awarded))
    } catch (err) {
      console.error('Playtime tracking error:', err.message);
    }

    // Increment real play count if eligible (>=5s) with keepalive
    if (seconds >= 5) {
      try {
        const { data, error } = await rpcWithKeepalive('increment_play_count', {
          p_user_id: userId,
          p_game_id: activeGame,
          p_seconds: seconds
        });
        if (error) throw error;
        
        // Update UI after server confirms (accurate count)
        if (data && typeof data.total_plays === 'number') {
          setPlaysLabelForCard(activeGame, data.total_plays)
          console.log(`📊 [plays +1] ${activeGame}: ${data.total_plays}`)
        }
      } catch (err) {
        console.error('Play count increment error:', err.message);
      }
    }
  }

  // Remove is-playing class to re-enable animations
  document.querySelectorAll('.game-card').forEach(card => card.classList.remove('is-playing'));
  
  activeGame = null;
  activeStartTime = 0;
  clearInterval(progressInterval);
  progressInterval = null;
}

// Khi iframe load xong game → bắt đầu tracking có delay
const iframes = document.querySelectorAll(".game-card iframe");
if (iframes && iframes.length) {
iframes.forEach((iframe) => {
  const gameId = iframe.closest(".game-card")?.dataset.gameId;
  if (!gameId) {
    console.warn("⚠️ Missing data-game-id for an iframe, tracking skipped.");
    return;
  }

  iframe.addEventListener("load", () => {
    setTimeout(() => {
      if (document.hasFocus()) {
        startGame(gameId);
      } else {
        console.log(`⏸ Tab not focused — deferred start ${gameId}`);
      }
    }, 1000);
  });
});
}

// Dừng khi tab ẩn
document.addEventListener("visibilitychange", () => {
  if (document.hidden) stopGame();
  else if (activeGame) startGame(activeGame);
});

// Dừng khi rời trang
window.addEventListener("beforeunload", stopGame);

  // ==============================
  // Likes & Comments (Supabase RPC)
  // ==============================
  function initSocialHandlers() {
    // Global overlay controller (single instance handlers)
    const overlay = document.getElementById('commentsOverlay')
    const listEl = document.getElementById('commentsList')
    const loadMoreBtn = document.getElementById('commentsLoadMore')
    const closeBtn = document.getElementById('commentsCloseBtn')
    const ta = document.getElementById('commentsTextarea')
    const postBtn = document.getElementById('commentsPostBtn')

    const paging = { gameId: null, offset: 0, limit: 10, loading: false, done: false }
    function shortAddr10(addr){ if(!addr) return ''; return addr.slice(0,6) + '…' + addr.slice(-3) }
    async function fetchMore(){
      if (paging.loading || paging.done || !paging.gameId) return
      paging.loading = true
      try {
        const { data, error } = await supabase.rpc('list_comments', {
          p_game_id: paging.gameId,
          p_limit: paging.limit,
          p_offset: paging.offset
        })
        if (error) throw error
        const rows = Array.isArray(data) ? data : []
        if (rows.length === 0) { paging.done = true; return }
        rows.forEach(r => {
          const item = document.createElement('div')
          item.className = 'comment-item'
          const meta = document.createElement('div')
          meta.className = 'comment-meta'
          const when = new Date(r.created_at).toLocaleString()
          meta.textContent = `${shortAddr10(r.user_id)} • ${when}`
          const text = document.createElement('div')
          text.className = 'comment-text'
          text.textContent = r.text
          item.appendChild(meta)
          item.appendChild(text)
          listEl.appendChild(item)
        })
        paging.offset += rows.length
      } catch(e){
        console.error('list_comments error:', e?.message || e)
      } finally { paging.loading = false }
    }
    function openPanel(forGame){
      paging.gameId = forGame
      paging.offset = 0
      paging.loading = false
      paging.done = false
      listEl.innerHTML = ''
      ta.value = ''
      overlay.classList.add('open')
      fetchMore()
    }
    loadMoreBtn.onclick = fetchMore
    closeBtn.onclick = () => overlay.classList.remove('open')
    postBtn.onclick = async () => {
      const text = (ta.value || '').trim()
      if (!text || !paging.gameId) return
      postBtn.disabled = true
      try {
        const { data, error } = await supabase.rpc('add_comment', {
      p_user_id: userId,
          p_game_id: paging.gameId,
          p_text: text
        })
        if (error) throw error
        const item = document.createElement('div')
        item.className = 'comment-item'
        const meta = document.createElement('div')
        meta.className = 'comment-meta'
        meta.textContent = `${shortAddr10(userId)} • just now`
        const body = document.createElement('div')
        body.className = 'comment-text'
        body.textContent = text
        item.appendChild(meta)
        item.appendChild(body)
        listEl.prepend(item)
        ta.value = ''
      } catch(e){
        console.error('add_comment error:', e?.message || e)
      } finally { postBtn.disabled = false }
    }

    const cards = document.querySelectorAll('.game-card')
    cards.forEach(card => {
      const gameId = card.getAttribute('data-game-id') || card.id
      if (!gameId) return

      const likeWrapper = card.querySelector('.icon-wrapper[data-role="like"]')
      const commentWrapper = card.querySelector('.icon-wrapper[data-role="comment"]')
      const shareWrapper = card.querySelector('.icon-wrapper[data-role="share"]')
      const leaderboardWrapper = card.querySelector('.icon-wrapper[data-role="leaderboard"]')
      const marketcapWrapper = card.querySelector('.icon-wrapper[data-role="marketcap"]')

      const likeBtn = likeWrapper?.querySelector('button')
      const commentBtn = commentWrapper?.querySelector('button')
      const shareBtn = shareWrapper?.querySelector('button')
      const leaderboardBtn = leaderboardWrapper?.querySelector('button')
      const marketcapBtn = marketcapWrapper?.querySelector('button')

      if (!likeBtn || !commentBtn) return

      const ensureCountEl = (wrapper, selector, fallback = '0') => {
        if (!wrapper) return null
        const existing = wrapper.querySelector(selector)
        if (existing) return existing
        const span = document.createElement('span')
        span.className = 'icon-count'
        span.textContent = fallback
        wrapper.appendChild(span)
        return span
      }

      const likeCountEl = ensureCountEl(likeWrapper, '.icon-count')
      const cmtCountEl = ensureCountEl(commentWrapper, '.icon-count')

      function setCounts(likes, comments) {
        if (likeCountEl) likeCountEl.textContent = String(Math.max(0, likes|0))
        if (cmtCountEl) cmtCountEl.textContent = String(Math.max(0, comments|0))
      }
      function renderHeart(isLiked) {
        const wrapper = likeBtn.closest('.icon-wrapper')
        if (wrapper) wrapper.classList.toggle('liked', !!isLiked)
        likeBtn.setAttribute('aria-pressed', isLiked ? 'true' : 'false')
      }
      ;(async () => {
        try {
          const { data, error } = await supabase.rpc('get_social_counts', { p_game_id: gameId })
          if (!error && data) {
            setCounts(data.likes ?? 0, data.comments ?? 0)
          }
        } catch {}
      })()
      const liked = localStorage.getItem('mp_like_' + gameId) === '1'
      renderHeart(liked)
      likeBtn.addEventListener('click', async () => {
        likeBtn.disabled = true
        try {
          const { data, error } = await supabase.rpc('toggle_like', {
            p_user_id: userId,
            p_game_id: gameId
          })
          if (error) throw error
          const isLiked = !!(data && (data.is_liked ?? data.liked))
          renderHeart(isLiked)
          localStorage.setItem('mp_like_' + gameId, isLiked ? '1' : '0')
          const likes = (data && (data.total_likes ?? data.likes))
          if (likes != null) {
            const currentComments = cmtCountEl ? Number(cmtCountEl.textContent) || 0 : 0
            setCounts(likes, currentComments)
          }
        } catch (e) {
          console.error('toggle_like error:', e?.message || e)
        } finally {
          likeBtn.disabled = false
        }
      })
      commentBtn.addEventListener('click', () => openPanel(gameId))
      if (marketcapBtn) {
        marketcapBtn.addEventListener('click', () => {
          console.log('Market Cap clicked for', gameId)
          // TODO: Show market cap overlay/link for game token
        })
      }
      if (shareBtn) {
        shareBtn.addEventListener('click', () => {
          openShareOverlay(gameId)
        })
      }
      if (leaderboardBtn) {
        leaderboardBtn.addEventListener('click', () => {
          if (typeof window.__openLeaderboardOverlay === 'function') {
            window.__openLeaderboardOverlay(gameId)
          }
        })
      }
    })
  }
  initSocialHandlers()

  // Listen for game scores via postMessage
  window.addEventListener('message', async (event) => {
    // DEBUG: Log ALL messages to see what's being received
    console.log('📨 [DEBUG] Parent received message:', event.data, 'from origin:', event.origin);
    
    if (event.data?.type === 'GAME_SCORE') {
      const { gameId, score } = event.data
      if (!gameId || !score || score <= 0) return
      
      // Convert to integer (round down for fairness)
      const finalScore = Math.floor(Number(score))
      
      console.log(`📊 Received score: ${score} → ${finalScore} for ${gameId}`)
      
      try {
        const { data, error } = await supabase.rpc('submit_game_score', {
          p_user_id: userId,
          p_game_id: gameId,
          p_score: finalScore
        })
        
        if (error) throw error
        
        if (data?.is_new_best) {
          console.log(`🏆 New high score! Rank #${data.user_rank}/${data.total_players}`)
          // TODO: Show toast/animation "New Best!"
        } else {
          console.log(`✓ Score submitted. Best: ${data.best_score}, Rank: #${data.user_rank}`)
        }
      } catch (err) {
        console.error('Submit score error:', err)
      }
    }
  })

  // Format count helper (1K, 10.5K, 1.2M)
  function formatCount(num) {
    const n = Number(num) || 0
    if (n >= 1000000) return (n / 1000000).toFixed(1).replace(/\.0$/, '') + 'M'
    if (n >= 1000) return (n / 1000).toFixed(1).replace(/\.0$/, '') + 'K'
    return String(n)
  }

  function shortAddrLeaderboard(addr) {
    if (!addr || addr.length <= 10) return addr || 'Anonymous'
    return addr.slice(0, 6) + '…' + addr.slice(-4)
  }

  // Format score based on game type
  function formatScore(score, gameId) {
    const num = Number(score) || 0;
    
    // Wojak game shows percentage
    if (gameId === 'wojak-btc-blast') {
      return num + '%';
    }
    
    // Other games use normal format (1K, 1M...)
    return formatCount(num);
  }

  function setLeaderboardActivePanel(panel) {
    const overlay = document.getElementById('leaderboardOverlay')
    if (!overlay) return
    const tabs = overlay.querySelectorAll('.leaderboard-tab')
    const scoresPanel = document.getElementById('leaderboardPanelScores')
    const rewardsPanel = document.getElementById('leaderboardPanelRewards')

    const target = panel === 'rewards' ? 'rewards' : 'scores'
    tabs.forEach(btn => {
      const isActive = btn.dataset.panel === target
      btn.classList.toggle('active', isActive)
    })
    scoresPanel?.classList.toggle('active', target === 'scores')
    rewardsPanel?.classList.toggle('active', target === 'rewards')
    overlay.dataset.activePanel = target
  }

  function renderRewardsPanel(gameId) {
    const summaryEl = document.getElementById('leaderboardRewardSummary')
    const listEl = document.getElementById('leaderboardRewardList')
    if (!summaryEl || !listEl) return

    const awardedMap = getGameAwards(gameId)
    const totalSeconds = getGameSeconds(gameId)
    const achievements = [
      { threshold: 10, name: 'Starter', reward: 100 },
      { threshold: 60, name: 'Engaged', reward: 300 },
      { threshold: 300, name: 'Champion', reward: 1000 }
    ]

    const progress = Math.min(100, (totalSeconds / 300) * 100)
    summaryEl.innerHTML = `
      <div style="font-size:18px;">Total Playtime</div>
      <div class="reward-total">${totalSeconds}s / 300s</div>
      <div class="leaderboard-reward-progress"><span style="width:${progress}%"></span></div>
      <div style="margin-top:6px;font-size:13px;color:#a9b1c4;">Play more to unlock bonus PLAY rewards</div>
    `

    listEl.innerHTML = ''
    achievements.forEach(ach => {
      const unlocked = awardedMap[ach.threshold] || totalSeconds >= ach.threshold
      const secondsLeft = Math.max(0, ach.threshold - totalSeconds)
      const card = document.createElement('div')
      card.className = 'leaderboard-reward-card' + (unlocked ? ' unlocked' : '')
      card.innerHTML = `
        <div style="flex:1;">
          <div class="reward-name">${unlocked ? '✅' : '🔒'} ${ach.name}</div>
          <div class="reward-status">${unlocked ? 'Unlocked!' : `${secondsLeft}s remaining`}</div>
        </div>
        <div class="reward-amount">+${ach.reward}</div>
      `
      listEl.appendChild(card)
    })
  }

  async function openLeaderboardOverlay(gameId) {
    const overlay = document.getElementById('leaderboardOverlay')
    const list = document.getElementById('leaderboardList')
    const rewardSummary = document.getElementById('leaderboardRewardSummary')
    const rewardList = document.getElementById('leaderboardRewardList')
    if (!overlay || !list || !rewardSummary || !rewardList) return

    overlay.dataset.gameId = gameId
    setLeaderboardActivePanel('scores')
    renderRewardsPanel(gameId)

    list.innerHTML = '<div style="padding:24px;text-align:center;color:#bbb;">Loading...</div>'
    overlay.classList.add('open')

    try {
      const { data, error } = await supabase.rpc('get_game_leaderboard_with_user', {
        p_game_id: gameId,
        p_user_id: userId,
        p_limit: 100
      })

      if (error) throw error

      list.innerHTML = ''

      const userEntry = data?.current_user
      if (userEntry) {
        const userItem = document.createElement('div')
        userItem.className = 'leaderboard-item user-highlight'
        userItem.innerHTML = `
          <div class="leaderboard-rank">${userEntry.rank ? '#' + userEntry.rank : '-'}</div>
          <div class="leaderboard-user">You</div>
          <div class="leaderboard-score">${formatScore(userEntry.best_score, gameId)}</div>
        `
        list.appendChild(userItem)
      }

      const divider = document.createElement('div')
      divider.className = 'leaderboard-divider'
      divider.textContent = 'Top 100 Players'
      list.appendChild(divider)

      const topPlayers = data?.top_players || []
      if (topPlayers.length === 0) {
        const empty = document.createElement('div')
        empty.style.cssText = 'padding:24px;text-align:center;color:#888;'
        empty.textContent = 'No scores yet. Be the first!'
        list.appendChild(empty)
        return
      }

      topPlayers.forEach(player => {
        const item = document.createElement('div')
        item.className = 'leaderboard-item'
        if (player.user_id === userId) {
          item.classList.add('is-current-user')
        }

        let rankDisplay = `#${player.rank}`
        if (player.rank === 1) rankDisplay = '🥇'
        else if (player.rank === 2) rankDisplay = '🥈'
        else if (player.rank === 3) rankDisplay = '🥉'

        item.innerHTML = `
          <div class="leaderboard-rank">${rankDisplay}</div>
          <div class="leaderboard-user">${shortAddrLeaderboard(player.user_id)}</div>
          <div class="leaderboard-score">${formatScore(player.best_score, gameId)}</div>
        `
        list.appendChild(item)
      })
    } catch (err) {
      console.error('Leaderboard error:', err)
      list.innerHTML = '<div style="padding:24px;text-align:center;color:#f88;">Failed to load leaderboard</div>'
    }
  }

  ;(function initLeaderboardOverlay(){
    const overlay = document.getElementById('leaderboardOverlay')
    if (!overlay) return
    const closeBtn = document.getElementById('leaderboardCloseBtn')
    const tabButtons = overlay.querySelectorAll('.leaderboard-tab')

    if (!overlay.dataset.activePanel) overlay.dataset.activePanel = 'scores'

    function closeLeaderboardOverlay() {
      overlay.classList.remove('open')
    }

    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const panel = btn.dataset.panel
        if (panel) setLeaderboardActivePanel(panel)
      })
    })

    closeBtn?.addEventListener('click', closeLeaderboardOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeLeaderboardOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeLeaderboardOverlay()
    })

    window.__openLeaderboardOverlay = openLeaderboardOverlay
    window.__closeLeaderboardOverlay = closeLeaderboardOverlay
  })()

  // Share Modal Logic
  let currentShareGameId = null
  
  function openShareOverlay(gameId) {
    currentShareGameId = gameId
    const overlay = document.getElementById('shareOverlay')
    if (overlay) overlay.classList.add('open')
  }

  ;(function initShareOverlay(){
    const overlay = document.getElementById('shareOverlay')
    if (!overlay) return
    
    const closeBtn = document.getElementById('shareCloseBtn')
    const copyBtn = document.getElementById('shareCopyBtn')
    const telegramBtn = document.getElementById('shareTelegramBtn')
    const xBtn = document.getElementById('shareXBtn')

    function closeShareOverlay() {
      overlay.classList.remove('open')
    }

    // Close handlers
    closeBtn?.addEventListener('click', closeShareOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeShareOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeShareOverlay()
    })

    // Copy Link Button
    copyBtn?.addEventListener('click', async () => {
      const shareUrl = `${window.location.origin}${window.location.pathname}#${currentShareGameId}`
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(shareUrl)
          const originalHTML = copyBtn.innerHTML
          copyBtn.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            <span>✓ Copied!</span>
          `
          setTimeout(() => {
            copyBtn.innerHTML = originalHTML
          }, 2000)
        }
      } catch (err) {
        console.error('Copy failed:', err)
      }
    })

    // Telegram Button
    telegramBtn?.addEventListener('click', () => {
      const shareUrl = `${window.location.origin}${window.location.pathname}#${currentShareGameId}`
      const text = `🎮 Check out this awesome game on MemePlay Arcade! Play and earn PLAY points! 🚀`
      const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(text)}`
      window.open(telegramUrl, '_blank')
      closeShareOverlay()
    })

    // X/Twitter Button
    xBtn?.addEventListener('click', () => {
      const shareUrl = `${window.location.origin}${window.location.pathname}#${currentShareGameId}`
      const text = `🎮 Just played an awesome game on MemePlay! Play & earn PLAY points! 🚀`
      const xUrl = `https://twitter.com/intent/tweet?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(text)}`
      window.open(xUrl, '_blank')
      closeShareOverlay()
    })
  })()

  ;(function initStatsOverlay(){
    const overlay = document.getElementById('statsOverlay')
    if (!overlay) return
    const closeBtn = document.getElementById('statsCloseBtn')
    const streakEl = document.getElementById('statsStreak')
    const playsEl = document.getElementById('statsPlays')

    function updateStatsOverlay() {
      const streakSource = document.getElementById('streakCount')
      const playsSource = document.getElementById('headerEarned')
      if (streakSource) streakEl.textContent = streakSource.textContent || '0'
      if (playsSource) playsEl.textContent = playsSource.textContent || '0'
    }

    function openStatsOverlay() {
      updateStatsOverlay()
      overlay.classList.add('open')
    }

    function closeStatsOverlay() {
      overlay.classList.remove('open')
    }

    closeBtn?.addEventListener('click', closeStatsOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeStatsOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeStatsOverlay()
    })

    window.__openStatsOverlay = openStatsOverlay
    window.__updateStatsOverlay = updateStatsOverlay
  })()
 
   
  </script>

  <!-- Global helpers shim (non-module) to guarantee console access -->
  <script>
    (function installMemeplayShim(){
      function lsGetInt(key){
        const raw = localStorage.getItem(key);
        const num = raw == null ? NaN : Number(raw);
        return Number.isFinite(num) ? num : 0;
      }
      function getIds(){
        return Array.from(document.querySelectorAll('.game-card')).map(c => c.getAttribute('data-game-id') || c.id || 'unknown');
      }
      const shim = {
        getGameSeconds: function(gameId){ return lsGetInt('mp_game_seconds_' + gameId); },
        listAllGameSeconds: function(){
          const rows = getIds().map(id => ({ gameId: id, seconds: lsGetInt('mp_game_seconds_' + id) }));
          try { console.table(rows); } catch {}
          return rows;
        },
        resetGameProgress: function(gameId){
          if (!gameId) return false;
          localStorage.setItem('mp_game_seconds_' + gameId, '0');
          localStorage.removeItem('mp_game_awards_' + gameId);
          console.log('🔄 Reset progress for', gameId);
          return true;
        },
        startGame: function(gameId){
          try { if (window.memeplay && window.memeplay.startGame) return window.memeplay.startGame(gameId); } catch {}
          console.warn('startGame bridge: module not ready');
        },
        stopGame: function(){
          try { if (window.memeplay && window.memeplay.stopGame) return window.memeplay.stopGame(); } catch {}
          console.warn('stopGame bridge: module not ready');
        }
      };
      try { window.memeplay = Object.assign({}, shim, window.memeplay || {}); } catch {}
      try { self.memeplay = window.memeplay; } catch {}
      try { globalThis.memeplay = window.memeplay; } catch {}
      console.log('🧩 memeplay console shim ready');
    })();
  </script>

  <!-- Desktop scroll: Chuyển scroll từ toàn trang vào .game-container với scroll-snap -->
  <script>
    (function enableDesktopScroll(){
      const gameContainer = document.querySelector('.game-container');
      if (!gameContainer) return;
      
      // Chuyển wheel events từ document vào .game-container
      document.addEventListener('wheel', (e) => {
        // Chỉ xử lý scroll dọc
        if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
          const target = e.target;
          // Kiểm tra xem click có trong .game-container không
          const isInGameContainer = gameContainer.contains(target) || 
                                    target.closest('.game-card') ||
                                    target.closest('.game-container') ||
                                    target.closest('.main-header');
          
          // Nếu click ra ngoài game-container (vùng đen), redirect scroll vào .game-container
          if (!isInGameContainer) {
            e.preventDefault();
            e.stopPropagation();
            
            // Scroll với tốc độ mượt hơn, đảm bảo scroll xuống hoạt động
            const scrollAmount = Math.abs(e.deltaY) * 1.2; // Tăng tốc độ scroll một chút
            const scrollDirection = e.deltaY > 0 ? 1 : -1; // Xuống = 1, Lên = -1
            
            // Sử dụng scrollBy để trigger scroll-snap tự nhiên
            gameContainer.scrollBy({
              top: scrollAmount * scrollDirection,
              behavior: 'auto' // 'auto' để scroll-snap hoạt động
            });
            
            // Sau khi scroll, tự động snap vào game card gần nhất ở center
            clearTimeout(gameContainer._snapTimeout);
            gameContainer._snapTimeout = setTimeout(() => {
              const cards = Array.from(document.querySelectorAll('.game-card'));
              if (!cards.length) return;
              
              const containerTop = gameContainer.scrollTop;
              const containerHeight = gameContainer.clientHeight;
              const viewportCenter = containerTop + containerHeight / 2;
              
              let bestCard = null;
              let bestDistance = Infinity;
              
              cards.forEach(card => {
                const cardTop = card.offsetTop - gameContainer.offsetTop;
                const cardHeight = card.offsetHeight;
                const cardCenter = cardTop + cardHeight / 2;
                const distance = Math.abs(cardCenter - viewportCenter);
                
                if (distance < bestDistance) {
                  bestDistance = distance;
                  bestCard = card;
                }
              });
              
              // Nếu card gần nhất chưa ở center, scroll đến center chính xác của nó + offset 5% xuống
              if (bestCard && bestDistance > 30) {
                const cardTop = bestCard.offsetTop - gameContainer.offsetTop;
                const cardHeight = bestCard.offsetHeight;
                const cardCenter = cardTop + cardHeight / 2;
                // Tính scroll position: center - 5% viewport xuống = center + 5% containerHeight
                const offsetDown = containerHeight * 0.05; // 5% xuống
                const targetScroll = Math.max(0, cardCenter - containerHeight / 2 - offsetDown);
                
                gameContainer.scrollTo({
                  top: targetScroll,
                  behavior: 'smooth'
                });
              }
            }, 150); // Debounce để không snap quá nhiều lần
          }
        }
      }, { passive: false });
      
      // Xử lý keyboard scroll (Space, Arrow keys) với scroll-snap
      document.addEventListener('keydown', (e) => {
        // Chỉ xử lý khi focus không nằm trong input/textarea
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        const key = e.key;
        if (key === ' ' || key === 'ArrowDown' || key === 'ArrowUp' || key === 'PageDown' || key === 'PageUp') {
          e.preventDefault();
          
          // Tìm game card hiện tại và scroll đến game tiếp theo/trước đó
          const cards = Array.from(document.querySelectorAll('.game-card'));
          if (!cards.length) return;
          
          let currentIndex = 0;
          const containerTop = gameContainer.scrollTop;
          const containerHeight = gameContainer.clientHeight;
          
          // Tìm game card đang hiển thị (chiếm >50% viewport)
          for (let i = 0; i < cards.length; i++) {
            const card = cards[i];
            const cardTop = card.offsetTop - gameContainer.offsetTop;
            const cardBottom = cardTop + card.offsetHeight;
            const viewportTop = containerTop;
            const viewportBottom = containerTop + containerHeight;
            
            // Nếu card chiếm >50% viewport
            const visibleTop = Math.max(cardTop, viewportTop);
            const visibleBottom = Math.min(cardBottom, viewportBottom);
            const visibleHeight = visibleBottom - visibleTop;
            
            if (visibleHeight > containerHeight * 0.5) {
              currentIndex = i;
              break;
            }
          }
          
          // Xác định game tiếp theo/trước đó
          let nextIndex = currentIndex;
          if (key === 'ArrowDown' || key === ' ' || key === 'PageDown') {
            nextIndex = (currentIndex + 1) % cards.length;
          } else if (key === 'ArrowUp' || key === 'PageUp') {
            nextIndex = (currentIndex - 1 + cards.length) % cards.length;
          }
          
          // Scroll đến center của game card + offset 5% xuống để game xuất hiện thấp hơn một chút
          if (cards[nextIndex]) {
            const card = cards[nextIndex];
            const cardTop = card.offsetTop - gameContainer.offsetTop;
            const cardHeight = card.offsetHeight;
            const containerHeight = gameContainer.clientHeight;
            const cardCenter = cardTop + cardHeight / 2;
            // Tính scroll position: center - 5% viewport xuống = center + 5% containerHeight
            const offsetDown = containerHeight * 0.05; // 5% xuống
            const targetScroll = Math.max(0, cardCenter - containerHeight / 2 - offsetDown);
            
            gameContainer.scrollTo({
              top: targetScroll,
              behavior: 'smooth'
            });
          }
        }
      });
    })();
  </script>

  <!-- Swipe navigation: up/down moves to next/prev game (loops) -->
  <script>
    (function swipeNavigation(){
      const sc = document.querySelector('.game-container');
      const cards = Array.from(document.querySelectorAll('.game-card'));
      if (!cards.length) return;

      let tops = [];
      function recalc(){
        tops = cards.map(el => el.offsetTop);
      }
      function currentIndex(){
        const y = sc.scrollTop + sc.clientHeight * 0.25; // focus upper quarter
        let best = 0, bestDiff = Infinity;
        for (let i=0;i<tops.length;i++){
          const d = Math.abs(tops[i]-y);
          if (d < bestDiff){ best = i; bestDiff = d; }
        }
        return best;
      }
      function scrollToIndex(i){
        const n = cards.length;
        const idx = ((i % n) + n) % n; // safe modulo
        const y = tops[idx] ?? 0;
        sc.scrollTo({ top: y, behavior: 'smooth' });
      }

      recalc();
      window.addEventListener('resize', recalc, { passive: true });
      window.addEventListener('orientationchange', recalc, { passive: true });

      let startY = 0, startT = 0, moved = false;
      const THRESHOLD = 60; // px
      const VELOCITY = 0.35; // px/ms

      sc.addEventListener('touchstart', (e) => {
        if (!e.touches || !e.touches.length) return;
        startY = e.touches[0].clientY; startT = performance.now(); moved = false;
      }, { passive: true });

      sc.addEventListener('touchmove', (e) => {
        moved = true;
      }, { passive: true });

      sc.addEventListener('touchend', (e) => {
        if (!moved) return;
        const endY = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY : startY;
        const dy = endY - startY; // down = positive
        const dt = Math.max(1, performance.now() - startT);
        const v = Math.abs(dy) / dt;
        if (Math.abs(dy) < THRESHOLD && v < VELOCITY) return; // ignore tiny swipes

        const cur = currentIndex();
        if (dy < 0) scrollToIndex(cur + 1); // swipe up -> next
        else scrollToIndex(cur - 1);        // swipe down -> prev
      }, { passive: true });

      // Force snap to nearest after inertial scrolling stops (prevents resting between cards)
      let snapTimer = null;
      sc.addEventListener('scroll', () => {
        if (snapTimer) clearTimeout(snapTimer);
        snapTimer = setTimeout(() => {
          recalc();
          const idx = currentIndex();
          scrollToIndex(idx);
        }, 120);
      }, { passive: true });
    })();
  </script>

  <script>
    ;(function initWalletOverlay(){
      const overlay = document.getElementById('walletOverlay')
      if (!overlay) return
      const closeBtn = document.getElementById('walletCloseBtn')
      const copyBtn = document.getElementById('walletCopyBtn')
      const disconnectBtn = document.getElementById('walletDisconnectBtn')
      const addressEl = document.getElementById('walletOverlayAddress')
      const streakEl = document.getElementById('walletOverlayStreak')
      const playsEl = document.getElementById('walletOverlayPlays')

      function updateWalletOverlay() {
        const api = globalThis.memeplayWallet || {}
        const address = api.getAddress?.() || ''
        addressEl.textContent = address ? address : 'Not connected'
        const streak = api.getStreak?.()
        const plays = api.getPlayPoints?.()
        streakEl.textContent = String(Number.isFinite(streak) ? streak : 0)
        playsEl.textContent = String(Number.isFinite(plays) ? plays : 0)
      }

      function openWalletOverlay() {
        updateWalletOverlay()
        overlay.classList.add('open')
      }

      function closeWalletOverlay() {
        overlay.classList.remove('open')
      }

      closeBtn?.addEventListener('click', closeWalletOverlay)
      overlay.addEventListener('click', (event) => {
        if (event.target === overlay) closeWalletOverlay()
      })
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && overlay.classList.contains('open')) closeWalletOverlay()
      })

      copyBtn?.addEventListener('click', async () => {
        const api = globalThis.memeplayWallet || {}
        const address = api.getAddress?.() || ''
        if (!address) return
        try {
          await navigator.clipboard.writeText(address)
          copyBtn.textContent = 'Copied!'
          setTimeout(() => { copyBtn.textContent = 'Copy address' }, 1500)
        } catch (err) {
          console.warn('Clipboard copy failed', err)
          copyBtn.textContent = 'Copy failed'
          setTimeout(() => { copyBtn.textContent = 'Copy address' }, 1500)
        }
      })

      disconnectBtn?.addEventListener('click', () => {
        const api = globalThis.memeplayWallet || {}
        api.disconnect?.()
        closeWalletOverlay()
      })

      window.__openWalletOverlay = openWalletOverlay
    window.__updateWalletOverlay = updateWalletOverlay
  })()

  ;(function initCreatorOverlay(){
    const overlay = document.getElementById('creatorOverlay')
    if (!overlay) return
    const closeBtn = document.getElementById('creatorCloseBtn')

    function openCreatorOverlay() {
      overlay.classList.add('open')
    }

    function closeCreatorOverlay() {
      overlay.classList.remove('open')
    }

    closeBtn?.addEventListener('click', closeCreatorOverlay)
    overlay.addEventListener('click', (event) => {
      if (event.target === overlay) closeCreatorOverlay()
    })
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && overlay.classList.contains('open')) closeCreatorOverlay()
    })

    window.__openCreatorOverlay = openCreatorOverlay
    window.__closeCreatorOverlay = closeCreatorOverlay
  })()

  // ==========================================
  // MARKET CAP - 4meme Integration
  // ==========================================
  setTimeout(() => {
    console.log('🚀 MC script start')
    
    if (!window.ethers) return console.error('❌ No ethers.js')
    console.log('✅ Ethers OK')
    
    const TOKEN = '0x2685ba9d4c0386f9982169920435ddc97aa34444'
    const HELPER = '0xF251F83e40a78868FcfA3FA4599Dad6494E46034'
    
    function fmt(n) {
      if (!n) return '--'
      if (n >= 1e9) return (n/1e9).toFixed(1)+'B'
      if (n >= 1e6) return (n/1e6).toFixed(1)+'M'
      if (n >= 1e3) return (n/1e3).toFixed(1)+'K'
      return n.toFixed(0)
    }
    
    // Get BNB price
    async function getBNB() {
      try {
        const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=binancecoin&vs_currencies=usd')
        const data = await res.json()
        return data.binancecoin?.usd || 600
      } catch {
        return 600
      }
    }
    
    async function update(id) {
      const btn = document.querySelector(`#${id} [data-role="marketcap"] button span`)
      if (!btn) return console.log(`[MC] No span: ${id}`)
      
      const wrap = document.querySelector(`#${id} [data-role="marketcap"] button`)
      btn.textContent = 'MC ...'
      
      try {
        // Init provider & contract
        const p = new ethers.providers.JsonRpcProvider('https://bsc-dataseed.binance.org/')
        const h = new ethers.Contract(HELPER, ['function getTokenInfo(address) view returns (uint256,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool)'], p)
        
        // Get token info
        const info = await h.getTokenInfo(TOKEN)
        const graduated = info[11] // liquidityAdded
        
        let mc = 0
        
        if (graduated) {
          // CASE 1: Đã lên PancakeSwap → DexScreener
          console.log(`[MC] ${id} graduated → DexScreener`)
          
          const dex = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${TOKEN}`)
          const dexData = await dex.json()
          
          if (dexData.pairs && dexData.pairs.length > 0) {
            mc = dexData.pairs[0].fdv || dexData.pairs[0].marketCap || 0
            console.log(`✅ [MC] ${id}: $${fmt(mc)} (DexScreener)`)
          } else {
            throw new Error('No DEX data')
          }
          
        } else {
          // CASE 2: Bonding curve → 4meme contract
          console.log(`[MC] ${id} bonding curve → 4meme contract`)
          
          const bnb = await getBNB()
          const priceBNB = Number(info[3]) / 1e18
          const priceUSD = priceBNB * bnb
          mc = priceUSD * 1e9
          
          console.log(`✅ [MC] ${id}: $${fmt(mc)} (4meme contract)`)
        }
        
        // Update UI
        btn.textContent = `MC ${fmt(mc)}`
        wrap.style.cursor = 'pointer'
        wrap.onclick = () => window.open(`https://four.meme/token/${TOKEN}`, '_blank')
        wrap.title = `$${mc.toLocaleString()}`
        mcCache[id] = mc // Cache kết quả
        
      } catch (e) {
        console.error(`❌ [MC] ${id}:`, e)
        btn.textContent = 'MC --'
        mcCache[id] = 'error' // Cache error để không retry
      }
    }
    
    // Cache để không fetch lại
    const mcCache = {}
    const mcLoading = {}
    
    // Lazy load MC khi game visible VÀ iframe loaded
    const mcObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
          const gameId = entry.target.id
          
          // Check iframe đã load chưa
          const iframe = entry.target.querySelector('iframe')
          const iframeLoaded = iframe && iframe.src && !iframe.src.includes('about:blank')
          
          if (iframeLoaded && !mcCache[gameId] && !mcLoading[gameId]) {
            // Đợi thêm 2s để game ổn định, MỚI fetch MC
            setTimeout(() => {
              mcLoading[gameId] = true
              console.log(`[MC] Loading for game (iframe ready): ${gameId}`)
              update(gameId)
            }, 2000)
          }
        }
      })
    }, { 
      threshold: 0.5, // Tăng từ 0.3 → 0.5 (visible 50%)
      rootMargin: '0px' // Bỏ preload, chỉ fetch khi thực sự visible
    })
    
    // Đợi 5s sau khi page load, bắt đầu observe
    setTimeout(() => {
      console.log('[MC] Starting lazy load observer (after 5s delay)')
      document.querySelectorAll('.game-card').forEach(card => {
        mcObserver.observe(card)
      })
    }, 5000)
    
    // Manual trigger
    window.__updateMC = () => {
      update('bird-squash')
      update('wojak-btc-blast')
      update('moonshot-bnb')
      update('valley-explorer-3d')
      update('hodl-tower-stack')
    }
  }, 5000)
  
  </script>
</body>
</html>