<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Avatar Metadata API</title>
  <script type="module">
    // Avatar Metadata API Endpoint
    // Returns ERC721 metadata JSON for NFT tokens
    // Usage: /avatar-system/api/avatar-metadata.html?tokenId=0

    import { CONTRACT_ADDRESS, CONTRACT_ABI } from '../src/contract-address.js';

    // Get URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const tokenId = urlParams.get('tokenId');

    // Avatar config mapping
    const AVATAR_CONFIG = {
      actors: {
        boy: { name: 'Boy', letter: 'a' },
        fish: { name: 'Fish', letter: 'b' },
        supergirl: { name: 'Super Girl', letter: 'c' }
      },
      clothes: ['None', 'Outfit 1', 'Outfit 2', 'Outfit 3', 'Outfit 4'],
      equipment: ['None', 'Weapon 1', 'Weapon 2', 'Weapon 3', 'Weapon 4', 'Weapon 5'],
      hat: ['None', 'Hat 1', 'Hat 2', 'Hat 3', 'Hat 4']
    };

    // Get avatar file path from config
    function getAvatarFilePath(config) {
      const actorData = AVATAR_CONFIG.actors[config.actor];
      if (!actorData) {
        // Default to boy if actor not found
        return 'avatar-system/assets/avatars/a000.png';
      }
      const skinLetter = actorData.letter;
      const clothes = config.clothes || 0;
      const equipment = config.equipment || 0;
      const hat = config.hat || 0;
      
      return `avatar-system/assets/avatars/${skinLetter}${clothes}${equipment}${hat}.png`;
    }

    // Parse config from hash string (reverse the hash generation)
    // This is a simplified approach - hash is not fully reversible
    // In production, should store config in contract or database
    function parseConfigFromHash(hash) {
      // Default config
      return {
        actor: 'boy',
        skin: 1,
        clothes: 0,
        equipment: 0,
        hat: 0
      };
    }

    // Generate metadata JSON
    function generateMetadata(tokenId, configHash, config = null) {
      if (!config) {
        config = parseConfigFromHash(configHash);
      }

      const actorData = AVATAR_CONFIG.actors[config.actor] || AVATAR_CONFIG.actors.boy;
      const imageUrl = getAvatarFilePath(config);
      const baseUrl = window.location.origin;
      const fullImageUrl = `${baseUrl}/${imageUrl}`;

      const name = `MemePlay Avatar #${tokenId}`;
      const description = `A unique MemePlay avatar with ${actorData.name} actor, ${AVATAR_CONFIG.clothes[config.clothes]}, ${AVATAR_CONFIG.equipment[config.equipment]}, and ${AVATAR_CONFIG.hat[config.hat]}.`;

      const attributes = [
        { trait_type: 'Actor', value: actorData.name },
        { trait_type: 'Clothes', value: AVATAR_CONFIG.clothes[config.clothes] },
        { trait_type: 'Equipment', value: AVATAR_CONFIG.equipment[config.equipment] },
        { trait_type: 'Hat', value: AVATAR_CONFIG.hat[config.hat] },
        { trait_type: 'Config Hash', value: configHash }
      ];

      return {
        name: name,
        description: description,
        image: fullImageUrl,
        external_url: `${baseUrl}/avatar-creator`,
        attributes: attributes
      };
    }

    // Load ethers.js
    async function loadEthers() {
      if (window.ethers) {
        return Promise.resolve();
      }

      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js';
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('Failed to load ethers.js'));
        document.head.appendChild(script);
      });
    }

    // Get configHash from contract
    async function getConfigHashFromContract(tokenId) {
      try {
        await loadEthers();
        
        // Use public RPC if no ethereum provider
        const rpcUrl = 'https://sepolia.base.org';
        const provider = new window.ethers.providers.JsonRpcProvider(rpcUrl);
        
        const contract = new window.ethers.Contract(
          CONTRACT_ADDRESS,
          CONTRACT_ABI,
          provider
        );
        
        const configHash = await contract.getConfigHash(tokenId);
        return configHash;
      } catch (error) {
        console.warn('Could not fetch configHash from contract:', error);
        return null;
      }
    }

    // Get config from localStorage (stored when minting)
    function getConfigFromStorage(tokenId, configHash) {
      try {
        // Try to get from token configs
        const tokenConfigs = localStorage.getItem('mp_avatar_token_configs');
        if (tokenConfigs) {
          const configs = JSON.parse(tokenConfigs);
          const tokenConfig = configs[tokenId];
          if (tokenConfig && tokenConfig.config) {
            return tokenConfig.config;
          }
        }
        
        // Try to get from configHash
        const configs = localStorage.getItem('mp_avatar_configs');
        if (configs) {
          const configMap = JSON.parse(configs);
          if (configMap[configHash]) {
            return configMap[configHash];
          }
        }
        
        return null;
      } catch (error) {
        console.warn('Get config from storage error:', error);
        return null;
      }
    }

    // Main handler
    async function handleRequest() {
      const tokenIdParam = tokenId || '0';
      const tokenIdNum = parseInt(tokenIdParam, 10);

      if (isNaN(tokenIdNum)) {
        throw new Error('Invalid tokenId');
      }

      // Try to get configHash from contract
      let configHash = null;
      try {
        configHash = await getConfigHashFromContract(tokenIdNum);
      } catch (error) {
        console.warn('Contract query failed, using default:', error);
      }

      // Try to get config from storage
      let config = null;
      if (configHash) {
        config = getConfigFromStorage(tokenIdNum, configHash);
      }

      // Generate metadata
      const metadata = generateMetadata(tokenIdNum, configHash || '0x00000000', config);

      // Return JSON response
      // Set proper headers for JSON response
      const jsonResponse = JSON.stringify(metadata, null, 2);
      
      // Clear body and set JSON
      document.body.innerHTML = '';
      document.body.textContent = jsonResponse;
      document.body.style.fontFamily = 'monospace';
      document.body.style.padding = '20px';
      document.body.style.whiteSpace = 'pre-wrap';
      document.body.style.backgroundColor = '#1a1a2e';
      document.body.style.color = '#fff';
      
      // Try to set content-type via meta tag (for some servers)
      const meta = document.createElement('meta');
      meta.httpEquiv = 'Content-Type';
      meta.content = 'application/json';
      document.head.appendChild(meta);
    }

    // Handle request
    handleRequest().catch(error => {
      console.error('Metadata API error:', error);
      const errorResponse = {
        error: 'Failed to generate metadata',
        message: error.message
      };
      document.body.textContent = JSON.stringify(errorResponse, null, 2);
      document.body.style.fontFamily = 'monospace';
      document.body.style.padding = '20px';
      document.body.style.whiteSpace = 'pre-wrap';
    });
  </script>
</head>
<body>
  <!-- Metadata will be displayed here -->
</body>
</html>
