<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Arrow - MemePlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            image-rendering: pixelated;
        }

        #game-container {
            position: relative;
            width: 720px;
            height: 1000px;
            max-width: 100vw;
            max-height: 100vh;
            background: linear-gradient(180deg, #87CEEB 0%, #98D8E8 30%, #B0E0E6 60%, #E0F7FF 100%);
            overflow: hidden;
            touch-action: none;
            border: 4px solid #2d2d2d;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }

        /* Pixel art clouds */
        .cloud {
            position: absolute;
            background: #fff;
            border-radius: 0;
            image-rendering: pixelated;
            opacity: 0.9;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 100;
            pointer-events: none;
        }

        #score-display {
            color: #FFD700;
            font-size: 28px;
            font-weight: bold;
        }

        #stamina-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #stamina-bar {
            width: 120px;
            height: 16px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            overflow: hidden;
        }

        #stamina-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.1s linear;
            border-radius: 8px;
        }

        #stamina-fill.warning {
            background: #ff4444;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #timer-display {
            color: #fff;
            font-size: 20px;
            font-weight: bold;
        }

        #timer-display.warning {
            color: #ff4444;
        }

        /* Combo display - below stamina bar */
        #combo-display {
            position: absolute;
            top: 60px;
            right: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #000;
            opacity: 0;
            z-index: 150;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #combo-display.show {
            opacity: 1;
            animation: comboPopup 0.5s ease-out;
        }

        @keyframes comboPopup {
            0% { transform: scale(0.5); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Game canvas */
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* Bow area */
        #bow-area {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 200px;
            z-index: 50;
        }

        /* Start screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .tap-to-start {
            font-size: 36px;
            font-weight: bold;
            color: #FFD700;
            animation: tapPulse 1.5s ease-in-out infinite;
            cursor: pointer;
        }

        @keyframes tapPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        /* Game over screen */
        #gameover-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #gameover-screen h1 {
            font-size: 36px;
            color: #FFD700;
            margin-bottom: 10px;
        }

        .binance-logo-gameover {
            margin-bottom: 15px;
        }

        #gameover-screen .brand {
            font-size: 24px;
            color: #FFD700;
            margin-bottom: 30px;
            letter-spacing: 3px;
        }

        #final-score {
            font-size: 32px;
            color: #fff;
            margin-bottom: 20px;
        }

        #final-score span {
            color: #FFD700;
            font-size: 48px;
        }

        #restart-btn {
            padding: 15px 50px;
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(180deg, #FFD700, #FFA500);
            border: 4px solid #8B4513;
            color: #2d2d2d;
            cursor: pointer;
            font-family: inherit;
            margin-top: 20px;
        }

        /* Point popup */
        .point-popup {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            z-index: 100;
            animation: floatUp 1s ease-out forwards;
        }

        .point-popup.positive {
            color: #4CAF50;
            text-shadow: 2px 2px 0 #000;
        }

        .point-popup.negative {
            color: #ff4444;
            text-shadow: 2px 2px 0 #000;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-60px); opacity: 0; }
        }

        /* Responsive - fit 720x1000 to screen */
        @media screen and (max-aspect-ratio: 720/1000) {
            /* Screen is taller than game ratio - fit by width */
            #game-container {
                width: 100vw;
                height: calc(100vw * 1000 / 720);
                max-height: 100vh;
                transform: none;
            }
        }

        @media screen and (min-aspect-ratio: 720/1000) {
            /* Screen is wider than game ratio - fit by height */
            #game-container {
                height: 100vh;
                width: calc(100vh * 720 / 1000);
                max-width: 100vw;
                transform: none;
            }
        }

        /* Mobile specific adjustments */
        @media screen and (max-width: 720px) {
            body {
                padding: 0;
                margin: 0;
            }
            
            #game-container {
                border: none;
                box-shadow: none;
                border-radius: 0;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Clouds will be added dynamically -->
        
        <!-- HUD -->
        <div id="hud">
            <div id="score-display">üèπ <span id="score">0</span></div>
            <div id="stamina-container">
                <div id="stamina-bar">
                    <div id="stamina-fill"></div>
                </div>
                <div id="timer-display">10.0s</div>
            </div>
        </div>

        <!-- Combo display -->
        <div id="combo-display"></div>

        <!-- Game canvas -->
        <canvas id="game-canvas"></canvas>

        <!-- Start screen -->
        <div id="start-screen" role="button" aria-label="Tap to start game">
            <div class="tap-to-start">TAP TO START</div>
        </div>

        <!-- Game over screen -->
        <div id="gameover-screen">
            <h1>GAME OVER</h1>
            <div class="binance-logo-gameover">
                <img src="assets/binance-logo.webp" alt="Binance" width="80" height="80">
            </div>
            <div class="brand">MEMEPLAY</div>
            <div id="final-score">Final Score: <span>0</span></div>
            <button id="restart-btn">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // ==================== GAME CONFIG ====================
        const CONFIG = {
            CANVAS_WIDTH: 720,
            CANVAS_HEIGHT: 1000,
            INITIAL_STAMINA: 10, // seconds
            MAX_STAMINA: 11,
            BIRD_SIZE: 80,
            ARROW_SPEED: 25,
            BOW_X: 360,
            BOW_Y: 900,
            MAX_PULL: 150,
            
            // Bird types
            BIRDS: {
                BLACK: { type: 'black', points: 1, stamina: 3, spawnRate: 0.70 },
                WHITE: { type: 'white', points: 5, stamina: 3, spawnRate: 0.20 },
                RED: { type: 'red', points: -5, stamina: 0, spawnRate: 0.10 }
            },
            
            SPAWN_INTERVAL: 750, // ms between spawns (doubled bird count)
            MIN_BIRD_SPEED: 2,
            MAX_BIRD_SPEED: 5
        };

        // ==================== GAME STATE ====================
        let gameState = {
            isRunning: false,
            score: 0,
            combo: 0,
            stamina: CONFIG.INITIAL_STAMINA,
            birds: [],
            arrows: [],
            clouds: [],
            isPulling: false,
            pullStart: { x: 0, y: 0 },
            pullCurrent: { x: 0, y: 0 },
            lastSpawnTime: 0,
            lastFrameTime: 0
        };

        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const startScreen = document.getElementById('start-screen');
        const gameoverScreen = document.getElementById('gameover-screen');
        const restartBtn = document.getElementById('restart-btn');
        const scoreDisplay = document.getElementById('score');
        const staminaFill = document.getElementById('stamina-fill');
        const timerDisplay = document.getElementById('timer-display');
        const comboDisplay = document.getElementById('combo-display');

        // Set canvas size
        canvas.width = CONFIG.CANVAS_WIDTH;
        canvas.height = CONFIG.CANVAS_HEIGHT;

        // Load Binance logo image
        const binanceLogo = new Image();
        binanceLogo.src = 'assets/binance-logo.webp';

        // ==================== SOUND SYSTEM ====================
        let audioCtx = null;
        
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        // Sound: Bow pull (creak/stretch sound)
        function playPullSound() {
            if (!audioCtx) return;
            // Creaking wood sound
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            osc1.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(800, audioCtx.currentTime);
            filter.Q.setValueAtTime(5, audioCtx.currentTime);
            
            osc1.type = 'triangle';
            osc1.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc1.frequency.linearRampToValueAtTime(350, audioCtx.currentTime + 0.15);
            
            osc2.type = 'sine';
            osc2.frequency.setValueAtTime(180, audioCtx.currentTime);
            osc2.frequency.linearRampToValueAtTime(300, audioCtx.currentTime + 0.15);
            
            gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);
            
            osc1.start();
            osc2.start();
            osc1.stop(audioCtx.currentTime + 0.15);
            osc2.stop(audioCtx.currentTime + 0.15);
        }
        
        // Sound: Arrow shoot (wind swoosh - v√∫t gi√≥)
        function playShootSound() {
            if (!audioCtx) return;
            
            // Create wind swoosh sound
            const duration = 0.25;
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            
            // Generate filtered noise that sounds like wind
            for (let i = 0; i < bufferSize; i++) {
                const t = i / bufferSize;
                // Envelope: quick attack, smooth decay
                const envelope = Math.pow(1 - t, 0.5) * Math.min(t * 20, 1);
                // Pink-ish noise (softer than white noise)
                const noise = (Math.random() * 2 - 1) * 0.5 + 
                              (Math.random() * 2 - 1) * 0.3 + 
                              (Math.random() * 2 - 1) * 0.2;
                data[i] = noise * envelope;
            }
            
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            
            // Highpass filter for airy sound
            const highpass = audioCtx.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.setValueAtTime(800, audioCtx.currentTime);
            
            // Bandpass for wind character
            const bandpass = audioCtx.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.frequency.setValueAtTime(3000, audioCtx.currentTime);
            bandpass.frequency.linearRampToValueAtTime(1000, audioCtx.currentTime + duration);
            bandpass.Q.setValueAtTime(0.5, audioCtx.currentTime);
            
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            
            source.connect(highpass);
            highpass.connect(bandpass);
            bandpass.connect(gain);
            gain.connect(audioCtx.destination);
            
            source.start();
        }
        
        // Sound: Hit good bird (positive ding)
        function playHitGoodSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, audioCtx.currentTime);
            osc.frequency.setValueAtTime(1100, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }
        
        // Sound: Hit bomb bird (negative buzz)
        function playHitBadSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }

        // ==================== INIT CLOUDS ====================
        function initClouds() {
            gameState.clouds = [];
            for (let i = 0; i < 5; i++) {
                gameState.clouds.push({
                    x: Math.random() * CONFIG.CANVAS_WIDTH,
                    y: 100 + Math.random() * 300,
                    width: 80 + Math.random() * 60,
                    speed: 0.3 + Math.random() * 0.3
                });
            }
        }

        // ==================== BIRD CLASS ====================
        class Bird {
            constructor() {
                const rand = Math.random();
                let birdConfig;
                
                if (rand < CONFIG.BIRDS.BLACK.spawnRate) {
                    birdConfig = CONFIG.BIRDS.BLACK;
                } else if (rand < CONFIG.BIRDS.BLACK.spawnRate + CONFIG.BIRDS.WHITE.spawnRate) {
                    birdConfig = CONFIG.BIRDS.WHITE;
                } else {
                    birdConfig = CONFIG.BIRDS.RED;
                }
                
                this.type = birdConfig.type;
                this.points = birdConfig.points;
                this.stamina = birdConfig.stamina;
                
                // Random direction
                this.direction = Math.random() < 0.5 ? 1 : -1;
                this.x = this.direction === 1 ? -CONFIG.BIRD_SIZE : CONFIG.CANVAS_WIDTH;
                this.y = 120 + Math.random() * (CONFIG.CANVAS_HEIGHT - 400);
                this.speed = CONFIG.MIN_BIRD_SPEED + Math.random() * (CONFIG.MAX_BIRD_SPEED - CONFIG.MIN_BIRD_SPEED);
                
                this.width = CONFIG.BIRD_SIZE;
                this.height = CONFIG.BIRD_SIZE - 20;
                this.wingFrame = 0;
                this.wingSpeed = 0.15;
                this.alive = true;
            }

            update(deltaTime) {
                this.x += this.speed * this.direction;
                this.wingFrame += this.wingSpeed;
                
                // Remove if off screen
                if ((this.direction === 1 && this.x > CONFIG.CANVAS_WIDTH + this.width) ||
                    (this.direction === -1 && this.x < -this.width)) {
                    this.alive = false;
                }
            }

            draw(ctx) {
                ctx.save();
                
                // Flip if going left
                if (this.direction === -1) {
                    ctx.translate(this.x + this.width / 2, this.y);
                    ctx.scale(-1, 1);
                    ctx.translate(-this.width / 2, 0);
                } else {
                    ctx.translate(this.x, this.y);
                }
                
                // Bird body color
                let bodyColor, wingColor, eyeColor;
                if (this.type === 'black') {
                    bodyColor = '#2d2d2d';
                    wingColor = '#1a1a1a';
                    eyeColor = '#fff';
                } else if (this.type === 'white') {
                    bodyColor = '#f5f5f5';
                    wingColor = '#e0e0e0';
                    eyeColor = '#000';
                } else {
                    bodyColor = '#ff4444';
                    wingColor = '#cc0000';
                    eyeColor = '#fff';
                }
                
                // Body (ellipse-like pixel)
                ctx.fillStyle = bodyColor;
                ctx.fillRect(20, 20, 40, 30);
                
                // Head
                ctx.fillRect(50, 15, 25, 25);
                
                // Beak
                ctx.fillStyle = '#FFA500';
                ctx.fillRect(75, 22, 12, 8);
                
                // Eye
                ctx.fillStyle = eyeColor;
                ctx.fillRect(60, 20, 6, 6);
                
                // Wing animation
                const wingY = Math.sin(this.wingFrame * Math.PI) * 8;
                ctx.fillStyle = wingColor;
                ctx.fillRect(25, 15 + wingY, 25, 15);
                
                // Tail
                ctx.fillStyle = wingColor;
                ctx.fillRect(5, 25, 15, 10);
                
                // Binance logo image on white bird's back
                if (this.type === 'white' && binanceLogo.complete) {
                    ctx.drawImage(binanceLogo, 15, -20, 50, 50);
                }
                
                // Bomb indicator for red bird
                if (this.type === 'red') {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('üí£', 30, 45);
                }
                
                ctx.restore();
            }

            checkCollision(arrow) {
                return arrow.x > this.x && 
                       arrow.x < this.x + this.width &&
                       arrow.y > this.y && 
                       arrow.y < this.y + this.height;
            }
        }

        // ==================== ARROW CLASS ====================
        class Arrow {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.rotation = Math.atan2(vy, vx);
                this.alive = true;
                this.trail = [];
            }

            update(deltaTime) {
                // Add trail point
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 10) this.trail.shift();
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Gravity effect (slight)
                this.vy += 0.1;
                
                // Update rotation based on velocity
                this.rotation = Math.atan2(this.vy, this.vx);
                
                // Check bounds
                if (this.y < -50 || this.y > CONFIG.CANVAS_HEIGHT + 50 ||
                    this.x < -50 || this.x > CONFIG.CANVAS_WIDTH + 50) {
                    this.alive = false;
                    // Miss - reset combo
                    if (gameState.combo > 0) {
                        gameState.combo = 0;
                        hideCombo();
                    }
                }
            }

            draw(ctx) {
                // Draw trail
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < this.trail.length; i++) {
                    if (i === 0) {
                        ctx.moveTo(this.trail[i].x, this.trail[i].y);
                    } else {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                }
                ctx.stroke();
                
                // Draw arrow
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Arrow shaft (+20px longer)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-30, -3, 60, 6);
                
                // Arrow head
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(35, 0);
                ctx.lineTo(25, -8);
                ctx.lineTo(25, 8);
                ctx.closePath();
                ctx.fill();
                
                // Feathers
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(-30, -6, 10, 3);
                ctx.fillRect(-30, 3, 10, 3);
                
                ctx.restore();
            }
        }

        // ==================== DRAW FUNCTIONS ====================
        function drawBackground() {
            // Sky gradient is already CSS
            
            // Draw clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            gameState.clouds.forEach(cloud => {
                // Pixel cloud shape
                const w = cloud.width;
                ctx.fillRect(cloud.x, cloud.y, w * 0.6, 20);
                ctx.fillRect(cloud.x + w * 0.1, cloud.y - 15, w * 0.4, 20);
                ctx.fillRect(cloud.x + w * 0.3, cloud.y - 25, w * 0.3, 20);
                ctx.fillRect(cloud.x - w * 0.1, cloud.y + 10, w * 0.5, 15);
            });
            
            // Ground
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, CONFIG.CANVAS_HEIGHT - 50, CONFIG.CANVAS_WIDTH, 50);
            
            // Grass
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, CONFIG.CANVAS_HEIGHT - 60, CONFIG.CANVAS_WIDTH, 15);
        }

        function drawBow() {
            const bowX = CONFIG.BOW_X;
            const bowY = CONFIG.BOW_Y;
            
            ctx.save();
            
            // Calculate pull vector (default aim up)
            let pullX = 0, pullY = -1, pullDist = 0;
            if (gameState.isPulling) {
                pullX = gameState.pullStart.x - gameState.pullCurrent.x;
                pullY = gameState.pullStart.y - gameState.pullCurrent.y;
                pullDist = Math.min(Math.sqrt(pullX * pullX + pullY * pullY), CONFIG.MAX_PULL);
                
                // Normalize
                const len = Math.sqrt(pullX * pullX + pullY * pullY);
                if (len > 0) {
                    pullX = (pullX / len) * pullDist;
                    pullY = (pullY / len) * pullDist;
                }
            }
            
            // Bow body (wooden arc) - pointing UP
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.arc(bowX, bowY, 60, Math.PI * 1.2, Math.PI * 1.8);
            ctx.stroke();
            
            // Bow string
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            // String endpoints (left and right sides)
            const leftX = bowX + Math.cos(Math.PI * 1.2) * 60;
            const leftY = bowY + Math.sin(Math.PI * 1.2) * 60;
            const rightX = bowX + Math.cos(Math.PI * 1.8) * 60;
            const rightY = bowY + Math.sin(Math.PI * 1.8) * 60;
            
            if (gameState.isPulling && pullDist > 10) {
                // Pulled string - follows drag direction (reduced to 25% for less stretch)
                const stringPullX = bowX - pullX * 0.25;
                const stringPullY = bowY - pullY * 0.25;
                
                ctx.moveTo(leftX, leftY);
                ctx.lineTo(stringPullX, stringPullY);
                ctx.lineTo(rightX, rightY);
            } else {
                // Relaxed string (slightly curved down)
                ctx.moveTo(leftX, leftY);
                ctx.quadraticCurveTo(bowX, bowY + 20, rightX, rightY);
            }
            ctx.stroke();
            
            // Draw arrow on string when pulling
            if (gameState.isPulling && pullDist > 10) {
                ctx.save();
                // Arrow follows the string (drag direction, reduced stretch)
                ctx.translate(bowX - pullX * 0.25, bowY - pullY * 0.25);
                // Arrow points in the direction it will fly (shot direction)
                ctx.rotate(Math.atan2(pullY, pullX));
                
                // Arrow on bow - tail at string position (x=0)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(0, -3, 70, 6);
                
                // Arrow head (pointing right = direction of flight)
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(75, 0);
                ctx.lineTo(65, -8);
                ctx.lineTo(65, 8);
                ctx.closePath();
                ctx.fill();
                
                // Feathers (at the back, x=0 = string position)
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(0, -6, 10, 3);
                ctx.fillRect(0, 3, 10, 3);
                
                ctx.restore();
                
                // Draw aim line (shows where arrow will go)
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.moveTo(bowX, bowY);
                const aimLen = 200;
                const aimX = bowX + (pullX / pullDist) * aimLen;
                const aimY = bowY + (pullY / pullDist) * aimLen;
                ctx.lineTo(aimX, aimY);
                ctx.stroke();
                ctx.setLineDash([]);
            } else {
                // Draw default arrow pointing up when not pulling
                ctx.save();
                ctx.translate(bowX, bowY - 30);
                ctx.rotate(-Math.PI / 2); // Point up
                
                // Arrow on bow (+20px longer)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-30, -3, 70, 6);
                
                // Arrow head
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(45, 0);
                ctx.lineTo(35, -8);
                ctx.lineTo(35, 8);
                ctx.closePath();
                ctx.fill();
                
                // Feathers
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(-30, -6, 10, 3);
                ctx.fillRect(-30, 3, 10, 3);
                
                ctx.restore();
            }
            
            ctx.restore();
        }

        // ==================== UPDATE FUNCTIONS ====================
        function updateClouds(deltaTime) {
            gameState.clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x > CONFIG.CANVAS_WIDTH + 100) {
                    cloud.x = -150;
                    cloud.y = 100 + Math.random() * 300;
                }
            });
        }

        function spawnBird(timestamp) {
            if (timestamp - gameState.lastSpawnTime > CONFIG.SPAWN_INTERVAL) {
                gameState.birds.push(new Bird());
                gameState.lastSpawnTime = timestamp;
            }
        }

        function checkCollisions() {
            gameState.arrows.forEach(arrow => {
                if (!arrow.alive) return;
                
                gameState.birds.forEach(bird => {
                    if (!bird.alive) return;
                    
                    if (bird.checkCollision(arrow)) {
                        // Hit!
                        bird.alive = false;
                        arrow.alive = false;
                        
                        if (bird.type === 'red') {
                            // Bomb bird - lose points and reset combo
                            gameState.score = Math.max(0, gameState.score + bird.points);
                            gameState.combo = 0;
                            hideCombo();
                            showPointPopup(bird.x, bird.y, bird.points);
                            playHitBadSound();
                        } else {
                            // Good bird - gain points and stamina
                            gameState.combo++;
                            const points = bird.points * gameState.combo;
                            gameState.score += points;
                            gameState.stamina = Math.min(CONFIG.MAX_STAMINA, gameState.stamina + bird.stamina);
                            
                            showPointPopup(bird.x, bird.y, points);
                            playHitGoodSound();
                            
                            if (gameState.combo >= 2) {
                                showCombo(gameState.combo);
                            }
                        }
                        
                        updateHUD();
                    }
                });
            });
        }

        // ==================== UI FUNCTIONS ====================
        function updateHUD() {
            scoreDisplay.textContent = gameState.score;
            
            const staminaPercent = (gameState.stamina / CONFIG.MAX_STAMINA) * 100;
            staminaFill.style.width = staminaPercent + '%';
            
            timerDisplay.textContent = gameState.stamina.toFixed(1) + 's';
            
            if (gameState.stamina <= 3) {
                staminaFill.classList.add('warning');
                timerDisplay.classList.add('warning');
            } else {
                staminaFill.classList.remove('warning');
                timerDisplay.classList.remove('warning');
            }
        }

        function showCombo(combo) {
            comboDisplay.textContent = `COMBO x${combo}!`;
            comboDisplay.classList.add('show');
            
            setTimeout(() => {
                comboDisplay.classList.remove('show');
            }, 800);
        }

        function hideCombo() {
            comboDisplay.classList.remove('show');
        }

        function showPointPopup(x, y, points) {
            const popup = document.createElement('div');
            popup.className = `point-popup ${points > 0 ? 'positive' : 'negative'}`;
            popup.textContent = points > 0 ? `+${points}` : points;
            // Fixed position: bottom-right corner, 200px from bottom, 50px from right
            popup.style.right = '50px';
            popup.style.bottom = '200px';
            popup.style.left = 'auto';
            popup.style.top = 'auto';
            gameContainer.appendChild(popup);
            
            setTimeout(() => popup.remove(), 1000);
        }

        // ==================== INPUT HANDLERS ====================
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = CONFIG.CANVAS_WIDTH / rect.width;
            const scaleY = CONFIG.CANVAS_HEIGHT / rect.height;
            
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function onPointerDown(e) {
            if (!gameState.isRunning) return;
            e.preventDefault();
            
            const pos = getPointerPos(e);
            gameState.isPulling = true;
            gameState.pullStart = { x: pos.x, y: pos.y };
            gameState.pullCurrent = { x: pos.x, y: pos.y };
            playPullSound();
        }

        function onPointerMove(e) {
            if (!gameState.isPulling) return;
            e.preventDefault();
            
            gameState.pullCurrent = getPointerPos(e);
        }

        function onPointerUp(e) {
            if (!gameState.isPulling) return;
            e.preventDefault();
            
            // Calculate and shoot arrow
            const pullX = gameState.pullStart.x - gameState.pullCurrent.x;
            const pullY = gameState.pullStart.y - gameState.pullCurrent.y;
            const pullDist = Math.sqrt(pullX * pullX + pullY * pullY);
            
            if (pullDist > 20) {
                // Normalize and scale velocity
                const speed = Math.min(pullDist / CONFIG.MAX_PULL, 1) * CONFIG.ARROW_SPEED;
                const vx = (pullX / pullDist) * speed;
                const vy = (pullY / pullDist) * speed;
                
                gameState.arrows.push(new Arrow(CONFIG.BOW_X, CONFIG.BOW_Y, vx, vy));
            }
            
            gameState.isPulling = false;
        }

        // Add event listeners
        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('mousemove', onPointerMove);
        canvas.addEventListener('mouseup', onPointerUp);
        canvas.addEventListener('mouseleave', onPointerUp);

        canvas.addEventListener('touchstart', onPointerDown, { passive: false });
        canvas.addEventListener('touchmove', onPointerMove, { passive: false });
        canvas.addEventListener('touchend', onPointerUp, { passive: false });

        // ==================== GAME LOOP ====================
        function gameLoop(timestamp) {
            if (!gameState.isRunning) return;
            
            // Calculate delta time
            const deltaTime = timestamp - gameState.lastFrameTime;
            gameState.lastFrameTime = timestamp;
            
            // Update stamina
            gameState.stamina -= deltaTime / 1000;
            
            // Check game over
            if (gameState.stamina <= 0) {
                gameOver();
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            
            // Update
            updateClouds(deltaTime);
            spawnBird(timestamp);
            
            // Update birds
            gameState.birds = gameState.birds.filter(bird => {
                bird.update(deltaTime);
                return bird.alive;
            });
            
            // Update arrows
            gameState.arrows = gameState.arrows.filter(arrow => {
                arrow.update(deltaTime);
                return arrow.alive;
            });
            
            // Check collisions
            checkCollisions();
            
            // Draw
            drawBackground();
            
            gameState.birds.forEach(bird => bird.draw(ctx));
            gameState.arrows.forEach(arrow => arrow.draw(ctx));
            
            drawBow();
            
            // Update HUD
            updateHUD();
            
            requestAnimationFrame(gameLoop);
        }

        // ==================== GAME CONTROL ====================
        function startGame() {
            // Initialize audio on user interaction
            initAudio();
            
            // Send message to parent
            window.parent.postMessage({ type: 'GAME_STARTED', gameId: 'arrow1' }, '*');
            
            // Reset state
            gameState = {
                isRunning: true,
                score: 0,
                combo: 0,
                stamina: CONFIG.INITIAL_STAMINA,
                birds: [],
                arrows: [],
                clouds: gameState.clouds || [],
                isPulling: false,
                pullStart: { x: 0, y: 0 },
                pullCurrent: { x: 0, y: 0 },
                lastSpawnTime: 0,
                lastFrameTime: performance.now()
            };
            
            // Init clouds if not exists
            if (gameState.clouds.length === 0) {
                initClouds();
            }
            
            // Hide screens
            startScreen.style.display = 'none';
            gameoverScreen.style.display = 'none';
            
            // Update HUD
            updateHUD();
            
            // Start loop
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameState.isRunning = false;
            
            // Play game over sound
            playHitBadSound();
            
            // Show game over screen
            gameoverScreen.style.display = 'flex';
            document.querySelector('#final-score span').textContent = gameState.score;
        }

        // Event listeners for buttons
        startScreen.addEventListener('click', startGame);
        startScreen.addEventListener('touchstart', startGame);
        restartBtn.addEventListener('click', startGame);

        // Initialize clouds on load
        initClouds();
    </script>
</body>
</html>

