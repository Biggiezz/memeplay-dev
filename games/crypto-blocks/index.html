<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Crypto Blocks 8×8</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
    }
    
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
    
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    
    body {
      font-family: 'Arial', sans-serif;
      background: #0a0a0a;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      touch-action: none;
      width: 100vw;
      height: 100vh;
    }
    
    .game-wrapper {
      width: 720px;
      height: 1000px;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    
    #gameContainer {
      width: 720px;
      height: 1000px;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      position: relative;
      overflow: hidden;
    }
    
    /* Mobile: fixed 720x1000px container, all objects fit inside */
    @media screen and (max-width: 720px) {
      html {
        overflow: hidden;
      }
      
      body {
        justify-content: center;
        align-items: center;
        overflow: hidden;
        padding: 0;
      }
      
      .game-wrapper {
        width: 720px;
        height: 1000px;
      }
      
      #gameContainer {
        width: 720px;
        height: 1000px;
        max-width: 720px;
        max-height: 1000px;
        overflow: hidden;
      }
    }
    
    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }
    
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    
    #uiCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10;
    }
    
    .story-banner {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid #ffb642;
      border-radius: 12px;
      padding: 12px 24px;
      color: #ffb642;
      font-size: 24px;
      font-weight: 600;
      max-width: 640px;
      text-align: center;
      z-index: 50;
      display: none !important; /* Always hidden - story only shows in game over screen */
    }
    
    .story-banner.show {
      display: none !important; /* Override show class to keep it hidden */
    }
    
    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 4px solid #ffb642;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      z-index: 1000; /* Tăng z-index để đảm bảo trên cùng */
      display: none;
      pointer-events: all; /* Cho phép click/touch */
      touch-action: manipulation; /* Tối ưu cho mobile */
      transform-origin: center center; /* Đảm bảo scale từ center */
    }
    
    .game-over.show {
      display: block;
      pointer-events: all; /* Đảm bảo có thể tương tác khi hiển thị */
    }
    
    /* Desktop: Phóng to bảng game over 20% */
    @media screen and (min-width: 721px) {
      .game-over {
        transform: translate(-50%, -50%) scale(1.2);
      }
    }
    
    /* Mobile: Thu nhỏ bảng game over 25% (còn 75%) */
    @media screen and (max-width: 720px) {
      .game-over {
        transform: translate(-50%, -50%) scale(0.75);
      }
    }
    
    .game-over h2 {
      color: #ffb642;
      font-size: 48px;
      margin-bottom: 20px;
    }
    
    .game-over p {
      color: #fff;
      font-size: 24px;
      margin-bottom: 30px;
    }
    
    .game-over-story {
      color: #ffb642;
      font-size: 22px;
      margin-bottom: 30px;
      white-space: pre-wrap;
    }
    
    .restart-btn {
      background: linear-gradient(135deg, #ffb642 0%, #ff8c00 100%);
      border: none;
      color: #000;
      font-size: 24px;
      font-weight: bold;
      padding: 15px 40px;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.2s;
      pointer-events: all; /* Đảm bảo có thể click/touch */
      touch-action: manipulation; /* Tối ưu cho mobile - tránh double-tap zoom */
      -webkit-tap-highlight-color: rgba(255, 182, 66, 0.3); /* Highlight khi touch */
      user-select: none; /* Tránh select text khi touch */
      -webkit-user-select: none;
      position: relative; /* Đảm bảo z-index hoạt động */
      z-index: 1001; /* Cao hơn game-over */
    }
    
    .restart-btn:active {
      transform: scale(0.95);
    }
    
    .restart-btn:hover {
      background: linear-gradient(135deg, #ffc862 0%, #ff9c20 100%);
    }
    
    /* Tap to Start Overlay - bán trong suốt phủ lên game */
    .tap-to-start-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.05); /* Rất sáng để thấy rõ 3 viên gạch preview phía dưới */
      z-index: 1999;
      pointer-events: all;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .tap-to-start-overlay.hidden {
      display: none;
    }
    
    /* Tap to Start Text */
    .tap-to-start {
      color: #ffb642;
      font-size: 48px;
      font-weight: bold;
      cursor: pointer;
      z-index: 2000;
      pointer-events: all;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
      text-align: center;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 1), 0 0 10px rgba(255, 182, 66, 0.5); /* Đậm hơn để nổi bật trên nền sáng */
      animation: pulseText 1.5s ease-in-out infinite;
    }
    
    .tap-to-start:active {
      opacity: 0.8;
    }
    
    @keyframes pulseText {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.6;
        transform: scale(1.1);
      }
    }
    
    /* Mobile: Smaller text */
    @media screen and (max-width: 720px) {
      .tap-to-start {
        font-size: 36px;
      }
    }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <div id="gameContainer">
      <canvas id="gameCanvas" width="720" height="1000"></canvas>
      <canvas id="uiCanvas" width="720" height="1000"></canvas>
      
      <div id="storyBanner" class="story-banner"></div>
      
      <div id="gameOver" class="game-over">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <div id="gameOverStory" class="game-over-story"></div>
        <button class="restart-btn" onclick="game.restart()">Restart</button>
      </div>
      
      <div id="tapToStartOverlay" class="tap-to-start-overlay">
        <div id="tapToStart" class="tap-to-start">Tap to Start</div>
      </div>
    </div>
  </div>

  <script>
    const DEFAULT_LOGO_URL = 'assets/ui/mc_meme.png';
    const externalTheme = {
      mapColor: '#0a0a0a',
      logoUrl: DEFAULT_LOGO_URL,
      story: ''
    };
    const mcImage = new Image();
    let mcImageLoaded = false;
    mcImage.onload = () => {
      mcImageLoaded = true;
    };
    mcImage.onerror = (err) => {
      console.warn('⚠️ [CRYPTO-BLOCKS] Failed to load mcImage:', err);
    };
    mcImage.src = DEFAULT_LOGO_URL;
    
    function applyExternalTheme() {
      const container = document.getElementById('gameContainer');
      if (container) {
        const color = externalTheme.mapColor || '#0a0a0a';
        container.style.background = color.startsWith('linear-gradient') ? color : color;
      }
      
      if (externalTheme.logoUrl) {
        mcImage.src = externalTheme.logoUrl;
      } else {
        mcImage.src = DEFAULT_LOGO_URL;
      }
      
      // Story banner removed - only show story in game over screen
      const banner = document.getElementById('storyBanner');
      if (banner) {
        banner.style.display = 'none';
      }
      
      const gameOverStory = document.getElementById('gameOverStory');
      if (gameOverStory) {
        gameOverStory.textContent = externalTheme.story?.trim() || '';
        gameOverStory.style.display = externalTheme.story ? 'block' : 'none';
      }
    }
    
    window.addEventListener('message', (event) => {
      const data = event.data || event.message;
      if (!data) return;
      if (data.type === 'CRYPTO_BLOCKS_CONFIG') {
        const payload = data.payload || {};
        if (typeof payload.mapColor === 'string') {
          externalTheme.mapColor = payload.mapColor || externalTheme.mapColor;
        }
        if (typeof payload.logoUrl === 'string') {
          externalTheme.logoUrl = payload.logoUrl || DEFAULT_LOGO_URL;
        }
        if (typeof payload.story === 'string') {
          externalTheme.story = payload.story || '';
        }
        applyExternalTheme();
      }
    });

applyExternalTheme();
    
    // ===== CONFIG =====
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    const CONFIG = {
      GRID_SIZE: 8,
      CELL_SIZE: 81,
      GRID_WIDTH: 8 * 81, // 648px
      GRID_HEIGHT: 8 * 81, // 648px
      GRID_X: (720 - 648) / 2, // Centered: 36px
      GRID_Y: 100, // Top margin
      BLOCK_SIZE: 64, // Block sprite size
      SHAPES_PER_TURN: 3,
      MAX_COMBO: 999, // No combo limit (x5, x6, x7...)
      COLORS: {
        RED: '#ff4444',
        GREEN: '#44ff44',
        BLUE: '#4444ff',
        PURPLE: '#aa44ff',
        YELLOW: '#ffff44'
      }
    };
    
    // Mobile scale factor for game objects (50% smaller)
    const MOBILE_SCALE = isMobile ? 0.5 : 1.0;
    
    if (isMobile) {
      // Scale down game objects on mobile (50%)
      CONFIG.CELL_SIZE = CONFIG.CELL_SIZE * MOBILE_SCALE;
      CONFIG.GRID_WIDTH = CONFIG.GRID_WIDTH * MOBILE_SCALE;
      CONFIG.GRID_HEIGHT = CONFIG.GRID_HEIGHT * MOBILE_SCALE;
      CONFIG.BLOCK_SIZE = CONFIG.BLOCK_SIZE * MOBILE_SCALE;
      
      // Calculate positions to fit in 720x1000px screen
      // Score/combo area: ~80px from top (top-left corner)
      // Grid: centered horizontally, positioned higher (15px up)
      // Preview grids: 20px below grid (revert to original)
      const scoreAreaHeight = 80;
      const previewCellSize = CONFIG.CELL_SIZE * 0.8; // Preview cells are 20% smaller
      const previewGridHeight = 3 * previewCellSize; // 3x3 grid height
      const spacing = 20; // Space between grid and preview
      
      // Calculate available space for grid
      const availableHeight = 1000 - scoreAreaHeight - previewGridHeight - spacing;
      // Center grid vertically in available space, then move up 15px
      CONFIG.GRID_Y = scoreAreaHeight + (availableHeight - CONFIG.GRID_HEIGHT) / 2 - 15;
      
      // Center grid horizontally
      CONFIG.GRID_X = (720 - CONFIG.GRID_WIDTH) / 2;
    }
    
    // ===== SHAPE LIBRARY =====
    // Each shape is an array of {x, y} offsets from center (0,0)
    // Only simple, common shapes (1-5 blocks max)
    const SHAPE_LIBRARY = [
      // Single blocks (1)
      [{x: 0, y: 0}],
      
      // Lines (2-3 blocks only, no 1x4)
      [{x: -1, y: 0}, {x: 0, y: 0}], // Horizontal 2
      [{x: 0, y: -1}, {x: 0, y: 0}], // Vertical 2
      [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}], // Horizontal 3
      [{x: 0, y: -1}, {x: 0, y: 0}, {x: 0, y: 1}], // Vertical 3
      
      // L-shapes (3-4 blocks)
      [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}], // L (3 blocks)
      [{x: 0, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}], // Reverse L
      [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: -1}], // L up
      [{x: 0, y: 0}, {x: -1, y: 0}, {x: 0, y: -1}], // Reverse L up
      [{x: 0, y: 0}, {x: 1, y: 0}, {x: 1, y: 1}], // Small L
      [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}, {x: 0, y: 2}], // Long L (4)
      [{x: 0, y: 0}, {x: 1, y: 0}, {x: 1, y: 1}, {x: 1, y: 2}], // Long L variant
      
      // T-shapes (4 blocks)
      [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}], // T down
      [{x: 0, y: -1}, {x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}], // T up
      [{x: 0, y: -1}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}], // T right
      [{x: 0, y: -1}, {x: -1, y: 0}, {x: 0, y: 0}, {x: 0, y: 1}], // T left
      
      // Squares (4 blocks)
      [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}], // 2x2 square
      
      // Z-shapes (4 blocks)
      [{x: -1, y: 0}, {x: 0, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}], // Z
      [{x: 1, y: 0}, {x: 0, y: 0}, {x: 0, y: 1}, {x: -1, y: 1}], // Reverse Z
      
      // 3x2 rectangle (6 blocks)
      [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: -1, y: 1}, {x: 0, y: 1}, {x: 1, y: 1}], // 3x2 rectangle
      
      // 3x3 square (9 blocks)
      [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: -1, y: 1}, {x: 0, y: 1}, {x: 1, y: 1}], // 3x3 square
    ];
    
    // ===== GAME STATE =====
    const gameState = {
      grid: [],
      score: 0,
      comboLevel: 0, // ✅ Combo starts from 0, accumulates based on lines cleared
      shapesPlacedThisTurn: 0,
      currentShapes: [], // 3 shapes to place this turn [{shape, color}, ...]
      gameOver: false,
      isPaused: false,
      consecutiveClears: 0, // Number of consecutive turns with clears (for combo multiplier)
      consecutiveNoClears: 0, // Number of consecutive turns without clears (reset combo if >= 3)
      consecutiveNoClearPlacements: 0, // Number of consecutive placements without clearing lines (reset combo to x0 if >= 3)
      linesClearedThisTurn: 0, // Total lines cleared in current turn
      hoveredShapeIndex: -1, // Currently hovered shape index (-1 = none) - for visual hover only
      selectedShapeIndex: -1, // Locked selected block index (-1 = none) - only changes on click, not on drag
      previewShape: null, // Currently previewing shape at mouse position
      previewGridX: -1,
      previewGridY: -1,
      isDragging: false, // Is mouse/touch being held down
      diamondAnimation: {
        active: false,
        scale: 1,
        rotation: 0,
        alpha: 1
      },
      particles: [], // Particles for line clear effects
      dragPointer: { x: CONFIG.GRID_X + CONFIG.GRID_WIDTH / 2, y: CONFIG.GRID_Y + CONFIG.GRID_HEIGHT / 2 }
    };
    
    // ===== PARTICLE SYSTEM =====
    class Particle {
      constructor(x, y, color, comboLevel) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * (4 + comboLevel * 2); // Faster with higher combo
        this.vy = (Math.random() - 0.5) * (4 + comboLevel * 2);
        this.color = color;
        this.size = 8 + comboLevel * 2; // Bigger with higher combo
        this.life = 1.0;
        this.decay = 0.02 + comboLevel * 0.01; // Slower decay with higher combo
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.2;
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.3; // Gravity
        this.life -= this.decay;
        this.rotation += this.rotationSpeed;
        return this.life > 0;
      }
      
      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
        ctx.restore();
      }
    }
    
    // ===== CANVAS SETUP =====
    const gameCanvas = document.getElementById('gameCanvas');
    const uiCanvas = document.getElementById('uiCanvas');
    const gameCtx = gameCanvas.getContext('2d', { alpha: false, desynchronized: true });
    const uiCtx = uiCanvas.getContext('2d', { alpha: true });
    
    gameCtx.imageSmoothingEnabled = false;
    uiCtx.imageSmoothingEnabled = false;
    
    // ===== INITIALIZE GRID =====
    function initGrid() {
      gameState.grid = [];
      for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
        gameState.grid[y] = [];
        for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
          gameState.grid[y][x] = null; // null = empty, string = color
        }
      }
    }
    
    // ===== BLOCK RENDERING =====
    function drawBlock(ctx, x, y, color, size = CONFIG.BLOCK_SIZE) {
      const centerX = x + size / 2;
      const centerY = y + size / 2;
      
      // Glow effect
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size / 2);
      gradient.addColorStop(0, color);
      gradient.addColorStop(0.7, color);
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      
      // Main block
      ctx.fillStyle = color;
      ctx.fillRect(x + 2, y + 2, size - 4, size - 4);
      
      // Glossy highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.fillRect(x + 4, y + 4, size / 2 - 4, size / 3);
      
      // Glow edges
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.strokeRect(x + 2, y + 2, size - 4, size - 4);
      
      // Drop shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(x + 4, y + size - 2, size - 4, 2);
    }
    
    // ===== GRID RENDERING =====
    function drawGrid() {
      // Clear canvas
      gameCtx.fillStyle = '#0a0a0a';
      gameCtx.fillRect(0, 0, 720, 1000);
      
      // Check if tap to start overlay is showing - if yes, make grid 90% transparent (opacity 0.1)
      const tapToStartOverlay = document.getElementById('tapToStartOverlay');
      const isShowingTapToStart = tapToStartOverlay && !tapToStartOverlay.classList.contains('hidden');
      if (isShowingTapToStart) {
        gameCtx.globalAlpha = 0.1; // 90% transparent (only 10% visible)
      }
      
      // Draw mc meme watermark inside grid (before grid lines and blocks)
      if (mcImageLoaded) {
        gameCtx.save();
        const previousAlpha = gameCtx.globalAlpha;
        gameCtx.globalAlpha = 0.12;
        
        const scale = Math.min(
          CONFIG.GRID_WIDTH / mcImage.width,
          CONFIG.GRID_HEIGHT / mcImage.height
        );
        const drawWidth = mcImage.width * scale;
        const drawHeight = mcImage.height * scale;
        const drawX = CONFIG.GRID_X + (CONFIG.GRID_WIDTH - drawWidth) / 2;
        const drawY = CONFIG.GRID_Y + (CONFIG.GRID_HEIGHT - drawHeight) / 2;
        
        gameCtx.drawImage(mcImage, drawX, drawY, drawWidth, drawHeight);
        gameCtx.globalAlpha = previousAlpha;
        gameCtx.restore();
      }
      
      // Draw grid lines
      gameCtx.strokeStyle = '#2a2a3e';
      gameCtx.lineWidth = 1;
      
      for (let i = 0; i <= CONFIG.GRID_SIZE; i++) {
        const pos = CONFIG.GRID_X + i * CONFIG.CELL_SIZE;
        // Vertical lines
        gameCtx.beginPath();
        gameCtx.moveTo(pos, CONFIG.GRID_Y);
        gameCtx.lineTo(pos, CONFIG.GRID_Y + CONFIG.GRID_HEIGHT);
        gameCtx.stroke();
        
        // Horizontal lines
        gameCtx.beginPath();
        gameCtx.moveTo(CONFIG.GRID_X, CONFIG.GRID_Y + i * CONFIG.CELL_SIZE);
        gameCtx.lineTo(CONFIG.GRID_X + CONFIG.GRID_WIDTH, CONFIG.GRID_Y + i * CONFIG.CELL_SIZE);
        gameCtx.stroke();
      }
      
      // Draw placed blocks
      for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
        for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
          const color = gameState.grid[y][x];
          if (color) {
            const blockX = CONFIG.GRID_X + x * CONFIG.CELL_SIZE + (CONFIG.CELL_SIZE - CONFIG.BLOCK_SIZE) / 2;
            const blockY = CONFIG.GRID_Y + y * CONFIG.CELL_SIZE + (CONFIG.CELL_SIZE - CONFIG.BLOCK_SIZE) / 2;
            drawBlock(gameCtx, blockX, blockY, color);
          }
        }
      }
      
      // Draw particles
      gameState.particles = gameState.particles.filter(particle => {
        particle.update();
        particle.draw(gameCtx);
        return particle.life > 0;
      });
      
      // Reset alpha after drawing grid
      if (isShowingTapToStart) {
        gameCtx.globalAlpha = 1.0;
      }
    }
    
    // ===== UI RENDERING =====
    function drawUI() {
      uiCtx.clearRect(0, 0, 720, 1000);
      
      // Check if tap to start overlay is showing - if yes, make everything 90% transparent (opacity 0.1)
      const tapToStartOverlay = document.getElementById('tapToStartOverlay');
      const isShowingTapToStart = tapToStartOverlay && !tapToStartOverlay.classList.contains('hidden');
      
      // Score and Combo - positioned relative to grid 8x8 top-left corner
      // Mobile: 15px from left edge of grid 8x8, above grid
      // Desktop: top-left of screen
      const scoreX = isMobile ? (CONFIG.GRID_X + 15) : 20;
      const scoreY = isMobile ? (CONFIG.GRID_Y - 30) : 40; // Above grid 8x8
      const comboY = isMobile ? (CONFIG.GRID_Y - 10) : 75; // Below score, above grid
      
      // Score - HD font on desktop: larger, sharper, with better shadow
      uiCtx.fillStyle = '#ffffff';
      uiCtx.font = isMobile ? 'bold 19px Arial' : 'bold 40px "Segoe UI", "Roboto", Arial, sans-serif';
      uiCtx.textAlign = 'left';
      uiCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      uiCtx.shadowBlur = 6;
      uiCtx.shadowOffsetX = 2;
      uiCtx.shadowOffsetY = 2;
      uiCtx.fillText(`Score: ${gameState.score}`, scoreX, scoreY);
      
      // Combo - HD font on desktop: larger, sharper, with better shadow
      // Show ×0 when combo = 0 (combo chain broken)
      uiCtx.fillStyle = gameState.comboLevel === 0 ? '#ff6666' : '#ffb642'; // Red when combo = 0
      uiCtx.font = isMobile ? 'bold 17px Arial' : 'bold 36px "Segoe UI", "Roboto", Arial, sans-serif';
      uiCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      uiCtx.shadowBlur = 6;
      uiCtx.shadowOffsetX = 2;
      uiCtx.shadowOffsetY = 2;
      uiCtx.fillText(`Combo: ×${gameState.comboLevel}`, scoreX, comboY);
      
      // Preview next shapes in 3x3 grids (20% smaller than main grid)
      // Position: 20px below the bottom of 8x8 grid
      const previewY = CONFIG.GRID_Y + CONFIG.GRID_HEIGHT + 20;
      const previewCellSize = CONFIG.CELL_SIZE * 0.8; // 20% smaller than main grid
      const previewBlockSize = CONFIG.BLOCK_SIZE * 0.8; // 20% smaller block size (maintain same ratio)
      const previewGridSize = 3; // 3x3 grid
      const previewGridWidth = previewGridSize * previewCellSize;
      const previewGridHeight = previewGridSize * previewCellSize;
      const previewSpacing = 20; // Spacing between preview grids
      const totalPreviewWidth = 3 * previewGridWidth + 2 * previewSpacing;
      const previewStartX = (720 - totalPreviewWidth) / 2; // Center all 3 grids
      
      // Draw 3 preview grids (3x3 each)
      for (let i = 0; i < CONFIG.SHAPES_PER_TURN; i++) {
        const gridX = previewStartX + i * (previewGridWidth + previewSpacing);
        const gridY = previewY;
        
        // Draw preview grid background (85% transparent = opacity 0.15)
        uiCtx.globalAlpha = 0.15; // 85% transparent (only 15% visible)
        uiCtx.fillStyle = 'rgba(30, 30, 50, 0.5)';
        uiCtx.fillRect(gridX, gridY, previewGridWidth, previewGridHeight);
        
        // Draw preview grid lines (85% transparent = opacity 0.15)
        uiCtx.strokeStyle = 'rgba(100, 100, 150, 0.3)';
        uiCtx.lineWidth = 1;
        for (let j = 0; j <= previewGridSize; j++) {
          const pos = gridX + j * previewCellSize;
          // Vertical lines
          uiCtx.beginPath();
          uiCtx.moveTo(pos, gridY);
          uiCtx.lineTo(pos, gridY + previewGridHeight);
          uiCtx.stroke();
          // Horizontal lines
          uiCtx.beginPath();
          uiCtx.moveTo(gridX, gridY + j * previewCellSize);
          uiCtx.lineTo(gridX + previewGridWidth, gridY + j * previewCellSize);
          uiCtx.stroke();
        }
        // Reset alpha after drawing grid (blocks NOT transparent - keep original alpha)
        uiCtx.globalAlpha = 1.0;
        
        // Draw shape inside preview grid - map shape to 3x3 matrix
        // IMPORTANT: Blocks NOT transparent - keep original alpha
        if (gameState.currentShapes[i]) {
          const { shape, color } = gameState.currentShapes[i];
          // Highlight selected block (alpha 1.0) or hovered block (alpha 0.85), others 0.7
          // Blocks NOT transparent - keep original brightness
          const alpha = gameState.selectedShapeIndex === i ? 1.0 : (gameState.hoveredShapeIndex === i ? 0.85 : 0.7);
          uiCtx.globalAlpha = alpha;
          
          // Convert shape (array of {x, y}) to 3x3 matrix
          const matrix = Array(3).fill(null).map(() => Array(3).fill(0));
          
          // Find bounds to center shape in 3x3
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          for (const block of shape) {
            minX = Math.min(minX, block.x);
            maxX = Math.max(maxX, block.x);
            minY = Math.min(minY, block.y);
            maxY = Math.max(maxY, block.y);
          }
          
          // Calculate offset to center in 3x3 grid
          const offsetX = 1 - Math.round((minX + maxX) / 2); // Center at (1,1)
          const offsetY = 1 - Math.round((minY + maxY) / 2);
          
          // Map shape blocks to matrix
          for (const block of shape) {
            const matrixX = block.x + offsetX;
            const matrixY = block.y + offsetY;
            // Only map if within 3x3 bounds
            if (matrixX >= 0 && matrixX < 3 && matrixY >= 0 && matrixY < 3) {
              matrix[matrixY][matrixX] = 1;
            }
          }
          
          // Render matrix by iterating row-col and drawing at exact grid cells
          for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 3; col++) {
              if (matrix[row][col] === 1) {
                // Calculate block position: exact grid cell + padding
                const blockX = gridX + col * previewCellSize + (previewCellSize - previewBlockSize) / 2;
                const blockY = gridY + row * previewCellSize + (previewCellSize - previewBlockSize) / 2;
                drawBlock(uiCtx, blockX, blockY, color, previewBlockSize);
              }
            }
          }
          uiCtx.globalAlpha = 1.0;
        }
      }
      
      // Preview shape on grid (ghost) - only show if can place
      if (gameState.previewShape && gameState.previewGridX >= 0 && gameState.previewGridY >= 0) {
        const { shape, color } = gameState.previewShape;
        const canPlace = canPlaceShape(shape, gameState.previewGridX, gameState.previewGridY);
        
        // Only show preview if can place (no red preview for conflicts)
        if (canPlace) {
          uiCtx.globalAlpha = 0.5;
          for (const block of shape) {
            const gridX = gameState.previewGridX + block.x;
            const gridY = gameState.previewGridY + block.y;
            
            if (gridX >= 0 && gridX < CONFIG.GRID_SIZE && gridY >= 0 && gridY < CONFIG.GRID_SIZE) {
              const blockX = CONFIG.GRID_X + gridX * CONFIG.CELL_SIZE + (CONFIG.CELL_SIZE - CONFIG.BLOCK_SIZE) / 2;
              const blockY = CONFIG.GRID_Y + gridY * CONFIG.CELL_SIZE + (CONFIG.CELL_SIZE - CONFIG.BLOCK_SIZE) / 2;
              drawBlock(uiCtx, blockX, blockY, color);
            }
          }
          uiCtx.globalAlpha = 1.0;
        }
      }
      
      // Draw dragging shape following pointer when dragging from bottom
      // Use selectedShapeIndex (locked) instead of hoveredShapeIndex
      if (gameState.isDragging && gameState.selectedShapeIndex >= 0) {
        const dragShapeData = gameState.currentShapes[gameState.selectedShapeIndex];
        if (dragShapeData) {
          const { shape, color } = dragShapeData;
          const pointerX = gameState.dragPointer.x;
          const pointerY = gameState.dragPointer.y;
          uiCtx.globalAlpha = 0.8;
          for (const block of shape) {
            const blockX = pointerX + block.x * CONFIG.BLOCK_SIZE - CONFIG.BLOCK_SIZE / 2;
            const blockY = pointerY + block.y * CONFIG.BLOCK_SIZE - CONFIG.BLOCK_SIZE / 2;
            drawBlock(uiCtx, blockX, blockY, color);
          }
          uiCtx.globalAlpha = 1.0;
        }
      }
      
      // Draw diamond combo indicator
      if (gameState.comboLevel > 1) {
        const diamondX = 600;
        const diamondY = 50;
        const size = 40;
        const scale = gameState.diamondAnimation.scale;
        const rotation = gameState.diamondAnimation.rotation;
        const alpha = gameState.diamondAnimation.alpha;
        
        uiCtx.save();
        uiCtx.translate(diamondX + size / 2, diamondY + size / 2);
        uiCtx.rotate(rotation * Math.PI / 180);
        uiCtx.scale(scale, scale);
        uiCtx.globalAlpha = alpha;
        
        // Diamond shape
        uiCtx.fillStyle = '#ffb642';
        uiCtx.shadowColor = '#ffb642';
        uiCtx.shadowBlur = 20;
        uiCtx.beginPath();
        uiCtx.moveTo(0, -size / 2);
        uiCtx.lineTo(size / 2, 0);
        uiCtx.lineTo(0, size / 2);
        uiCtx.lineTo(-size / 2, 0);
        uiCtx.closePath();
        uiCtx.fill();
        
        uiCtx.restore();
      }
    }
    
    // ===== PERFORMANCE OPTIMIZATION =====
    let lastPreviewUpdate = 0;
    const PREVIEW_UPDATE_INTERVAL = 16; // ~60fps (16ms)
    let rafPending = false;
    
    // ===== SOUND SYSTEM =====
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let audioUnlocked = false; // Track if audio has been unlocked by user interaction
    
    // Unlock audio on first user interaction (mobile requirement)
    // Critical for iframe on mobile - must be called on ANY user interaction
    function unlockAudio() {
      // Always try to resume if suspended (not just once)
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          audioUnlocked = true;
          // Play a silent sound to fully unlock audio (required for iOS Safari)
          // CRITICAL: Must use audioContext.currentTime for timing
          try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.001, audioContext.currentTime); // Silent
            oscillator.frequency.setValueAtTime(1, audioContext.currentTime); // Very low frequency
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.01);
          } catch (e) {
            console.log('Silent unlock sound error:', e);
          }
        }).catch(e => {
          console.log('Audio resume error:', e);
          // Retry after short delay
          setTimeout(() => {
            if (audioContext.state === 'suspended') {
              audioContext.resume().then(() => {
                audioUnlocked = true;
                // Play silent sound after retry
                try {
                  const oscillator = audioContext.createOscillator();
                  const gainNode = audioContext.createGain();
                  oscillator.connect(gainNode);
                  gainNode.connect(audioContext.destination);
                  gainNode.gain.setValueAtTime(0.001, audioContext.currentTime);
                  oscillator.frequency.setValueAtTime(1, audioContext.currentTime);
                  oscillator.start(audioContext.currentTime);
                  oscillator.stop(audioContext.currentTime + 0.01);
                } catch (e) {}
              }).catch(() => {});
            }
          }, 100);
        });
      } else if (audioContext.state === 'running') {
        // Already running - still play silent sound to ensure unlock (iOS requirement)
        if (!audioUnlocked) {
          audioUnlocked = true;
          try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.001, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(1, audioContext.currentTime);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.01);
          } catch (e) {
            // Ignore errors
          }
        }
      }
    }
    
    // Add event listeners to unlock audio on user interaction
    // DON'T use once: true - need to unlock multiple times to ensure audio works on mobile
    // Multiple listeners to ensure unlock works in iframe on mobile
    document.addEventListener('touchstart', unlockAudio, { passive: true });
    document.addEventListener('touchend', unlockAudio, { passive: true });
    document.addEventListener('touchmove', unlockAudio, { passive: true });
    document.addEventListener('click', unlockAudio, { passive: true });
    document.addEventListener('mousedown', unlockAudio, { passive: true });
    
    // Also listen on window for iframe scenarios
    window.addEventListener('touchstart', unlockAudio, { passive: true });
    window.addEventListener('touchend', unlockAudio, { passive: true });
    window.addEventListener('touchmove', unlockAudio, { passive: true });
    
    function playSound(type, frequency = 440, duration = 0.2, volume = 0.3) {
      try {
        // Always try to resume audio context if suspended (mobile requirement)
        if (audioContext.state === 'suspended') {
          audioContext.resume().catch(e => {
            console.log('Audio resume error:', e);
          });
          // If still suspended, wait a bit and retry
          if (audioContext.state === 'suspended') {
            setTimeout(() => {
              if (audioContext.state === 'suspended') {
                audioContext.resume().catch(() => {});
              }
            }, 100);
          }
        }
        
        // Wait for audio context to be ready (but don't block if it takes too long)
        // If suspended → unlock and retry
        if (audioContext.state === 'suspended') {
          unlockAudio();
          audioContext.resume().then(() => {
            // Retry playing sound after resume
            setTimeout(() => playSound(type, frequency, duration, volume), 50);
          }).catch(e => {
            // Retry unlock and play
            setTimeout(() => {
              unlockAudio();
              playSound(type, frequency, duration, volume);
            }, 100);
          });
          return;
        } else if (audioContext.state !== 'running') {
          // If not running → unlock and retry
          unlockAudio();
          setTimeout(() => playSound(type, frequency, duration, volume), 50);
          return;
        }
        
        // Ensure audio is unlocked before playing
        if (!audioUnlocked || audioContext.state !== 'running') {
          unlockAudio();
          // If still suspended, wait a bit then retry
          if (audioContext.state === 'suspended') {
            setTimeout(() => playSound(type, frequency, duration, volume), 100);
            return;
          }
          // If not running yet, wait a bit
          if (audioContext.state !== 'running') {
            setTimeout(() => playSound(type, frequency, duration, volume), 100);
            return;
          }
        }
        
        // Ensure audio context is running before creating oscillator
        if (audioContext.state !== 'running') {
          setTimeout(() => playSound(type, frequency, duration, volume), 100);
          return;
        }
        
        try {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
          
          gainNode.gain.setValueAtTime(0, audioContext.currentTime);
          gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + duration);
        } catch (e) {
          console.log('Play sound error:', e);
          // Retry after unlock
          unlockAudio();
          setTimeout(() => playSound(type, frequency, duration, volume), 100);
        }
      } catch (e) {
        console.log('Audio error:', e);
      }
    }
    
    function playPlaceBlock() {
      // Light "click" sound when placing block - volume 150% (0.45 → 0.675)
      playSound('place', 400, 0.15, 0.675);
    }
    
    function playLineClear() {
      // Volume 150% (1.0 → 1.5, louder than 100%)
      playSound('clear', 800, 0.35, 1.5);
    }
    
    // Progressive combo sounds - higher combo = more exciting
    // Volume > 100% (1.5-2.0) to be really loud
    function playComboSound(comboLevel) {
      if (comboLevel === 2) {
        // Combo x2: Cool - light, startup (1.0→1.5, 0.9→1.35)
        playSound('combo', 500, 0.3, 1.5);
        setTimeout(() => playSound('combo', 700, 0.2, 1.35), 100);
      } else if (comboLevel === 3) {
        // Combo x3: Great - stronger, with rhythm (1.0→1.5, 1.0→1.5, 0.9→1.35)
        playSound('combo', 600, 0.25, 1.5);
        setTimeout(() => playSound('combo', 800, 0.2, 1.5), 80);
        setTimeout(() => playSound('combo', 1000, 0.15, 1.35), 160);
      } else if (comboLevel === 4) {
        // Combo x4: Awesome - very strong, many layers (1.0→1.5, 1.0→1.5, 1.0→1.5, 0.9→1.35)
        playSound('combo', 700, 0.2, 1.5);
        setTimeout(() => playSound('combo', 900, 0.18, 1.5), 60);
        setTimeout(() => playSound('combo', 1100, 0.15, 1.5), 120);
        setTimeout(() => playSound('combo', 1300, 0.12, 1.35), 180);
      } else if (comboLevel >= 5) {
        // Combo x5+: Perfect - extremely exciting, strong crescendo (all → 1.5-2.0)
        playSound('combo', 800, 0.18, 2.0);
        setTimeout(() => playSound('combo', 1000, 0.15, 2.0), 50);
        setTimeout(() => playSound('combo', 1200, 0.12, 1.8), 100);
        setTimeout(() => playSound('combo', 1400, 0.1, 1.5), 150);
        setTimeout(() => playSound('combo', 1600, 0.08, 1.35), 200);
        // Add bass layer to increase excitement
        setTimeout(() => playSound('combo', 400, 0.25, 2.0), 100);
      }
    }
    
    // Legacy functions (kept for compatibility if needed)
    function playComboCool() {
      playComboSound(2);
    }
    
    function playComboGreat() {
      playComboSound(3);
    }
    
    function playComboPerfect() {
      playComboSound(5);
    }
    
    function playGameOver() {
      // Volume 150% (1.0 → 1.5, louder than 100%)
      playSound('over', 200, 0.5, 1.5);
    }
    
    function playUIClick() {
      // Volume 150% (0.6 → 0.9)
      playSound('click', 800, 0.1, 0.9);
    }
    
    // ===== GAME LOGIC =====
    function getRandomColor() {
      const colors = Object.values(CONFIG.COLORS);
      return colors[Math.floor(Math.random() * colors.length)];
    }
    
    function getRandomShape() {
      return SHAPE_LIBRARY[Math.floor(Math.random() * SHAPE_LIBRARY.length)];
    }
    
    function getRandomShapeWithWeight() {
      // Reduced frequency of 3x2 and 3x3 shapes (60% reduction: 30% -> 12%)
      const rand = Math.random();
      
      // Find 3x2 and 3x3 indices (last 2 shapes in library)
      const shape3x2Index = SHAPE_LIBRARY.length - 2; // 3x2 rectangle
      const shape3x3Index = SHAPE_LIBRARY.length - 1; // 3x3 square
      
      // 12% chance for 3x2 rectangle (reduced from 30%)
      if (rand < 0.12) {
        return SHAPE_LIBRARY[shape3x2Index]; // 3x2 rectangle
      }
      // 12% chance for 3x3 square (reduced from 30%)
      else if (rand < 0.24) {
        return SHAPE_LIBRARY[shape3x3Index]; // 3x3 square
      }
      // 76% chance for other shapes
      else {
        // Exclude 3x2 and 3x3 from random pool
        const otherShapes = SHAPE_LIBRARY.slice(0, shape3x2Index);
        return otherShapes[Math.floor(Math.random() * otherShapes.length)];
      }
    }
    
    function generateNewTurn() {
      gameState.currentShapes = [];
      for (let i = 0; i < CONFIG.SHAPES_PER_TURN; i++) {
        const shape = getRandomShapeWithWeight();
        const color = getRandomColor();
        gameState.currentShapes.push({ shape, color });
      }
      gameState.shapesPlacedThisTurn = 0;
      gameState.hoveredShapeIndex = -1; // Reset hover
      gameState.selectedShapeIndex = -1; // Reset selected block
      gameState.isDragging = false;
      gameState.dragPointer = { x: CONFIG.GRID_X + CONFIG.GRID_WIDTH / 2, y: CONFIG.GRID_Y + CONFIG.GRID_HEIGHT / 2 };
    }
    
    function canPlaceShape(shape, gridX, gridY) {
      for (const block of shape) {
        const x = gridX + block.x;
        const y = gridY + block.y;
        
        // Check bounds
        if (x < 0 || x >= CONFIG.GRID_SIZE || y < 0 || y >= CONFIG.GRID_SIZE) {
          return false;
        }
        
        // Check if cell is empty
        if (gameState.grid[y][x] !== null) {
          return false;
        }
      }
      return true;
    }
    
    function placeShape(shape, gridX, gridY) {
      if (!canPlaceShape(shape, gridX, gridY)) {
        return false;
      }
      
      // Send GAME_START message on first block placement
      if (!gameState.gameStarted) {
        gameState.gameStarted = true;
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({
            type: 'GAME_START',
            gameId: 'crypto-blocks'
          }, '*');
        }
      }
      
      // Get color from selected shape (locked when clicked)
      const selectedShapeData = gameState.currentShapes[gameState.selectedShapeIndex];
      const color = selectedShapeData ? selectedShapeData.color : '#ff0000'; // Fallback to red
      
      // Place all blocks of the shape
      for (const block of shape) {
        const x = gridX + block.x;
        const y = gridY + block.y;
        gameState.grid[y][x] = color;
      }
      
      gameState.shapesPlacedThisTurn++;
      playPlaceBlock();
      
      // Check and clear lines immediately after placing shape
      const linesToClear = checkLines();
      const totalLines = linesToClear.rows.length + linesToClear.cols.length;
      
      if (totalLines > 0) {
        // Clear lines immediately
        clearLines(linesToClear);
        playLineClear();
        
        // ✅ COMBO = TOTAL NUMBER OF LINES CLEARED (ACCUMULATED)
        // Combo increases by the number of lines cleared this turn
        gameState.comboLevel += totalLines;
        
        // ✅ ADD SCORE IMMEDIATELY AFTER EACH LINE CLEAR
        // Score = lines cleared × combo (after combo has been increased)
        const points = totalLines * gameState.comboLevel;
        gameState.score += points;
        
        // ✅ Reset counter for consecutive placements without clearing (lines cleared now)
        gameState.consecutiveNoClearPlacements = 0;
        
        // Play progressive combo sound - higher combo = more exciting
        // Play sound for all combo levels (x2, x3, x4, x5+)
        if (gameState.comboLevel >= 2) {
          playComboSound(gameState.comboLevel);
        }
        
        // Animate diamond
        animateDiamond();
        
        // Track lines cleared this turn
        gameState.linesClearedThisTurn += totalLines;
        
        // Update UI immediately to show new combo and score
        drawUI();
      } else {
        // ✅ No lines cleared → increase counter for consecutive placements without clearing
        gameState.consecutiveNoClearPlacements++;
        
        // ✅ If 3 consecutive placements without clearing → reset combo to 0
        if (gameState.consecutiveNoClearPlacements >= 3) {
          gameState.comboLevel = 0;
          gameState.consecutiveNoClearPlacements = 0; // Reset counter
          drawUI(); // Update UI to show combo x0
        }
      }
      
      // Check if all shapes are used (turn complete)
      const remainingShapes = gameState.currentShapes.filter(s => s !== null).length;
      if (remainingShapes === 0 || gameState.shapesPlacedThisTurn >= CONFIG.SHAPES_PER_TURN) {
        // Turn complete → spawn new blocks first, then check game over
        endTurn();
      }
      // DON'T check game over immediately after placing block
      // Only check game over after 3 new blocks have been fully generated (in endTurn)
      
      return true;
    }
    
    function getGridCell(mouseX, mouseY) {
      const x = mouseX - CONFIG.GRID_X;
      const y = mouseY - CONFIG.GRID_Y;
      
      if (x < 0 || y < 0 || x >= CONFIG.GRID_WIDTH || y >= CONFIG.GRID_HEIGHT) {
        return null;
      }
      
      const gridX = Math.floor(x / CONFIG.CELL_SIZE);
      const gridY = Math.floor(y / CONFIG.CELL_SIZE);
      
      if (gridX < 0 || gridX >= CONFIG.GRID_SIZE || gridY < 0 || gridY >= CONFIG.GRID_SIZE) {
        return null;
      }
      
      return { x: gridX, y: gridY };
    }
    
    function checkLines() {
      const linesToClear = { rows: [], cols: [] };
      
      // Check rows
      for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
        let full = true;
        for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
          if (gameState.grid[y][x] === null) {
            full = false;
            break;
          }
        }
        if (full) {
          linesToClear.rows.push(y);
        }
      }
      
      // Check columns
      for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
        let full = true;
        for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
          if (gameState.grid[y][x] === null) {
            full = false;
            break;
          }
        }
        if (full) {
          linesToClear.cols.push(x);
        }
      }
      
      return linesToClear;
    }
    
    function clearLines(linesToClear) {
      const comboLevel = gameState.comboLevel;
      
      // Create particles for rows
      for (const row of linesToClear.rows) {
        for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
          const color = gameState.grid[row][x];
          if (color) {
            // Create particles at block position
            const blockX = CONFIG.GRID_X + x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
            const blockY = CONFIG.GRID_Y + row * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
            
            // More particles with higher combo
            const particleCount = 3 + comboLevel * 2;
            for (let i = 0; i < particleCount; i++) {
              gameState.particles.push(new Particle(blockX, blockY, color, comboLevel));
            }
          }
          gameState.grid[row][x] = null;
        }
      }
      
      // Create particles for columns
      for (const col of linesToClear.cols) {
        for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
          const color = gameState.grid[y][col];
          if (color) {
            // Create particles at block position
            const blockX = CONFIG.GRID_X + col * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
            const blockY = CONFIG.GRID_Y + y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
            
            // More particles with higher combo
            const particleCount = 3 + comboLevel * 2;
            for (let i = 0; i < particleCount; i++) {
              gameState.particles.push(new Particle(blockX, blockY, color, comboLevel));
            }
          }
          gameState.grid[y][col] = null;
        }
      }
    }
    
    function endTurn() {
      // ✅ Score already added immediately after each line clear (in placeShape)
      // ✅ Combo already processed in placeShape (accumulates lines cleared, resets when 3+ consecutive placements without clearing)
      // Only reset counter for next turn
      gameState.linesClearedThisTurn = 0;
      
      // Generate new turn FIRST (spawn new blocks)
      generateNewTurn();
      
      // Only check game over AFTER 3 new blocks have been fully generated
      // Ensure currentShapes.length === 3 before checking
      if (gameState.currentShapes.length === CONFIG.SHAPES_PER_TURN) {
        // Check game over with 3 new blocks
        if (isGameOver()) {
          gameState.gameOver = true;
          playGameOver();
          showGameOver();
          return;
        }
      }
      // If previewBlocks is empty or loading → DON'T check game over
    }
    
    function canPlaceAnyShape() {
      // Check if any of the current shapes can be placed anywhere on the grid
      for (const shapeData of gameState.currentShapes) {
        if (!shapeData) continue; // Skip used shapes
        
        const { shape } = shapeData;
        
        // Try placing this shape at every possible position
        for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
          for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
            if (canPlaceShape(shape, x, y)) {
              return true; // Found at least one valid placement
            }
          }
        }
      }
      return false; // No shapes can be placed
    }
    
    function isGameOver() {
      // Game over if no shapes can be placed
      return !canPlaceAnyShape();
    }
    
    function animateDiamond() {
      gameState.diamondAnimation.active = true;
      gameState.diamondAnimation.scale = 1;
      gameState.diamondAnimation.rotation = 0;
      gameState.diamondAnimation.alpha = 1;
      
      const startTime = performance.now();
      const duration = 500; // 0.5s
      
      function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Ease out
        const ease = 1 - Math.pow(1 - progress, 3);
        
        gameState.diamondAnimation.scale = 1 + ease * 0.3; // Scale up 30%
        gameState.diamondAnimation.rotation = ease * 20; // Rotate 20 degrees
        gameState.diamondAnimation.alpha = 1 - ease * 0.3; // Fade slightly
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          gameState.diamondAnimation.active = false;
          gameState.diamondAnimation.scale = 1;
          gameState.diamondAnimation.rotation = 0;
          gameState.diamondAnimation.alpha = 1;
        }
      }
      
      animate();
    }
    
    // ===== INPUT HANDLING =====
    function getPreviewShapeArea(mouseX, mouseY) {
      // Position: 20px below the bottom of 8x8 grid
      const previewY = CONFIG.GRID_Y + CONFIG.GRID_HEIGHT + 20;
      const previewCellSize = CONFIG.CELL_SIZE * 0.8; // 20% smaller than main grid
      const previewGridSize = 3; // 3x3 grid
      const previewGridWidth = previewGridSize * previewCellSize;
      const previewGridHeight = previewGridSize * previewCellSize;
      const previewSpacing = 20; // Spacing between preview grids
      const totalPreviewWidth = 3 * previewGridWidth + 2 * previewSpacing;
      const previewStartX = (720 - totalPreviewWidth) / 2; // Center all 3 grids
      
      if (mouseY < previewY || mouseY > previewY + previewGridHeight) {
        return -1;
      }
      
      for (let i = 0; i < CONFIG.SHAPES_PER_TURN; i++) {
        const gridX = previewStartX + i * (previewGridWidth + previewSpacing);
        if (mouseX >= gridX && mouseX < gridX + previewGridWidth) {
          return i;
        }
      }
      return -1;
    }
    
    function updatePreview(mouseX, mouseY) {
      if (gameState.isDragging) {
        gameState.dragPointer.x = mouseX;
        gameState.dragPointer.y = mouseY;
      }
      
      // If dragging → DON'T change selectedShapeIndex (locked)
      // Only update hover for visual feedback
      if (!gameState.isDragging) {
        // Check if hovering over preview area (only for hover display, not select)
        const previewIndex = getPreviewShapeArea(mouseX, mouseY);
        if (previewIndex >= 0 && gameState.currentShapes[previewIndex]) {
          // Hovering over a shape in preview (visual only)
          gameState.hoveredShapeIndex = previewIndex;
        } else {
          gameState.hoveredShapeIndex = -1;
        }
      }
      
      // Preview on grid - use selectedShapeIndex (locked) instead of hoveredShapeIndex
      const cell = getGridCell(mouseX, mouseY);
      if (cell && gameState.selectedShapeIndex >= 0) {
        const selectedShapeData = gameState.currentShapes[gameState.selectedShapeIndex];
        if (selectedShapeData) {
          gameState.previewShape = selectedShapeData;
          gameState.previewGridX = cell.x;
          gameState.previewGridY = cell.y;
        } else {
          gameState.previewShape = null;
        }
      } else {
        gameState.previewShape = null;
      }
    }
    
    function handleMouseDown(event) {
      if (gameState.gameOver || gameState.shapesPlacedThisTurn >= CONFIG.SHAPES_PER_TURN) {
        return;
      }
      
      const rect = gameCanvas.getBoundingClientRect();
      // Use canvas coordinates if provided (from touch events), otherwise calculate
      const mouseX = event.canvasX !== undefined ? event.canvasX : (event.clientX - rect.left);
      const mouseY = event.canvasY !== undefined ? event.canvasY : (event.clientY - rect.top);
      
      // Check if clicking on preview area (LOCK selectedBlock)
      const previewIndex = getPreviewShapeArea(mouseX, mouseY);
      if (previewIndex >= 0 && gameState.currentShapes[previewIndex]) {
        // LOCK this block as selectedBlock - don't change during drag
        gameState.selectedShapeIndex = previewIndex;
        gameState.hoveredShapeIndex = previewIndex; // Visual feedback
        gameState.isDragging = true;
        gameState.dragPointer.x = mouseX;
        gameState.dragPointer.y = mouseY;
        playUIClick();
        return;
      }
      
      // If already hovering a shape, lock it as selected and start dragging
      if (gameState.hoveredShapeIndex >= 0) {
        // LOCK this block as selectedBlock
        gameState.selectedShapeIndex = gameState.hoveredShapeIndex;
        gameState.isDragging = true;
        gameState.dragPointer.x = mouseX;
        gameState.dragPointer.y = mouseY;
      }
    }
    
    function handleMouseUp(event) {
      if (gameState.gameOver || gameState.shapesPlacedThisTurn >= CONFIG.SHAPES_PER_TURN) {
        gameState.isDragging = false;
        return;
      }
      
      const rect = gameCanvas.getBoundingClientRect();
      // Use canvas coordinates if provided (from touch events), otherwise calculate
      const mouseX = event.canvasX !== undefined ? event.canvasX : (event.clientX - rect.left);
      const mouseY = event.canvasY !== undefined ? event.canvasY : (event.clientY - rect.top);
      
      let placed = false;
      // Check if releasing on grid (place shape) - use selectedShapeIndex (locked)
      const cell = getGridCell(mouseX, mouseY);
      if (cell && gameState.selectedShapeIndex >= 0 && gameState.isDragging) {
        const selectedShapeData = gameState.currentShapes[gameState.selectedShapeIndex];
        if (selectedShapeData) {
          const { shape } = selectedShapeData;
          if (placeShape(shape, cell.x, cell.y)) {
            // Remove used shape
            gameState.currentShapes[gameState.selectedShapeIndex] = null;
            gameState.selectedShapeIndex = -1; // Reset selected block
            gameState.hoveredShapeIndex = -1;
            gameState.previewShape = null;
            drawGrid();
            drawUI();
            placed = true;
          }
        }
      }
      
      gameState.isDragging = false;
      if (!placed) {
            // If cannot place → reset selected block to allow selecting another block
        gameState.selectedShapeIndex = -1;
        gameState.previewShape = null;
        gameState.hoveredShapeIndex = -1;
      }
    }
    
    function handleClick(event) {
      // Click is handled by mouseDown + mouseUp
      // This is kept for touch devices
      handleMouseDown(event);
      setTimeout(() => handleMouseUp(event), 10);
    }
    
    function handleMouseMove(event) {
      if (gameState.gameOver || gameState.shapesPlacedThisTurn >= CONFIG.SHAPES_PER_TURN) {
        gameState.previewShape = null;
        gameState.hoveredShapeIndex = -1;
        return;
      }
      
      const rect = gameCanvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      
      const oldHovered = gameState.hoveredShapeIndex;
      const oldPreviewX = gameState.previewGridX;
      const oldPreviewY = gameState.previewGridY;
      
      updatePreview(mouseX, mouseY);
      
      // Only redraw if preview changed (optimization)
      // Use requestAnimationFrame to batch updates
      if (oldHovered !== gameState.hoveredShapeIndex || 
          oldPreviewX !== gameState.previewGridX || 
          oldPreviewY !== gameState.previewGridY) {
        if (!rafPending) {
          rafPending = true;
          requestAnimationFrame(() => {
            drawUI();
            rafPending = false;
          });
        }
      }
    }
    
    // ===== GAME OVER UI =====
    async function showGameOver() {
      document.getElementById('finalScore').textContent = gameState.score;
      document.getElementById('gameOver').classList.add('show');
      
      // ✅ Send final score to leaderboard when game over
      const isInIframe = window.parent && window.parent !== window;
      
      if (isInIframe) {
        // ✅ If running in iframe → use postMessage (MemePlay platform)
        window.parent.postMessage({
          type: 'GAME_SCORE',
          gameId: 'crypto-blocks',
          score: gameState.score
        }, '*');
        console.log('📤 [CRYPTO-BLOCKS] Sent score via postMessage (iframe):', gameState.score);
      } else {
        // ✅ If NOT running in iframe → send directly to Supabase (mobile direct access)
        console.warn('⚠️ [CRYPTO-BLOCKS] Not in iframe, sending score directly to Supabase');
        
        // Get userId from localStorage (same as parent window)
        const getLocalUserId = () => {
          let id = localStorage.getItem('mp_user_id');
          if (!id) {
            id = 'u_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('mp_user_id', id);
          }
          return id;
        };
        
        const getWalletAddress = () => {
          return localStorage.getItem('mp_user_wallet') || '';
        };
        
        const userId = getWalletAddress() || getLocalUserId();
        
        if (!userId) {
          console.error('❌ [CRYPTO-BLOCKS] Cannot send score: No userId');
          return;
        }
        
        // Send directly to Supabase REST API
        const SUPABASE_URL = 'https://iikckrcdrvnqctzacxgx.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlpa2NrcmNkcnZucWN0emFjeGd4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE3Mzc3NDgsImV4cCI6MjA3NzMxMzc0OH0.nIPvf11YfFlWH0XHDZdxI496zaP431QOJCuQ-5XX4DQ';
        
        const endpoint = `${SUPABASE_URL}/rest/v1/rpc/submit_game_score`;
        const scoreData = {
          p_user_id: userId,
          p_game_id: 'crypto-blocks',
          p_score: gameState.score
        };
        
        try {
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
              'Prefer': 'return=representation'
            },
            body: JSON.stringify(scoreData),
            keepalive: true  // Safari-safe
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          
          const data = await response.json();
          console.log('✅ [CRYPTO-BLOCKS] Score sent directly to Supabase:', data);
        } catch (err) {
          console.error('❌ [CRYPTO-BLOCKS] Direct submit error:', err);
        }
      }
    }
    
    // ===== GAME CONTROL =====
    const game = {
      start() {
        initGrid();
        gameState.score = 0;
        gameState.comboLevel = 0; // ✅ Combo bắt đầu từ 0, cộng dồn theo số hàng phá được
        gameState.gameOver = false;
        gameState.shapesPlacedThisTurn = 0;
        gameState.consecutiveClears = 0;
        gameState.consecutiveNoClears = 0;
        gameState.consecutiveNoClearPlacements = 0;
        gameState.linesClearedThisTurn = 0;
        gameState.hoveredShapeIndex = -1;
        gameState.selectedShapeIndex = -1; // Reset selected block
        gameState.previewShape = null;
        gameState.isDragging = false;
        gameState.dragPointer = { x: CONFIG.GRID_X + CONFIG.GRID_WIDTH / 2, y: CONFIG.GRID_Y + CONFIG.GRID_HEIGHT / 2 };
        gameState.particles = []; // Clear particles
        gameState.gameStarted = false; // Reset game started flag
        generateNewTurn();
        drawGrid();
        drawUI();
        
        // Resume audio context (browser autoplay policy)
        // Unlock audio ngay khi start game (CRITICAL for mobile)
        unlockAudio();
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            unlockAudio(); // Unlock lại sau khi resume
          }).catch(e => {
            // Retry after short delay
            setTimeout(() => {
              if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => unlockAudio()).catch(() => {});
              }
            }, 200);
          });
        } else {
          unlockAudio(); // Vẫn unlock nếu đã running
        }
      },
      
      restart() {
        playUIClick();
        document.getElementById('gameOver').classList.remove('show');
        
        // DON'T show tap to start overlay - start game immediately
        // User has already played so no need for tap to start anymore
        
        // Reset game state and start again
        this.start();
        
        // Unlock audio (user has interacted with restart button)
        unlockAudio();
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            audioUnlocked = true;
          }).catch(() => {});
        } else {
          audioUnlocked = true;
        }
      }
    };
    
    // ===== TAP TO START HANDLER =====
    const tapToStartOverlay = document.getElementById('tapToStartOverlay');
    const tapToStartBtn = document.getElementById('tapToStart');
    let gameStarted = false;
    
    function handleTapToStart() {
      if (gameStarted) return; // Prevent multiple taps
      gameStarted = true;
      
      // CRITICAL: Unlock audio FIRST (valid user gesture - tap)
      // This is a valid user gesture → Safari will allow audio
      unlockAudio();
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          audioUnlocked = true;
          console.log('✅ Audio unlocked via Tap to Start');
          // Play a tiny sound to fully unlock (iOS Safari requirement)
          try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.01);
          } catch (e) {
            // Ignore
          }
        }).catch(() => {});
      } else {
        audioUnlocked = true;
      }
      
      // Hide overlay and "TAP TO START" text
      tapToStartOverlay.classList.add('hidden');
      
      // Restore game opacity to 100% (redraw with opacity 1.0)
      drawGrid();
      drawUI();
      
      // Start game (DON'T reset, just mark as started)
      // Game already initialized and shapes generated, just mark as started
      gameState.gameStarted = true;
      
      // Post message integration (for MemePlay platform)
      if (window.parent !== window) {
        window.parent.postMessage({ type: 'GAME_START', gameId: 'crypto-blocks' }, '*');
      }
    }
    
    // Add event listeners for tap to start (on overlay)
    if (tapToStartOverlay) {
      tapToStartOverlay.addEventListener('click', handleTapToStart);
      tapToStartOverlay.addEventListener('touchstart', handleTapToStart, { passive: true });
    }
    
    // ===== EVENT LISTENERS =====
    // Unlock audio on canvas interaction (mobile requirement)
    // DON'T use once: true - need to unlock multiple times
    // Note: Touch events are handled in gameContainer (main handler)
    // gameCanvas listeners are for direct canvas touches (backup)
    gameCanvas.addEventListener('mousedown', (e) => {
      unlockAudio();
      handleMouseDown(e);
    });
    gameCanvas.addEventListener('mouseup', handleMouseUp);
    gameCanvas.addEventListener('mousemove', (e) => {
      // Throttle mousemove to optimize performance
      const now = performance.now();
      if (now - lastPreviewUpdate < PREVIEW_UPDATE_INTERVAL) {
        return;
      }
      lastPreviewUpdate = now;
      
      if (!rafPending) {
        rafPending = true;
        requestAnimationFrame(() => {
          handleMouseMove(e);
          rafPending = false;
        });
      }
    });
    gameCanvas.addEventListener('mouseleave', () => {
      gameState.isDragging = false;
      gameState.hoveredShapeIndex = -1;
      gameState.previewShape = null;
    });
    
    // Touch events - Add to gameContainer to handle drag from preview area
    const gameContainer = document.getElementById('gameContainer');
    
    function getCanvasCoordinates(clientX, clientY) {
      const rect = gameCanvas.getBoundingClientRect();
      // Canvas is 720x1000, so coordinates are 1:1 with rect
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }
    
    gameContainer.addEventListener('touchstart', (e) => {
      // CRITICAL: Unlock audio FIRST before any other logic
      // Call unlockAudio() BEFORE preventDefault() to allow event to bubble to document/window
      unlockAudio();
      
      // Don't preventDefault if game over (to allow restart button to work)
      if (gameState.gameOver) {
        return; // Return early - don't preventDefault to allow event to bubble
      }
      
      // Only preventDefault after audio has been unlocked
      e.preventDefault();
      const touch = e.touches[0];
      if (touch) {
        const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
        const fakeEvent = { 
          clientX: touch.clientX, 
          clientY: touch.clientY,
          canvasX: coords.x,
          canvasY: coords.y
        };
        handleMouseDown(fakeEvent);
      }
    }, { passive: false });
    
    gameContainer.addEventListener('touchend', (e) => {
      // CRITICAL: Unlock audio on touchend too
      // Gọi unlockAudio() TRƯỚC preventDefault() để event có thể bubble
      unlockAudio();
      
      // Don't preventDefault if game over (to allow restart button to work)
      if (gameState.gameOver) {
        return; // Return early - don't preventDefault to allow event to bubble
      }
      
      // Only preventDefault after audio has been unlocked
      e.preventDefault();
      const touch = e.changedTouches[0];
      if (touch) {
        const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
        const fakeEvent = { 
          clientX: touch.clientX, 
          clientY: touch.clientY,
          canvasX: coords.x,
          canvasY: coords.y
        };
        handleMouseUp(fakeEvent);
      }
    }, { passive: false });
    
    gameContainer.addEventListener('touchmove', (e) => {
      // CRITICAL: Unlock audio on touchmove too (continuous unlock)
      // Gọi unlockAudio() TRƯỚC preventDefault() để event có thể bubble
      unlockAudio();
      
      // Don't preventDefault if game over (to allow restart button to work)
      if (gameState.gameOver) {
        return; // Return early - don't preventDefault to allow event to bubble
      }
      
      // Only preventDefault after audio has been unlocked
      e.preventDefault();
      const touch = e.touches[0];
      if (touch) {
        const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
        
        // Throttle updates to reduce lag (only update every 16ms = 60fps)
        const now = performance.now();
        if (now - lastPreviewUpdate < PREVIEW_UPDATE_INTERVAL) {
          return; // Skip frame if too fast
        }
        lastPreviewUpdate = now;
        
        // Batch updates with requestAnimationFrame
        if (!rafPending) {
          rafPending = true;
          requestAnimationFrame(() => {
            updatePreview(coords.x, coords.y);
            drawUI(); // Only redraw UI (don't redraw grid)
            rafPending = false;
          });
        }
      }
    }, { passive: false });
    
    // REMOVE duplicate gameCanvas touch listeners - already handled in gameContainer
    // Keep only as backup if gameContainer doesn't catch
    // BUT: Don't preventDefault to allow event to bubble to document/window (for unlockAudio)
    gameCanvas.addEventListener('touchstart', (e) => {
      unlockAudio(); // Unlock audio ngay khi touch canvas (CRITICAL for mobile iframe)
      // DON'T preventDefault here - allow event to bubble to document/window for unlockAudio
      // gameContainer will handle preventDefault
    }, { passive: true }); // passive: true để không chặn event
    
    gameCanvas.addEventListener('touchend', (e) => {
      unlockAudio(); // Unlock audio
      // DON'T preventDefault - allow event to bubble
    }, { passive: true });
    
    gameCanvas.addEventListener('touchmove', (e) => {
      unlockAudio(); // Continuous unlock
      // DON'T preventDefault - allow event to bubble
    }, { passive: true });
    
    // ===== GAME LOOP =====
    function gameLoop() {
      if (!gameState.gameOver) {
        // Only check game over when there are 3 new blocks (don't check when previewBlocks is empty)
        if (gameState.currentShapes.length === CONFIG.SHAPES_PER_TURN) {
          if (isGameOver()) {
            gameState.gameOver = true;
            playGameOver();
            showGameOver();
          } else {
            drawGrid();
            drawUI();
          }
        } else {
          // PreviewBlocks is empty or loading → only render, don't check game over
          drawGrid();
          drawUI();
        }
      }
      requestAnimationFrame(gameLoop);
    }
    
    // ===== INITIALIZE =====
    // DON'T auto-start game - wait for user to tap "Tap to Start"
    // But still init grid and generate shapes to display dimmed in background
    initGrid();
    generateNewTurn();
    drawGrid();
    drawUI();
    gameLoop();
    
    // ✅ Ensure "Tap to Start" overlay is visible when loaded in iframe (homepage)
    // This ensures the gaming screen is always shown, not editor or other screens
    // Run after a short delay to ensure all variables are initialized
    setTimeout(() => {
      const tapToStartOverlay = document.getElementById('tapToStartOverlay');
      if (tapToStartOverlay) {
        // Remove 'hidden' class if present (ensure overlay is visible)
        tapToStartOverlay.classList.remove('hidden');
        // Reset gameStarted flag to ensure overlay shows
        if (typeof gameStarted !== 'undefined') {
          gameStarted = false;
        }
        // Ensure gameState.gameStarted is false
        if (typeof gameState !== 'undefined' && gameState && typeof gameState.gameStarted !== 'undefined') {
          gameState.gameStarted = false;
        }
        // Redraw to show overlay
        drawGrid();
        drawUI();
      }
    }, 100);
    
    // Post message integration (for MemePlay platform)
    // Moved to handleTapToStart() - only send when user actually starts
    // if (window.parent !== window) {
    //   window.parent.postMessage({ type: 'GAME_START', gameId: 'crypto-blocks' }, '*');
    // }
  </script>
</body>
</html>

