<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Brick - Fallen Crypto</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      background: #0a0a0a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      touch-action: none;
    }
    #gameCanvas {
      display: block;
      max-width: 100vw;
      max-height: 100vh;
      background: #000;
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-crisp-edges;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      will-change: transform;
      transform: translateZ(0);
      backface-visibility: hidden;
      touch-action: none;
    }
    .touch-zone {
      position: fixed;
      bottom: 0;
      width: 50%;
      height: 100%;
      z-index: 50;
      opacity: 0;
      touch-action: none;
    }
    .touch-zone.left {
      left: 0;
    }
    .touch-zone.right {
      right: 0;
    }
    /* Start screen: fullscreen overlay */
    .start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: white;
      z-index: 200;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    .start-screen.show {
      display: flex;
      animation: popIn 0.3s ease-out;
    }
    /* Level screen and Game Over: old design (box with border) */
    .level-screen, .game-over-screen {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #ffd700;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      color: white;
      z-index: 200;
      display: none;
    }
    .level-screen.show, .game-over-screen.show {
      display: block;
      animation: popIn 0.3s ease-out;
    }
    .screen-title {
      font-size: 48px;
      color: #ffd700;
      margin-bottom: 20px;
      text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
    }
    .start-screen .screen-title {
      margin: 0;
      text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px rgba(255, 215, 0, 0.5);
      pointer-events: none;
      animation: gentlePulse 2s ease-in-out infinite;
    }
    @keyframes gentlePulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.7;
        transform: scale(1.05);
      }
    }
    .screen-subtitle {
      font-size: 24px;
      margin-bottom: 30px;
      line-height: 1.6;
    }
    .game-over-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-bottom: 30px;
      width: 100%;
    }
    .bnb-logo {
      width: 140px;
      height: 140px;
      object-fit: contain;
    }
    .bnb-story {
      font-size: 16px;
      line-height: 1.6;
      color: #fff;
      text-align: center;
      max-width: 500px;
      margin: 0;
      padding: 0 20px;
    }
    .screen-btn {
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      color: #000;
      border: none;
      border-radius: 10px;
      padding: 15px 40px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s;
      font-family: 'Courier New', monospace;
    }
    .screen-btn:hover {
      transform: scale(1.05);
    }
    .screen-btn:active {
      transform: scale(0.95);
    }
    /* Mobile: Compact game over screen */
    @media screen and (max-width: 768px) {
      .game-over-screen {
        padding: 20px !important;
        width: 90vw !important;
        max-width: 600px !important;
        max-height: 85vh !important;
        overflow-y: auto;
      }
      .game-over-screen .screen-title {
        font-size: 27px !important; /* 75% of 36px = 27px (down another 25%) */
        margin-bottom: 12px !important;
      }
      .game-over-screen .screen-subtitle {
        font-size: 20px !important;
        margin-bottom: 16px !important;
      }
      .game-over-content {
        gap: 12px !important;
        margin-bottom: 16px !important;
      }
      .bnb-logo {
        width: 98px !important; /* 70% of 140px = 98px (down 30%) */
        height: 98px !important;
      }
      .bnb-story {
        font-size: 14px !important;
        line-height: 1.5 !important;
        padding: 0 10px !important;
        margin-bottom: 12px !important; /* Space for button */
      }
      .game-over-screen .screen-btn {
        font-size: 18px !important;
        padding: 10px 25px !important;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        margin: 0 auto !important;
        width: fit-content !important;
      }
    }
    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    @media (max-width: 768px) {
      .control-btn { width: 100px; height: 100px; font-size: 40px; }
      .screen-title { font-size: 36px; }
      .screen-subtitle { font-size: 20px; }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div class="touch-zone left" id="touchLeft"></div>
  <div class="touch-zone right" id="touchRight"></div>

  <div class="start-screen show" id="startScreen">
    <div class="screen-title" id="startBtn">Tap to play</div>
  </div>

  <div class="level-screen" id="levelScreen">
    <div class="screen-title" id="levelTitle">LEVEL 1</div>
    <button class="screen-btn" id="levelStartBtn">START</button>
  </div>

  <div class="game-over-screen" id="gameOverScreen">
    <div class="screen-title">GAME OVER</div>
    <div class="screen-subtitle">
      Score: <span id="finalScore">0</span>
    </div>
    <div class="game-over-content">
      <img id="bnbLogo" src="assets/binance-logo.webp" alt="BNB Logo" class="bnb-logo">
      <p id="bnbStory" class="bnb-story"></p>
    </div>
    <button class="screen-btn" id="restartBtn">PLAY AGAIN</button>
  </div>

  <script>
    // ==========================================
    // MOBILE DETECTION
    // ==========================================
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const speedMultiplier = isMobile ? 2.73 : 2.25; // Desktop: +125% (1.0 * 2.25 = 2.25, tƒÉng 50% t·ª´ 1.5) | Mobile: +173%
    
    console.log('üì± Device:', isMobile ? 'Mobile' : 'Desktop', '| Speed:', speedMultiplier + 'x');

    // ==========================================
    // GAME CONFIGURATION
    // ==========================================
    const CONFIG = {
      WIDTH: 720,
      HEIGHT: 1000,
      PADDLE_WIDTH: 120,
      PADDLE_HEIGHT: 20,
      PADDLE_Y: 920,
      get PADDLE_SPEED() { return 10.4 * (isMobile ? 1.15 : 1.0); }, // Desktop: +30% (8‚Üí10.4) | Mobile: +15% on top (11.96)
      BALL_SIZE: 32, // x4 size (was 8)
      // T·ªëc ƒë·ªô bi KH√îNG thay ƒë·ªïi theo level - ch·ªâ ph·ª• thu·ªôc v√†o mobile/desktop
      get BALL_SPEED_BASE() { return 4 * speedMultiplier; }, // Kh√¥ng nh√¢n v·ªõi level!
      BRICK_PADDING: 3, // Spacing between bricks (tƒÉng l√™n 3 ƒë·ªÉ r√µ r√†ng h∆°n, d·ªÖ th·∫•y padding)
      LEVEL_TIME: 30000, // 30 seconds per level
      MAX_LEVEL: 20,
      MAX_BALLS: 15, // T·ªëi ƒëa 15 vi√™n bi
      POWERUP_SIZE: 24,
      POWERUP_FALL_SPEED: 3,
      // Brick progression
      LEVEL1_BRICKS: 30, // 5 rows x 6 cols
      BRICKS_PER_LEVEL: 6 // +6 bricks each level
    };

    // Failed crypto projects
    const CRYPTO_LOGOS = [
      { name: 'FTX', rows: 8, cols: 16 },
      { name: 'LUNA', rows: 8, cols: 16 },
      { name: 'BITCONNECT', rows: 8, cols: 20 },
      { name: 'MT.GOX', rows: 8, cols: 16 },
      { name: 'CELSIUS', rows: 8, cols: 18 },
      { name: 'VOYAGER', rows: 8, cols: 18 },
      { name: 'THREE ARROWS', rows: 9, cols: 20 },
      { name: 'BLOCKFI', rows: 8, cols: 18 },
      { name: 'TERRA', rows: 8, cols: 14 },
      { name: 'SAFEMOON', rows: 8, cols: 18 },
      { name: 'SQUID GAME', rows: 9, cols: 20 },
      { name: 'ONECOIN', rows: 8, cols: 18 },
      { name: 'QUADRIGA', rows: 9, cols: 20 },
      { name: 'THODEX', rows: 8, cols: 16 },
      { name: 'AFRICRYPT', rows: 9, cols: 20 },
      { name: 'TITANIUM', rows: 9, cols: 20 },
      { name: 'CENTRA', rows: 8, cols: 16 },
      { name: 'PLUSTOKEN', rows: 9, cols: 20 },
      { name: 'BITCLUB', rows: 8, cols: 18 },
      { name: 'PONZICOIN', rows: 9, cols: 20 }
    ];

    // ==========================================
    // CANVAS SETUP
    // ==========================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { 
      alpha: false, 
      desynchronized: true 
    });
    ctx.imageSmoothingEnabled = false;

    canvas.width = CONFIG.WIDTH;
    canvas.height = CONFIG.HEIGHT;

    // ==========================================
    // AUDIO SETUP (8-bit sounds, mobile-safe)
    // ==========================================
    let audioContext = null;
    let audioUnlocked = false;
    
    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      try {
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            if (audioUnlocked) return;
            audioUnlocked = true;
            // Silent tick to fully unlock audio on iOS/Safari
            try {
              const osc = audioContext.createOscillator();
              const gain = audioContext.createGain();
              osc.connect(gain);
              gain.connect(audioContext.destination);
              gain.gain.setValueAtTime(0.0001, audioContext.currentTime);
              osc.frequency.setValueAtTime(1, audioContext.currentTime);
              osc.start(audioContext.currentTime);
              osc.stop(audioContext.currentTime + 0.01);
            } catch (e) {
              console.log('Silent unlock error:', e);
            }
          }).catch(() => {});
        } else if (audioContext.state === 'running' && !audioUnlocked) {
          audioUnlocked = true;
          try {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(0.0001, audioContext.currentTime);
            osc.frequency.setValueAtTime(1, audioContext.currentTime);
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.01);
          } catch (e) {}
        }
      } catch (err) {
        console.log('initAudio error:', err);
      }
    }
    
    // Bi ch·∫°m g·∫°ch (√¢m thanh t·ª´ game 13 - crypto-blocks: ƒë·∫∑t g·∫°ch v√†o √¥ l∆∞·ªõi 8x8)
    function playBrickHit() {
      // D√πng √¢m thanh bi ch·∫°m m√°i ch√®o cho bi ch·∫°m g·∫°ch (nghe √™m tai h∆°n)
      playPaddleBounce();
    }
    
    // Ph√° g·∫°ch (explosion sound)
    function playBrickBreak() {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.connect(gain);
      gain.connect(audioContext.destination);
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(200, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.15);
      gain.gain.setValueAtTime(0.15, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + 0.15);
    }
    
    // Ch·∫°m paddle (bounce sound)
    function playPaddleBounce() {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.connect(gain);
      gain.connect(audioContext.destination);
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(300, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.1);
      gain.gain.setValueAtTime(0.2, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + 0.1);
    }
    
    // Hit x2 powerup (positive sound)
    function playPowerupX2() {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.connect(gain);
      gain.connect(audioContext.destination);
      osc.type = 'sine';
      osc.frequency.setValueAtTime(600, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.2);
      gain.gain.setValueAtTime(0.15, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + 0.2);
    }
    
    // Hit x3 powerup (super positive sound)
    function playPowerupX3() {
      if (!audioContext) return;
      const osc1 = audioContext.createOscillator();
      const osc2 = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc1.connect(gain);
      osc2.connect(gain);
      gain.connect(audioContext.destination);
      osc1.type = 'sine';
      osc2.type = 'sine';
      osc1.frequency.setValueAtTime(800, audioContext.currentTime);
      osc2.frequency.setValueAtTime(1000, audioContext.currentTime);
      osc1.frequency.exponentialRampToValueAtTime(1600, audioContext.currentTime + 0.3);
      osc2.frequency.exponentialRampToValueAtTime(2000, audioContext.currentTime + 0.3);
      gain.gain.setValueAtTime(0.2, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      osc1.start(audioContext.currentTime);
      osc2.start(audioContext.currentTime);
      osc1.stop(audioContext.currentTime + 0.3);
      osc2.stop(audioContext.currentTime + 0.3);
    }

    // ==========================================
    // LOAD BINANCE LOGO WHITE (for ball sprite)
    // ==========================================
    const binanceLogoImg = new Image();
    binanceLogoImg.src = 'assets/binance-logo-white.webp';
    let binanceLogoLoaded = false;
    binanceLogoImg.onload = () => {
      binanceLogoLoaded = true;
      console.log('‚úÖ Binance logo (white) loaded for ball');
    };
    binanceLogoImg.onerror = () => {
      console.warn('‚ö†Ô∏è Binance logo failed to load, using fallback color');
    };

    // ==========================================
    // BNB STORIES (random 1/5 on game over)
    // ==========================================
    const BNB_STORIES = [
      "In 2025, Binance Integrates BlackRock's BUIDL Fund into Institutional Collateral Framework",
      "In 2017, Binance launched in a highly competitive market, but BNB quickly stood out with low fees and fast transactions.",
      "In 2018, even during a deep market downturn, BNB kept growing thanks to Binance's expanding ecosystem.",
      "In September 2020, Binance Smart Chain went live, turning BNB into the core asset of a major blockchain.",
      "In 2021, BSC handled millions of transactions per day, proving BNB's leadership in low-cost DeFi."
    ];

    // ==========================================
    // GAME STATE
    // ==========================================
    let gameState = {
      isRunning: false,
      level: 1,
      score: 0,
      bricksDestroyed: 0,
      levelStartTime: 0,
      timeRemaining: 30,
      currentLogo: 'FTX'
    };

    // ==========================================
    // PADDLE
    // ==========================================
    const paddle = {
      x: CONFIG.WIDTH / 2 - CONFIG.PADDLE_WIDTH / 2,
      y: CONFIG.PADDLE_Y,
      width: CONFIG.PADDLE_WIDTH,
      height: CONFIG.PADDLE_HEIGHT,
      vx: 0,
      color: '#00ff00'
    };

    // ==========================================
    // BALLS
    // ==========================================
    const balls = [];

    class Ball {
      constructor(x, y, randomDirection = false) {
        this.x = x;
        this.y = y;
        this.size = CONFIG.BALL_SIZE;
        this.radius = this.size / 2; // Cache radius ƒë·ªÉ tr√°nh t√≠nh l·∫°i nhi·ªÅu l·∫ßn
        
        if (randomDirection) {
          // Random angle between 45¬∞ and 135¬∞ (upward)
          const angle = (Math.random() * 90 + 45) * Math.PI / 180;
          this.vx = Math.cos(angle) * CONFIG.BALL_SPEED_BASE;
          this.vy = -Math.abs(Math.sin(angle) * CONFIG.BALL_SPEED_BASE);
        } else {
          this.vx = (Math.random() - 0.5) * 2;
          this.vy = -CONFIG.BALL_SPEED_BASE;
        }
        
        this.active = true;
      }

      update(deltaTime) {
        // Use deltaTime for smooth movement (like paddle and powerups)
        // Prevents ball "jumping" when frame rate fluctuates
        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;

        // Wall collision (circular hitbox) - d√πng cached radius
        if (this.x - this.radius <= 0) {
          this.vx = Math.abs(this.vx);
          this.x = this.radius;
        }
        if (this.x + this.radius >= CONFIG.WIDTH) {
          this.vx = -Math.abs(this.vx);
          this.x = CONFIG.WIDTH - this.radius;
        }

        // Ceiling collision
        if (this.y - this.radius <= 0) {
          this.vy = Math.abs(this.vy);
          this.y = this.radius;
        }

        // Paddle collision (circular ball vs rectangle paddle) - d√πng cached radius
        const ballBottom = this.y + this.radius;
        const ballTop = this.y - this.radius;
        const ballLeft = this.x - this.radius;
        const ballRight = this.x + this.radius;
        
        if (ballBottom >= paddle.y &&
            ballTop <= paddle.y + paddle.height &&
            ballRight >= paddle.x &&
            ballLeft <= paddle.x + paddle.width) {
          // Bounce off paddle
          playPaddleBounce(); // Sound: ch·∫°m paddle
          this.vy = -Math.abs(this.vy);
          this.y = paddle.y - this.radius;
          
          // Add spin based on hit position
          const paddleCenter = paddle.x + paddle.width / 2;
          const hitOffset = (this.x - paddleCenter) / (paddle.width / 2);
          this.vx += hitOffset * 2;
        }

        // Ball falls off bottom = GAME OVER (mark inactive)
        if (this.y - this.radius > CONFIG.HEIGHT) {
          this.active = false;
        }
      }

      draw() {
        // Optimized rendering: unified approach for both mobile and desktop
        // B·ªè clip() ƒë·ªÉ tƒÉng performance (logo v·∫´n hi·ªÉn th·ªã t·ªët)
        if (binanceLogoLoaded) {
          // Draw white circular background
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw logo directly (no clip needed - logo is already circular/square)
          ctx.drawImage(
            binanceLogoImg,
            this.x - this.radius,
            this.y - this.radius,
            this.size,
            this.size
          );
        } else {
          // Fallback: Draw circular ball (purple) if logo not loaded yet
          ctx.fillStyle = '#ff00ff';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // ==========================================
    // POWERUPS
    // ==========================================
    const powerups = [];

    class Powerup {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'x2' or 'x3'
        this.size = CONFIG.POWERUP_SIZE;
        this.vy = CONFIG.POWERUP_FALL_SPEED;
        this.collected = false;
        this.rotation = 0;
      }

      update(deltaTime) {
        this.y += this.vy * deltaTime;
        this.rotation += 0.1 * deltaTime;

        // Check paddle collision
        if (this.y + this.size / 2 >= paddle.y &&
            this.y - this.size / 2 <= paddle.y + paddle.height &&
            this.x + this.size / 2 >= paddle.x &&
            this.x - this.size / 2 <= paddle.x + paddle.width) {
          
          // Play sound based on powerup type
          if (this.type === 'x3') {
            playPowerupX3(); // Sound: hit x3
          } else {
            playPowerupX2(); // Sound: hit x2
          }
          
          this.collected = true;
          
          // Multiply current balls
          const multiplier = this.type === 'x3' ? 3 : 2;
          const currentBalls = balls.filter(b => b.active);
          const ballsToAdd = Math.min(
            currentBalls.length * (multiplier - 1),
            CONFIG.MAX_BALLS - balls.length
          );
          
          for (let i = 0; i < ballsToAdd; i++) {
            const sourceBall = currentBalls[i % currentBalls.length];
            const newBall = new Ball(sourceBall.x, sourceBall.y, true);
            newBall.vx = sourceBall.vx + (Math.random() - 0.5) * 2;
            newBall.vy = sourceBall.vy + (Math.random() - 0.5);
            balls.push(newBall);
          }
        }

        // Remove if off screen
        if (this.y > CONFIG.HEIGHT) {
          this.collected = true;
        }
      }

      draw() {
        if (this.collected) return;

        // Optimized: B·ªè shadowBlur (t·ªën performance), ch·ªâ d√πng save/restore cho rotation
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        // Diamond shape (no shadow for better performance)
        ctx.fillStyle = this.type === 'x3' ? '#ff0000' : '#00ff00';
        ctx.beginPath();
        ctx.moveTo(0, -this.size / 2);
        ctx.lineTo(this.size / 2, 0);
        ctx.lineTo(0, this.size / 2);
        ctx.lineTo(-this.size / 2, 0);
        ctx.closePath();
        ctx.fill();

        // Label
        ctx.fillStyle = 'white';
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.type.toUpperCase(), 0, 0);

        ctx.restore();
      }
    }

    // ==========================================
    // BRICKS
    // ==========================================
    const bricks = [];

    class Brick {
      constructor(x, y, width, height, color) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.color = color;
        this.alive = true;
      }

      draw() {
        if (!this.alive) return;

        // Brick body only (optimized: removed highlight and border for performance)
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    // ==========================================
    // LEVEL GENERATION
    // ==========================================
    function generateLevel(level) {
      bricks.length = 0;
      
      // Calculate total bricks: 30 + (level-1) * 6
      const totalBricks = CONFIG.LEVEL1_BRICKS + (level - 1) * CONFIG.BRICKS_PER_LEVEL;
      
      // Find best rows/cols for rectangle (prefer square)
      let rows = Math.floor(Math.sqrt(totalBricks));
      let cols = Math.ceil(totalBricks / rows);
      
      // Adjust to fit exact count
      while (rows * cols < totalBricks) {
        cols++;
      }
      
      // Calculate brick size to fit screen
      const availableWidth = CONFIG.WIDTH - 40; // 20px margin each side
      const availableHeight = 400; // Top area for bricks
      
      let brickWidth = Math.floor((availableWidth - (cols + 1) * CONFIG.BRICK_PADDING) / cols);
      let brickHeight = Math.floor((availableHeight - (rows + 1) * CONFIG.BRICK_PADDING) / rows);
      
      // Thu nh·ªè g·∫°ch 25% (c√≤n 75%)
      brickWidth = Math.floor(brickWidth * 0.75);
      brickHeight = Math.floor(brickHeight * 0.75);
      
      // Center the brick field
      const totalWidth = cols * brickWidth + (cols + 1) * CONFIG.BRICK_PADDING;
      const startX = (CONFIG.WIDTH - totalWidth) / 2;
      const startY = 90; // Moved down 10px

      // Create solid rectangle of bricks (no pattern, all filled)
      // T√≠nh padding ƒë·ªÅu cho t·∫•t c·∫£ c√°c h√†ng (bao g·ªìm c·∫£ h√†ng ƒë·∫ßu v√† h√†ng sau)
      let brickCount = 0;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          if (brickCount >= totalBricks) break;
          
          // T√≠nh X: padding ƒë·∫ßu + (col * (brickWidth + padding))
          const x = startX + CONFIG.BRICK_PADDING + col * (brickWidth + CONFIG.BRICK_PADDING);
          
          // T√≠nh Y: padding ƒë·∫ßu + (row * (brickHeight + padding))
          // ƒê·∫£m b·∫£o padding ƒë·ªÅu gi·ªØa T·∫§T C·∫¢ c√°c h√†ng (h√†ng 0-1, 1-2, 2-3)
          const y = startY + CONFIG.BRICK_PADDING + row * (brickHeight + CONFIG.BRICK_PADDING);
          
          const color = getBrickColor(row, rows);
          
          bricks.push(new Brick(x, y, brickWidth, brickHeight, color));
          brickCount++;
        }
        if (brickCount >= totalBricks) break;
      }
      
      // Sort bricks by Y position (top to bottom) for optimized collision detection
      // This allows early exit when checking collisions (skip bricks too far below ball)
      bricks.sort((a, b) => a.y - b.y);
      
      // Get crypto name for display
      const logoIndex = (level - 1) % CRYPTO_LOGOS.length;
      gameState.currentLogo = CRYPTO_LOGOS[logoIndex].name;
    }

    function getBrickColor(row, totalRows) {
      // Th·ªëng nh·∫•t m√†u x√°m xanh cho t·∫•t c·∫£ g·∫°ch (t·ªëi ∆∞u lag - gi·∫£m context switching)
      return '#4a90a4'; // X√°m xanh (teal/gray-blue)
    }

    // ==========================================
    // CONTROLS
    // ==========================================
    let leftPressed = false;
    let rightPressed = false;

    const touchLeft = document.getElementById('touchLeft');
    const touchRight = document.getElementById('touchRight');

    // Touch zones (left/right half of screen)
    touchLeft.addEventListener('touchstart', (e) => {
      e.preventDefault();
      leftPressed = true;
    });
    touchLeft.addEventListener('touchend', (e) => {
      e.preventDefault();
      leftPressed = false;
    });
    touchLeft.addEventListener('mousedown', () => leftPressed = true);
    touchLeft.addEventListener('mouseup', () => leftPressed = false);

    touchRight.addEventListener('touchstart', (e) => {
      e.preventDefault();
      rightPressed = true;
    });
    touchRight.addEventListener('touchend', (e) => {
      e.preventDefault();
      rightPressed = false;
    });
    touchRight.addEventListener('mousedown', () => rightPressed = true);
    touchRight.addEventListener('mouseup', () => rightPressed = false);

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = true;
      if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = true;
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = false;
      if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = false;
    });

    // ==========================================
    // GAME LOOP
    // ==========================================
    let lastTime = 0;

    function gameLoop(currentTime) {
      requestAnimationFrame(gameLoop);
      
      // Always render (so game is visible behind overlay), only update when running
      render();
      
      if (!gameState.isRunning) return;
      
      const deltaTime = Math.min((currentTime - lastTime) / 16.67, 2);
      lastTime = currentTime;

      update(deltaTime, currentTime);
    }

    function update(deltaTime, currentTime) {
      // Update paddle
      paddle.vx = 0;
      if (leftPressed) paddle.vx = -CONFIG.PADDLE_SPEED;
      if (rightPressed) paddle.vx = CONFIG.PADDLE_SPEED;
      
      paddle.x += paddle.vx * deltaTime;
      paddle.x = Math.max(0, Math.min(CONFIG.WIDTH - paddle.width, paddle.x));

      // Update balls
      // Optimized: for loop thay v√¨ forEach (nhanh h∆°n ~10-20%)
      for (let i = 0; i < balls.length; i++) {
        const ball = balls[i];
        if (ball.active) {
          ball.update(deltaTime);

          // Check brick collisions (max 2 bricks per ball per frame)
          // Optimized: Early exit with Y-range check (skip bricks too far above/below ball)
          // Gi·∫£m ~70-80% collision checks ‚Üí gi·∫£m 10-15% lag
          const hitBricks = [];
          const ballY = ball.y;
          const checkRange = 100; // Ch·ªâ check bricks trong 100px (tr√™n/d∆∞·ªõi ball)
          // Cache collision bounds (t√≠nh 1 l·∫ßn, d√πng nhi·ªÅu l·∫ßn)
          const ballLeft = ball.x - ball.radius;
          const ballRight = ball.x + ball.radius;
          const ballTop = ball.y - ball.radius;
          const ballBottom = ball.y + ball.radius;
          
          for (let brick of bricks) {
            if (!brick.alive || hitBricks.length >= 2) continue;
            
            // Early exit: Skip bricks qu√° xa ph√≠a tr√™n ball (Y nh·ªè h∆°n nhi·ªÅu)
            if (brick.y < ballY - checkRange) continue;
            
            // Early exit: N·∫øu brick qu√° xa ph√≠a d∆∞·ªõi ball (Y l·ªõn h∆°n nhi·ªÅu), d·ª´ng lu√¥n
            // V√¨ bricks ƒë√£ ƒë∆∞·ª£c sort theo Y, c√°c bricks sau s·∫Ω c√≤n xa h∆°n
            if (brick.y > ballY + checkRange) break;
            
            // Ch·ªâ check collision cho bricks trong v√πng Y g·∫ßn ball
            if (ballRight >= brick.x &&
                ballLeft <= brick.x + brick.width &&
                ballBottom >= brick.y &&
                ballTop <= brick.y + brick.height) {
              hitBricks.push(brick);
            }
          }
          
          // If hit bricks, destroy them and bounce ONCE
          if (hitBricks.length > 0) {
            playBrickHit(); // Sound: bi ch·∫°m g·∫°ch
            
            let bounceX = false;
            let bounceY = false;
            
            // Optimized: for loop thay v√¨ forEach
            // Reuse cached collision bounds (kh√¥ng t√≠nh l·∫°i)
            for (let j = 0; j < hitBricks.length; j++) {
              const brick = hitBricks[j];
              // Determine collision side (d√πng l·∫°i ballLeft/Right/Top/Bottom ƒë√£ cache)
              
              const overlapLeft = ballRight - brick.x;
              const overlapRight = (brick.x + brick.width) - ballLeft;
              const overlapTop = ballBottom - brick.y;
              const overlapBottom = (brick.y + brick.height) - ballTop;
              
              const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
              
              if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                bounceX = true;
              } else {
                bounceY = true;
              }
              
              brick.alive = false;
              playBrickBreak(); // Sound: ph√° g·∫°ch
              gameState.score += 10;
              gameState.bricksDestroyed++;
              
              // Random powerup drop
              const rand = Math.random();
              if (rand < 0.05) {
                powerups.push(new Powerup(brick.x + brick.width / 2, brick.y + brick.height / 2, 'x3'));
              } else if (rand < 0.20) {
                powerups.push(new Powerup(brick.x + brick.width / 2, brick.y + brick.height / 2, 'x2'));
              }
            }
            
            // Apply bounce ONCE based on all hits
            if (bounceX) ball.vx = -ball.vx;
            if (bounceY) ball.vy = -ball.vy;
          }
        }
      }

      // Update powerups (optimized: for loop)
      for (let i = 0; i < powerups.length; i++) {
        const powerup = powerups[i];
        if (!powerup.collected) {
          powerup.update(deltaTime);
        }
      }

      // Remove collected powerups
      for (let i = powerups.length - 1; i >= 0; i--) {
        if (powerups[i].collected) {
          powerups.splice(i, 1);
        }
      }

      // Remove inactive balls
      for (let i = balls.length - 1; i >= 0; i--) {
        if (!balls[i].active) {
          balls.splice(i, 1);
        }
      }

      // No balls left - GAME OVER (ball fell off paddle)
      if (balls.length === 0) {
        endGame();
        return;
      }

      // Check level complete
      const aliveBricks = bricks.filter(b => b.alive).length;
      if (aliveBricks === 0) {
        nextLevel();
        return;
      }

      // Update timer
      const elapsed = currentTime - gameState.levelStartTime;
      gameState.timeRemaining = Math.max(0, CONFIG.LEVEL_TIME - elapsed) / 1000;

      // Time's up - game over
      if (gameState.timeRemaining <= 0) {
        endGame();
      }
    }

    function render() {
      // Clear canvas (pure black background, no stars)
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

      // Draw bricks (optimized: for loop)
      for (let i = 0; i < bricks.length; i++) {
        bricks[i].draw();
      }

      // Draw powerups (optimized: for loop)
      for (let i = 0; i < powerups.length; i++) {
        powerups[i].draw();
      }

      // Draw balls (optimized: for loop)
      for (let i = 0; i < balls.length; i++) {
        const ball = balls[i];
        if (ball.active) ball.draw();
      }

      // Draw paddle (optimized: ch·ªâ v·∫Ω body, b·ªè highlight v√† hitbox debug)
      ctx.fillStyle = paddle.color;
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

      // Draw UI
      ctx.fillStyle = 'white';
      ctx.font = 'bold 24px Courier New';
      
      // Top right: LV and time (inside 30px from right edge)
      ctx.textAlign = 'right';
      ctx.fillText(`LV ${gameState.level}`, CONFIG.WIDTH - 30, 35);
      ctx.fillText(`time ${Math.ceil(gameState.timeRemaining)}s`, CONFIG.WIDTH - 30, 65);
      
      // Top left: score (inside 15px from left edge)
      ctx.textAlign = 'left';
      ctx.fillText(`score`, 15, 35);
      ctx.fillText(`${gameState.score}`, 15, 65);
    }

    // ==========================================
    // GAME FLOW
    // ==========================================
    function startGame() {
      // Initialize audio (requires user gesture)
      initAudio();
      
      window.parent.postMessage({ 
        type: 'GAME_START', 
        gameId: 'brick-fallen-crypto' 
      }, '*');

      gameState = {
        isRunning: true,
        level: 1,
        score: 0,
        bricksDestroyed: 0,
        levelStartTime: performance.now(),
        timeRemaining: 30
      };

      paddle.x = CONFIG.WIDTH / 2 - CONFIG.PADDLE_WIDTH / 2;
      balls.length = 0;
      powerups.length = 0;
      
      generateLevel(1);
      spawnBall(true); // Random direction for first ball

      document.getElementById('startScreen').classList.remove('show');
      lastTime = performance.now();
    }

    function nextLevel() {
      if (gameState.level >= CONFIG.MAX_LEVEL) {
        // Won all 20 levels!
        endGame(true);
        return;
      }

      gameState.level++;
      gameState.levelStartTime = performance.now();
      gameState.timeRemaining = 30;
      
      // Show level screen
      gameState.isRunning = false;
      document.getElementById('levelTitle').textContent = `LEVEL ${gameState.level}`;
      document.getElementById('levelScreen').classList.add('show');
    }

    function startLevel() {
      document.getElementById('levelScreen').classList.remove('show');
      generateLevel(gameState.level);
      balls.length = 0;
      powerups.length = 0;
      // T·∫°o bi m·ªõi v·ªõi t·ªëc ƒë·ªô c·ªë ƒë·ªãnh (kh√¥ng ƒë·ªïi theo level)
      spawnBall(true); // Random direction for first ball
      gameState.isRunning = true;
      gameState.levelStartTime = performance.now();
    }

    function spawnBall(isFirstBall = false) {
      // Limit to max 15 balls
      if (balls.length >= CONFIG.MAX_BALLS) return;
      
      // T·∫°o bi m·ªõi v·ªõi t·ªëc ƒë·ªô c·ªë ƒë·ªãnh (CONFIG.BALL_SPEED_BASE kh√¥ng ƒë·ªïi theo level)
      const ball = new Ball(
        paddle.x + paddle.width / 2,
        paddle.y - 20,
        isFirstBall // Random direction for first ball
      );
      // ‚úÖ T·ªëc ƒë·ªô bi GI·ªÆ NGUY√äN ·ªü m·ªçi level (ch·ªâ ph·ª• thu·ªôc mobile/desktop)
      // ‚úÖ Ball speed does NOT increase with level - constant throughout all levels
      balls.push(ball);
    }

    function endGame(won = false) {
      gameState.isRunning = false;

      window.parent.postMessage({ 
        type: 'GAME_SCORE', 
        gameId: 'brick-fallen-crypto',
        score: gameState.score 
      }, '*');

      // Update score display
      document.getElementById('finalScore').textContent = gameState.score;
      
      // Display first story only (no random)
      const story = BNB_STORIES[0] || '';
      document.getElementById('bnbStory').textContent = story;
      
      // Ensure logo is visible
      const bnbLogoEl = document.getElementById('bnbLogo');
      if (bnbLogoEl) {
        bnbLogoEl.style.display = 'block';
      }
      
      if (won) {
        document.querySelector('.game-over-screen .screen-title').textContent = 'YOU WON!';
      } else {
        document.querySelector('.game-over-screen .screen-title').textContent = 'GAME OVER';
      }
      
      document.getElementById('gameOverScreen').classList.add('show');
    }

    function restartGame() {
      document.getElementById('gameOverScreen').classList.remove('show');
      startGame();
    }

    // ==========================================
    // INITIALIZE GAME (pre-render for preview)
    // ==========================================
    // Generate level 1 immediately so game is visible behind overlay
    generateLevel(1);
    render(); // Initial render
    
    // ==========================================
    // EVENT LISTENERS
    // ==========================================
    // Make entire start screen clickable
    const startScreen = document.getElementById('startScreen');
    startScreen.addEventListener('click', startGame);
    startScreen.addEventListener('touchstart', (e) => { e.preventDefault(); startGame(); }, { passive: false });
    document.getElementById('levelStartBtn').addEventListener('click', startLevel);
    document.getElementById('restartBtn').addEventListener('click', restartGame);

    // ==========================================
    // START GAME LOOP
    // ==========================================
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
