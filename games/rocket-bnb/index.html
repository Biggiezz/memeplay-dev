<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üöÄ BNB Rocket Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      background: #000;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }
    #gameCanvas {
      border: none;
      cursor: pointer;
      display: block;
      /* ‚úÖ Canvas internal: Always 720√ó1000px */
      /* CSS scales to fit screen, but graphics resolution stays fixed */
      width: 100%;
      height: 100%;
      object-fit: contain;
      /* Performance hints for iframe */
      will-change: transform;
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    .score {
      position: absolute;
      top: 55px;  /* Desktop: Moved down 25px (30 ‚Üí 55) */
      left: 50%;
      transform: translateX(-50%);
      font-size: 64px;
      color: #F3BA2F;
      text-shadow: 3px 3px 0 #000;
      font-weight: bold;
      z-index: 10;
    }
    @media (max-width: 768px) {
      .score {
        top: 40px;  /* Mobile: Higher by 10px (50 ‚Üí 40) */
        font-size: 48px;  /* Mobile: 25% smaller (64 ‚Üí 48) */
      }
    }
    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1E1A2E, #2A1E42);
      padding: 25px;
      border-radius: 15px;
      border: 3px solid #F3BA2F;
      text-align: center;
      color: #F3BA2F;
      display: none;
      z-index: 100;
      width: 420px;
      min-height: 420px; /* ‚úÖ Min height instead of fixed */
      height: auto; /* ‚úÖ Auto height to fit content */
      max-width: 90%;
      max-height: 90vh; /* ‚úÖ Max 90% viewport height */
      flex-direction: column;
      justify-content: space-between;
      overflow-y: auto; /* ‚úÖ Scroll if content too long */
    }
    .game-over.show { display: flex; }
    .game-over h2 { font-size: 26px; margin: 0; line-height: 1.2; }
    .game-over .score-text { font-size: 22px; margin: 0; font-weight: bold; }
    .token-showcase { margin: 10px 0; flex: 1; display: flex; flex-direction: column; justify-content: center; }
    .token-logo { 
      width: 140px; 
      height: 140px; 
      margin: 0 auto 15px; 
      display: block;
      border-radius: 50%;
      border: 2px solid #F3BA2F;
      object-fit: contain;
      background: transparent;
      padding: 2px;
    }
    .token-story { 
      font-size: 16px;  /* Increased 25% from 13px */
      line-height: 1.5; 
      color: #FFF; 
      margin: 0;
      text-align: left;
      padding: 0 5px;
      white-space: pre-line;
    }
    .game-over button {
      padding: 14px 30px;
      font-size: 18px;
      background: linear-gradient(135deg, #F3BA2F, #FCD535);
      color: #000;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      width: 100%;
      max-width: 280px;
      margin: 0 auto;
      display: block;
    }
    @media (max-width: 768px) {
      .game-over {
        padding: 20px;
        width: 85vw;
        min-height: 85vw; /* ‚úÖ Min height instead of fixed */
        height: auto; /* ‚úÖ Auto height to fit content */
        max-width: 420px;
        max-height: 85vh; /* ‚úÖ Max 85% viewport height on mobile */
      }
      .game-over h2 { 
        font-size: 22px;
        margin: 0;
      }
      .game-over .score-text { 
        font-size: 18px;
        margin: 0;
      }
      .token-logo { 
        width: 55px; 
        height: 55px;
        margin-bottom: 10px;
        object-fit: contain;
        padding: 3px;
      }
      .token-story { 
        font-size: 15px;  /* Increased 25% from 12px */
        line-height: 1.4;
        padding: 0;
      }
      .game-over button { 
        font-size: 14px;
        padding: 10px 20px;
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="score" id="score">0</div>
  <div class="game-over" id="gameOver">
    <h2>GAME OVER</h2>
    <div class="score-text">Score: <span id="finalScore">0</span></div>
    <div class="token-showcase">
      <img id="tokenLogo" src="" alt="Token Logo" class="token-logo">
      <p id="tokenStory" class="token-story"></p>
    </div>
    <button onclick="restart()">TO THE MOON AGAIN!</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { 
      alpha: false,              // No transparency = faster!
      desynchronized: true,      // Don't wait for compositor = smoother!
      willReadFrequently: false  // Write-only mode = faster!
    });
    ctx.imageSmoothingEnabled = false;  // Pixel art = no smoothing!
    
    // ‚úÖ Detect if running in iframe (localhost has overhead!)
    const isInIframe = window.self !== window.top;
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    if (isInIframe) {
      console.log('‚ö†Ô∏è Running in IFRAME - Using max performance mode!');
    }
    
    // Token story (single story)
    const tokenStory = "welcome to memeplay";
    
    // ‚úÖ Canvas always 720√ó1000px (same for desktop & mobile!)
    // CSS scales display, but graphics resolution stays fixed!
    canvas.width = 720;
    canvas.height = 1000;

    // Load rocket WebP (PIXEL ART - Clear Binance logo!)
    const img = new Image();
    img.src = 'assets/rocket-pixel.webp';
    let loaded = false;
    img.onload = () => {
      loaded = true;
      console.log('‚úÖ Rocket pixel art loaded!', img.width, 'x', img.height);
    };
    
    // Load 3 rock obstacles (random stacking)
    const rocks = [];
    const rockPaths = ['assets/rock1.webp', 'assets/rock2.webp', 'assets/rock3.webp'];
    let rocksLoaded = 0;
    rockPaths.forEach((path, i) => {
      rocks[i] = new Image();
      rocks[i].src = path;
      rocks[i].onload = () => {
        rocksLoaded++;
        if (rocksLoaded === 3) console.log('‚úÖ All 3 rocks loaded!');
      };
    });
    
    // ‚úÖ Placeholder: Yellow circle (creator can replace with custom logo)
    // TODO: Replace with custom logo image when using template
    
    // ==========================================
    // AUDIO (Mobile-safe unlock)
    // ==========================================
    const ctx2 = new (window.AudioContext || window.webkitAudioContext)();
    let audioUnlocked = false;
    
    // Unlock / resume audio on first real user gesture (required on mobile)
    function unlockAudio() {
      try {
        if (ctx2.state === 'suspended') {
          ctx2.resume().then(() => {
            if (audioUnlocked) return;
            audioUnlocked = true;
            // Silent click to fully unlock audio on iOS/Safari
            try {
              const o = ctx2.createOscillator();
              const g = ctx2.createGain();
              o.connect(g);
              g.connect(ctx2.destination);
              g.gain.setValueAtTime(0.0001, ctx2.currentTime);
              o.frequency.setValueAtTime(1, ctx2.currentTime);
              o.start(ctx2.currentTime);
              o.stop(ctx2.currentTime + 0.01);
            } catch (err) {
              console.log('Silent unlock error:', err);
            }
          }).catch(() => {});
        } else if (ctx2.state === 'running' && !audioUnlocked) {
          audioUnlocked = true;
          try {
            const o = ctx2.createOscillator();
            const g = ctx2.createGain();
            o.connect(g);
            g.connect(ctx2.destination);
            g.gain.setValueAtTime(0.0001, ctx2.currentTime);
            o.frequency.setValueAtTime(1, ctx2.currentTime);
            o.start(ctx2.currentTime);
            o.stop(ctx2.currentTime + 0.01);
          } catch (err) {}
        }
      } catch (e) {
        console.log('unlockAudio error:', e);
      }
    }
    
    function beep(freq, dur, type = 'square') {
      try {
        // Ensure context is running before playing (mobile)
        if (ctx2.state === 'suspended') {
          unlockAudio();
        }
      } catch (e) {}
      
      try {
        const o = ctx2.createOscillator();
        const g = ctx2.createGain();
        o.connect(g);
        g.connect(ctx2.destination);
        o.type = type;
        o.frequency.value = freq;
        g.gain.setValueAtTime(0.3, ctx2.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, ctx2.currentTime + dur);
        o.start();
        o.stop(ctx2.currentTime + dur);
      } catch (e) {
        console.log('beep error:', e);
      }
    }

    // Game vars
    let started = false;
    let gameOver = false;
    let score = 0;
    let frames = 0;
    
    // ‚úÖ MOBILE GAME SPEED BOOST +15% √ó 2 = +32% TOTAL!
    const MOBILE_GAME_SPEED = isMobile ? 1.3225 : 1.0;  // 1.15 √ó 1.15 = 1.3225 (+32% speed!)
    const MOBILE_PIPE_BOOST = isMobile ? 1.5 * MOBILE_GAME_SPEED : 1.0;  // 1.5 √ó 1.3225 = 1.984
    const MOBILE_GRAVITY_BOOST = isMobile ? 1.4 * MOBILE_GAME_SPEED : 1.0;  // 1.4 √ó 1.3225 = 1.851
    const MOBILE_SPAWN_ADJUST = isMobile ? 0.6 : 1.0;  // 0.75 √ó 0.8 = 0.6 (spawn 20% faster!)

    // Rocket
    const rocket = {
      x: 150,
      y: canvas.height / 2,
      w: 180,  // Rocket width +25% (144 ‚Üí 180)
      h: 156,  // Rocket height +25% (125 ‚Üí 156)
      vy: 0,
      
      draw() {
        if (!loaded) return;  // Don't draw if not loaded
        
        const rot = Math.max(-30, Math.min(30, this.vy * 4.86)) * Math.PI / 180;
        const centerX = this.x + this.w/2;
        const centerY = this.y + this.h/2;
        
        // ‚úÖ Optimize: Only save/restore if rotating
        if (Math.abs(rot) > 0.01) {
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(rot);
          ctx.drawImage(img, -this.w/2, -this.h/2, this.w, this.h);
          ctx.restore();
        } else {
          // No rotation = direct draw (faster!)
          ctx.drawImage(img, this.x, this.y, this.w, this.h);
        }
      },
      
      update() {
        if (!started || gameOver) return;
        this.vy += 0.312 * MOBILE_GRAVITY_BOOST;
        this.y += this.vy;
        
        // ‚ùå Removed canvas collision - let rocks collision handle all
      },
      
      jump() {
        if (gameOver) return;
        
        // ‚úÖ Send GAME_START on first jump (for playtime tracking!)
        if (!started) {
          started = true;
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'GAME_START',
              gameId: 'rocket-bnb'
            }, '*');
            console.log('üì§ Sent GAME_START to parent');
          }
        }
        
        // ‚úÖ Jump force increased 32% on mobile! (1.15 √ó 1.15)
        const jumpForce = -5.76 * (isMobile ? 1.3225 : 1.0);  // Mobile: -7.618
        this.vy = jumpForce;
        beep(400, 0.1);
      }
    };

    // ‚ú® Background gradient + stars (PRE-RENDERED for max performance!)
    const bgCanvas = document.createElement('canvas');
    bgCanvas.width = 720;
    bgCanvas.height = 1000;
    const bgCtx = bgCanvas.getContext('2d');
    
    // Render gradient
    const bgGradient = bgCtx.createLinearGradient(0, 0, 0, bgCanvas.height);
    bgGradient.addColorStop(0, '#1A0A2E');     // Deep purple top
    bgGradient.addColorStop(0.5, '#2D1B4E');   // Medium purple middle
    bgGradient.addColorStop(1, '#0F051D');     // Dark purple/black bottom
    bgCtx.fillStyle = bgGradient;
    bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
    
    // Render stars (adaptive: 5 stars ONLY for max smoothness!)
    const starCount = 5;  // Minimal stars = max performance!
    bgCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    for (let i = 0; i < starCount; i++) {
      const x = Math.random() * bgCanvas.width;
      const y = Math.random() * bgCanvas.height;
      const size = 2;  // Fixed size = consistent
      bgCtx.fillRect(x, y, size, size);
    }
    
    // ‚úÖ Background = 1 image! Draw once per frame = FAST!

    // Coins/Collectibles (logo coin only)
    const coins = [];
    class Coin {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 80;  // 80√ó80px!
        this.collected = false;
      }
      
      draw() {
        if (this.collected) return;
        
        // ‚úÖ Placeholder: Yellow circle (creator can replace with custom logo)
        // TODO: Replace with: ctx.drawImage(customLogoImg, this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        ctx.save();
        ctx.fillStyle = '#F3BA2F';  // Yellow color (same as game theme)
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
        ctx.fill();
        // Add inner circle for depth
        ctx.fillStyle = '#FFD700';  // Gold color
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size/2 - 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      
      update() {
        if (!started || gameOver || this.collected) return;
        this.x -= 2.72 * MOBILE_PIPE_BOOST;
        
        // Check collision with rocket
        const dist = Math.hypot(this.x - (rocket.x + rocket.w/2), this.y - (rocket.y + rocket.h/2));
        if (dist < (this.size + Math.min(rocket.w, rocket.h)) / 2) {
          this.collected = true;
          score += 5;  // +5 points!
          document.getElementById('score').textContent = score;
          beep(800, 0.15, 'sine');  // Collection sound
        }
      }
    }

    // Obstacles (3 rocks stacked vertically)
    const pipes = [];
    class Pipe {
      constructor() {
        this.x = canvas.width;
        this.w = 144;  // Rock width
        // ‚úÖ Visual gap 230-320, after shrink (¬±10px) ‚Üí SAFE gap = 250-340px!
        this.gap = 230 + Math.random() * 90;  // Gap: 230-320px
        this.top = Math.random() * (canvas.height - this.gap - 100) + 50;
        this.passed = false;
        this.rockSize = 144;  // Bigger rocks +20%
        this.rocksPerColumn = 3;  // Only 3 rocks per column
        this.rockSpacing = 0;  // Tightly packed
        // Random rock types for 3 rocks
        this.topRocks = [
          Math.floor(Math.random() * 3),
          Math.floor(Math.random() * 3),
          Math.floor(Math.random() * 3)
        ];
        this.bottomRocks = [
          Math.floor(Math.random() * 3),
          Math.floor(Math.random() * 3),
          Math.floor(Math.random() * 3)
        ];
      }
      
      draw() {
        if (rocksLoaded < 3) return;
        
        const rockW = this.rockSize;
        const rockH = this.rockSize;
        const overlap = 3;
        const rockShrinkY = 10;
        
        // ‚úÖ OPTIMIZED: Calculate count, then batch draw (fewer state changes!)
        const effectiveRockH = rockH - overlap;
        
        // TOP ROCKS
        const topGapEdge = this.top - rockShrinkY;
        const topRocksCount = Math.ceil(topGapEdge / effectiveRockH);
        
        for (let i = 0; i < topRocksCount; i++) {
          const rockType = this.topRocks[i % 3];
          const yPos = topGapEdge - (i + 1) * effectiveRockH;
          if (yPos + rockH > 0) {  // Only draw if visible
            ctx.drawImage(rocks[rockType], this.x, yPos, rockW, rockH);
          }
        }
        
        this.actualTopRockBottom = topGapEdge;
        
        // BOTTOM ROCKS
        const bottomGapEdge = this.top + this.gap + rockShrinkY;
        const bottomRocksCount = Math.ceil((canvas.height - bottomGapEdge) / effectiveRockH);
        
        for (let i = 0; i < bottomRocksCount; i++) {
          const rockType = this.bottomRocks[i % 3];
          const yPos = bottomGapEdge + i * effectiveRockH;
          if (yPos < canvas.height) {  // Only draw if visible
            ctx.drawImage(rocks[rockType], this.x, yPos, rockW, rockH);
          }
        }
        
        this.actualBottomRockTop = bottomGapEdge;
      }
      
      update() {
        if (!started || gameOver) return;
        this.x -= 2.72 * MOBILE_PIPE_BOOST;
        
        // ‚úÖ COLLISION = BLUE HITBOX 125√ó73 (OFFSET UP 9px!)
        
        // Rocket hitbox: 125√ó73 (width stays same, height -10%, offset UP 9px)
        const hitboxW = 125;
        const hitboxH = 73;
        const offsetUp = 9;  // Pull hitbox UP 9px!
        const rocketShrinkX = (rocket.w - hitboxW) / 2;  // (180-125)/2 = 27.5
        const rocketShrinkY = (rocket.h - hitboxH) / 2 - offsetUp;  // 41.5 - 9 = 32.5
        const rocketLeft = rocket.x + rocketShrinkX;
        const rocketRight = rocket.x + rocket.w - rocketShrinkX;
        const rocketTop = rocket.y + rocketShrinkY;  // Higher by 9px!
        const rocketBottom = rocket.y + rocketShrinkY + hitboxH;  // = rocketTop + 73
        
        // Rock hitbox: Shrink WIDTH by 15%!
        const rockShrinkX = 20;  // Width shrinks more
        const rockShrinkY = 10;  // Height shrinks less
        const rockLeft = this.x + rockShrinkX;
        const rockRight = this.x + this.w - rockShrinkX;
        const topRockBottom = this.actualTopRockBottom - rockShrinkY;
        const bottomRockTop = this.actualBottomRockTop;  // ‚úÖ Already OFFSET +10!
        
        // Canvas boundaries (with shrink)
        if (rocketTop < rockShrinkY || rocketBottom > canvas.height - rockShrinkY) {
          console.log('üí• HIT CANVAS!');
          beep(200, 0.2, 'sawtooth');
          end();
        }
        
        // Rock collision - WHEN BLUE HITBOXES TOUCH!
        const horizontalOverlap = rocketRight > rockLeft && rocketLeft < rockRight;
        const hitTopRock = rocketTop < topRockBottom;
        const hitBottomRock = rocketBottom > bottomRockTop;
        
        if (horizontalOverlap && (hitTopRock || hitBottomRock)) {
          console.log('üí• HITBOX COLLISION!', {
            'Rocket': { x: rocket.x, y: rocket.y, w: rocket.w, h: rocket.h },
            'Rock': { x: this.x, topBottom: topRockBottom, bottomTop: bottomRockTop }
          });
          beep(200, 0.2, 'sawtooth');
          end();
        }
        
        // Score when passed
        if (!this.passed && this.x + this.w < rocket.x) {
          this.passed = true;
          score++;
          document.getElementById('score').textContent = score;
          beep(800, 0.1, 'sine');
        }
      }
    }

    function spawn() {
      if (!started || gameOver) return;
      const rate = Math.floor(158 * MOBILE_SPAWN_ADJUST);
      if (frames % rate === 0) {
        const newPipe = new Pipe();
        pipes.push(newPipe);
        
        // Spawn coin 50% chance IN MIDDLE OF HORIZONTAL GAP (between 2 rock columns)
        if (Math.random() < 0.5 && pipes.length > 0) {
          const prevPipe = pipes[pipes.length - 2];
          if (prevPipe) {
            // X = Middle of 2 rock columns (prevPipe and newPipe)
            const coinX = prevPipe.x + (newPipe.x - prevPipe.x) / 2;
            // Y = Random in safe zone (100-900)
            const coinY = 100 + Math.random() * 800;
            coins.push(new Coin(coinX, coinY));
          }
        }
      }
    }

    function loop() {
      try {
        // ‚ú® Draw pre-rendered background (1 drawImage vs 60+ operations!)
        ctx.drawImage(bgCanvas, 0, 0);
        
        // Debug: Check if images loaded
        if (!loaded) {
          ctx.fillStyle = 'white';
          ctx.font = '20px monospace';
          ctx.fillText('Loading rocket...', 50, 50);
        }
        if (rocksLoaded < 3) {
          ctx.fillStyle = 'white';
          ctx.font = '20px monospace';
          ctx.fillText(`Loading rocks... ${rocksLoaded}/3`, 50, 80);
        }
        
        rocket.update();
        rocket.draw();
        
        spawn();
        
        // ‚úÖ Optimize: Loop backward for safe splice
        for (let i = pipes.length - 1; i >= 0; i--) {
          pipes[i].update();
          pipes[i].draw();
          if (pipes[i].x + pipes[i].w < 0) pipes.splice(i, 1);
        }
        
        // Update & draw coins (backward loop)
        for (let i = coins.length - 1; i >= 0; i--) {
          coins[i].update();
          coins[i].draw();
          if (coins[i].x < -50 || coins[i].collected) coins.splice(i, 1);
        }
        
        frames++;
        requestAnimationFrame(loop);
      } catch (err) {
        console.error('üí• GAME LOOP ERROR:', err);
        ctx.fillStyle = 'red';
        ctx.font = '16px monospace';
        ctx.fillText('ERROR: ' + err.message, 50, 100);
      }
    }

    function end() {
      if (gameOver) return;
      gameOver = true;
      document.getElementById('finalScore').textContent = score;
      
      // ‚úÖ Send score to parent (MemePlay) for achievements & playtime rewards!
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: 'GAME_SCORE',
          score: score,
          gameId: 'rocket-bnb'
        }, '*');
        console.log('üì§ Sent GAME_SCORE to parent:', score);
      }
      
      // Update UI - Placeholder yellow circle (creator can replace with custom logo)
      // TODO: Replace with: logoEl.src = 'path/to/custom-logo.png';
      const logoEl = document.getElementById('tokenLogo');
      logoEl.src = '';  // Clear image source
      logoEl.style.width = '140px';
      logoEl.style.height = '140px';
      logoEl.style.padding = '0';
      logoEl.style.border = '2px solid #F3BA2F';
      logoEl.style.borderRadius = '50%';
      logoEl.style.background = 'linear-gradient(135deg, #F3BA2F, #FFD700)';
      logoEl.style.objectFit = 'none';  // Don't show image, show background
      
      document.getElementById('tokenStory').textContent = tokenStory;
      document.getElementById('gameOver').classList.add('show');
      
      beep(800, 0.5);
    }

    function restart() {
      gameOver = false;
      started = false;
      score = 0;
      frames = 0;
      pipes.length = 0;
      coins.length = 0;  // Clear coins
      rocket.y = canvas.height / 2;
      rocket.vy = 0;
      document.getElementById('score').textContent = '0';
      document.getElementById('gameOver').classList.remove('show');
    }

    canvas.addEventListener('click', () => {
      unlockAudio();
      rocket.jump();
    });
    canvas.addEventListener('touchstart', (e) => { 
      e.preventDefault(); 
      unlockAudio();
      rocket.jump(); 
    });
    document.addEventListener('keydown', (e) => { 
      if (e.code === 'Space') { 
        e.preventDefault(); 
        unlockAudio();
        rocket.jump(); 
      }
    });

    loop();
    console.log('üöÄ BNB Rocket - OPTIMIZED FOR IFRAME!');
    console.log('ü™ô Collectibles: 80√ó80px CIRCULAR (clipped!)');
    console.log('üéØ Game over logo: 140√ó140px (desktop)');
    console.log('üí∞ Value: +5 points each');
    console.log('‚ú® Stars: 5 only (max performance!)');
    console.log('‚ö° Pre-rendered background');
    console.log('üì± Canvas: 720√ó1000px');
    console.log('üéÆ Mode:', isMobile ? 'MOBILE' : 'DESKTOP');
  </script>
</body>
</html>

