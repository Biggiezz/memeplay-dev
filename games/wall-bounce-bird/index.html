<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Wall Bounce Bird</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #040b1a;
      color: #fff;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    body {
      position: relative;
    }
    .game-container {
      position: relative;
      width: min(100vw, 720px);
      margin: 0 auto;
      height: auto;
    }
    canvas {
      display: block;
      width: min(100vw, 720px);
      aspect-ratio: 720 / 1000;
      max-height: 100vh;
      margin: 0 auto;
      background: #87ceeb;
      border-radius: 28px;
      box-shadow: 0 30px 120px rgba(0,0,0,0.35);
      touch-action: none;
      object-fit: contain;
    }
    .hud {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      display: flex;
      justify-content: space-between;
      font-weight: 700;
      letter-spacing: 0.05em;
      font-size: clamp(16px, 2vw, 24px);
      text-shadow: 0 4px 14px rgba(0,0,0,0.45);
      pointer-events: none;
      z-index: 5;
    }
    #scoreLabel {
      position: relative;
      left: 50px;
      top: 10px;
      font-size: clamp(27.2px, 3.4vw, 40.8px); /* 70% larger than default */
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 24px;
      z-index: 10;
    }
    .overlay.hidden { display: none; }
    .overlay-card {
      width: min(420px, 90vw);
      background: rgba(5,7,14,0.92);
      border: 1px solid rgba(255,196,106,0.45);
      border-radius: 20px;
      padding: 32px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      box-shadow: 0 20px 80px rgba(0,0,0,0.6);
    }
    .overlay-card h1 {
      margin: 0;
      font-size: clamp(32px, 8vw, 48px);
      letter-spacing: 0.12em;
      color: #ffd447;
    }
    .overlay-card p { margin: 0; line-height: 1.5; color: #e6ecff; }
    .overlay-card button,
    #startBtn {
      padding: 14px 22px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(120deg, #ffd447, #ff9a2f);
      color: #1d0f00;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 12px 30px rgba(255,148,55,0.35);
      transition: transform 0.2s ease;
      animation: blink 1.5s ease-in-out infinite;
    }
    .overlay-card button:active,
    #startBtn:active { transform: scale(0.96); }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .promo-text {
      font-style: italic;
      color: #c8d6ff;
      font-size: 15px;
      opacity: 0.9;
    }
    .game-over-logo {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 3px solid #ffd447;
      object-fit: contain;
      margin: 0 auto 20px;
      display: block;
      background: rgba(255, 255, 255, 0.1);
      padding: 8px;
    }
    @media (max-width: 768px) {
      .hud { top: 12px; font-size: 16px; }
      canvas { 
        width: calc(100vw - 16px);
        aspect-ratio: 720 / 1000;
        max-height: calc(100vh - 24px);
      }
      .overlay-card { padding: 24px; }
      .game-over-logo {
        width: 80px;
        height: 80px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="hud" id="hud" aria-live="polite">
      <span id="scoreLabel">Score: 0</span>
    </div>
    <canvas id="game" width="720" height="1000" style="height: 100%;"></canvas>

    <div class="overlay" id="startOverlay">
      <button id="startBtn">Tap to Start</button>
    </div>

    <div class="overlay hidden" id="gameOverOverlay">
      <div class="overlay-card">
        <h1>GAME OVER</h1>
        <img id="gameOverLogo" class="game-over-logo" src="" alt="Logo" style="display: none;">
        <p id="finalScoreText">Score: 0</p>
        <p class="promo-text" id="promoText"></p>
        <button id="retryBtn">Play Again</button>
      </div>
    </div>
  </div>

  <script>
    // ✅ Get gameId from URL (like Pacman and Blocks 8x8)
    function getGameId() {
      const url = new URL(window.location.href);
      const gameIdFromQuery = url.searchParams.get('game');
      if (gameIdFromQuery) return gameIdFromQuery;
      return null;
    }
    const EMBEDDED_GAME_ID = getGameId() || 'wall-bounce-bird';
    
    // ✅ FIX: Load config from localStorage khi khởi động (giống Pacman/Blocks) - Đảm bảo hoạt động trên mobile
    function loadBrandConfigFromLocalStorage(gameId) {
      if (!gameId || gameId === 'wall-bounce-bird') return false;
      const storageKey = `wall_bounce_bird_config_${gameId}`;
      const saved = localStorage.getItem(storageKey);
      if (!saved) return false;
      
      try {
        const config = JSON.parse(saved);
        if (!config) return false;
        
        // Apply background color
        if (config.backgroundColor) {
          state.backgroundColor = config.backgroundColor;
        }
        
        // Apply logo
        if (config.fragmentLogoUrl) {
          state.customLogo = config.fragmentLogoUrl;
          const logoImg = new Image();
          logoImg.onload = () => {
            state.customLogoImage = logoImg;
          };
          logoImg.onerror = () => {
            state.customLogoImage = null;
          };
          logoImg.src = config.fragmentLogoUrl;
        }
        
        // Apply story
        if (config.story) {
          state.customStory = config.story;
        }
        
        return true;
      } catch (e) {
        return false;
      }
    }
    
    // ✅ Load config ngay khi khởi động (trước khi resetGame)
    if (EMBEDDED_GAME_ID && EMBEDDED_GAME_ID !== 'wall-bounce-bird') {
      loadBrandConfigFromLocalStorage(EMBEDDED_GAME_ID);
    }
    
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { desynchronized: true });
    const scoreLabel = document.getElementById('scoreLabel');
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const finalScoreText = document.getElementById('finalScoreText');
    const promoText = document.getElementById('promoText');
    const startBtn = document.getElementById('startBtn');
    const retryBtn = document.getElementById('retryBtn');

    const PROMOS = [
      "From wild idea to global market – it all starts at Four Meme.",
      "Where memecoins are more than a joke – they're a blockchain movement.",
      "No code, no dev skills – just your meme and a little BNB.",
      "Four Meme turns spontaneous ideas into viral tokens on BNB Chain in minutes.",
      "With just a few clicks, you can create your own memecoin and instantly list it on PancakeSwap."
    ];

    const CONFIG = {
      WIDTH: 720,
      HEIGHT: 1000,
      GRAVITY: 0.6,
      JUMP_FORCE: -10,
      HORIZONTAL_SPEED: 6,
      WALL_OFFSET: 0,
      BIRD_SIZE: 115,
      BIRD_HITBOX_SIZE: 55,
      SPIKE_SIZE: 40,
      TOP_SPIKE_HEIGHT: 30,
      PILL_SIZE: 56,
      PILL_POINTS: 5,
      PARTICLES: { desktop: 8, mobile: 2 }, // Reduced for better performance
      PILL_AREA: { minX: 150, maxX: 570, minY: 200, maxY: 600 },
      DEBUG_HITBOXES: false // Disabled - hitboxes removed after testing
    };

    const state = {
      running: false,
      started: false,
      gameOver: false, // Flag to prevent floatIdleBird when game is over
      score: 0,
      bird: null,
      spikesLeft: [],
      spikesRight: [],
      topSpikes: [],
      bottomSpikes: [],
      cachedTopBottomCanvas: null, // Cached canvas for top and bottom spikes (static)
      pill: null,
      particles: [],
      scoreTexts: [],
      lastBounceTime: 0,
      spikesLeftCount: 2,
      spikesRightCount: 2,
      customLogo: null,      // Logo from editor (used for pill)
      customLogoImage: null,  // Loaded logo image object
      customStory: null,     // Story from editor
      backgroundColor: '#87ceeb',  // Background color from editor
      perfStats: {
        collisionTime: 0,
        frameCount: 0,
        totalCollisionTime: 0,
        particlesTime: 0,
        scoreTextsTime: 0,
        totalParticlesTime: 0,
        totalScoreTextsTime: 0
      }
    };

    const isMobile = /Mobi|Android/i.test(navigator.userAgent);

    const birdImage = new Image();
    let birdImageLoaded = false;
    let birdImageRatio = 1;
    // Cached flipped images for better performance (no transform needed each frame)
    let birdImageLeft = null;
    let birdImageRight = null;
    
    // Load and process original image
    const originalBirdImage = new Image();
    originalBirdImage.src = 'bird.webp';
    originalBirdImage.onload = () => {
      // Process image to remove white background while preserving eye colors
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = originalBirdImage.width;
      tempCanvas.height = originalBirdImage.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Draw original image
      tempCtx.drawImage(originalBirdImage, 0, 0);
      
      // Get image data
      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      const data = imageData.data;
      
      // Process pixels: make white background transparent, preserve eye colors
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        
        // Check if pixel is white (background)
        // Use threshold to detect white: r, g, b all > 250
        // This preserves eye white which might have slight variations or black pixels nearby
        if (r > 250 && g > 250 && b > 250) {
          // Make white background transparent
          data[i + 3] = 0; // Set alpha to 0
        }
        // All other pixels (red body, green wing/tail, white/black eye) remain unchanged
      }
      
      // Put processed image data back
      tempCtx.putImageData(imageData, 0, 0);
      
      // Load processed image into birdImage
      birdImage.onload = () => {
        birdImageLoaded = true;
        if (birdImage.width && birdImage.height) {
          birdImageRatio = birdImage.width / birdImage.height;
          
          // Create cached flipped images (left and right) for better performance
          const cacheCanvas = document.createElement('canvas');
          cacheCanvas.width = birdImage.width;
          cacheCanvas.height = birdImage.height;
          const cacheCtx = cacheCanvas.getContext('2d');
          
          // Create right-facing image (normal)
          cacheCtx.clearRect(0, 0, cacheCanvas.width, cacheCanvas.height);
          cacheCtx.drawImage(birdImage, 0, 0);
          birdImageRight = new Image();
          birdImageRight.src = cacheCanvas.toDataURL('image/png');
          
          // Create left-facing image (flipped horizontally)
          cacheCtx.clearRect(0, 0, cacheCanvas.width, cacheCanvas.height);
          cacheCtx.setTransform(-1, 0, 0, 1, birdImage.width, 0);
          cacheCtx.drawImage(birdImage, 0, 0);
          cacheCtx.setTransform(1, 0, 0, 1, 0, 0);
          birdImageLeft = new Image();
          birdImageLeft.src = cacheCanvas.toDataURL('image/png');
        }
      };
      birdImage.src = tempCanvas.toDataURL('image/png');
    };


    class Bird {
      constructor() {
        this.x = CONFIG.WIDTH / 2;
        this.y = CONFIG.HEIGHT / 2;
        this.vx = 0;
        this.vy = 0;
        this.size = CONFIG.BIRD_SIZE;
        this.hitboxSize = CONFIG.BIRD_HITBOX_SIZE;
        // Hitbox offset to align with bird center
        this.hitboxOffsetX = 0;
        this.hitboxOffsetY = 4; // Offset down 4px to center hitbox with bird
        this.active = false;
        this.direction = 1;
      }
      update(dt) {
        if (!this.active) return;
        // Stop updating if game is over (freeze bird at collision position)
        if (state.running === false) return;
        this.vy += CONFIG.GRAVITY * dt;
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Boundary check: prevent bird from going too far, but don't trigger game over
        // Actual collision with spikes is checked in checkCollisions()
        const half = this.size / 2;
        if (this.y - half < 0) {
          this.y = half;
        }
        if (this.y + half > CONFIG.HEIGHT) {
          this.y = CONFIG.HEIGHT - half;
        }

        const hitboxHalf = this.hitboxSize / 2;
        const birdCenterX = this.x + this.hitboxOffsetX;
        if (birdCenterX - hitboxHalf <= CONFIG.WALL_OFFSET) {
          this.x = CONFIG.WALL_OFFSET + hitboxHalf - this.hitboxOffsetX;
          wallBounce(1);
        } else if (birdCenterX + hitboxHalf >= CONFIG.WIDTH - CONFIG.WALL_OFFSET) {
          this.x = CONFIG.WIDTH - CONFIG.WALL_OFFSET - hitboxHalf - this.hitboxOffsetX;
          wallBounce(-1);
        }
      }
      draw() {
        const half = this.size / 2;
        
        if (birdImageLoaded && birdImageLeft && birdImageRight) {
          // Optimized: Use cached flipped images instead of transform (much faster)
          // Bird image is centered at (this.x, this.y)
          const drawHeight = this.size;
          const drawWidth = this.size * birdImageRatio;
          // direction = 1 means flip (left), direction = -1 means no flip (right)
          // This matches the old logic: setTransform(-direction, ...) where -1 flips and 1 doesn't
          const imageToDraw = this.direction === 1 ? birdImageLeft : birdImageRight;
          // Center the image at bird position
          ctx.drawImage(imageToDraw, this.x - drawWidth / 2, this.y - drawHeight / 2, drawWidth, drawHeight);
        } else if (birdImageLoaded) {
          // Fallback: Use transform if cached images not ready yet
          ctx.setTransform(-this.direction, 0, 0, 1, this.x, this.y);
          const drawHeight = this.size;
          const drawWidth = this.size * birdImageRatio;
          ctx.drawImage(birdImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
          ctx.setTransform(1, 0, 0, 1, 0, 0);
        } else {
          ctx.fillStyle = '#d93232';
          ctx.beginPath();
          ctx.roundRect(-half, -half, this.size, this.size, 18);
          ctx.fill();

          ctx.fillStyle = '#f5a623';
          ctx.beginPath();
          ctx.moveTo(half - 10, -10);
          ctx.lineTo(half + 15, -2);
          ctx.lineTo(half - 10, 6);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = '#ffd447';
          ctx.beginPath();
          ctx.moveTo(-half + 8, -half + 6);
          ctx.lineTo(-half + 20, -half - 8);
          ctx.lineTo(-half + 32, -half + 10);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(half - 18, -10, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(half - 15, -10, 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // Reset transform instead of restore (faster)
        ctx.setTransform(1, 0, 0, 1, 0, 0);

      }
    }

    class Spike {
      constructor(y, side) {
        this.y = y;
        this.side = side;
      }
      draw() {
        ctx.fillStyle = '#737373';
        ctx.beginPath();
        if (this.side === 'left') {
          ctx.moveTo(CONFIG.WALL_OFFSET + CONFIG.SPIKE_SIZE, this.y);
          ctx.lineTo(CONFIG.WALL_OFFSET, this.y - CONFIG.SPIKE_SIZE / 2);
          ctx.lineTo(CONFIG.WALL_OFFSET, this.y + CONFIG.SPIKE_SIZE / 2);
        } else {
          ctx.moveTo(CONFIG.WIDTH - CONFIG.WALL_OFFSET - CONFIG.SPIKE_SIZE, this.y);
          ctx.lineTo(CONFIG.WIDTH - CONFIG.WALL_OFFSET, this.y - CONFIG.SPIKE_SIZE / 2);
          ctx.lineTo(CONFIG.WIDTH - CONFIG.WALL_OFFSET, this.y + CONFIG.SPIKE_SIZE / 2);
        }
        ctx.closePath();
        ctx.fill();

      }
      hit(bird) {
        // Early exit: Quick distance check before expensive collision calculation
        // Calculate bird center position
        const birdCenterX = bird.x + bird.hitboxOffsetX;
        const birdCenterY = bird.y + bird.hitboxOffsetY;
        
        // Calculate spike center position
        const spikeX = this.side === 'left'
          ? CONFIG.WALL_OFFSET + CONFIG.SPIKE_SIZE / 2
          : CONFIG.WIDTH - CONFIG.WALL_OFFSET - CONFIG.SPIKE_SIZE / 2;
        const spikeY = this.y;
        
        // Calculate distance squared (avoid sqrt for performance)
        const dx = birdCenterX - spikeX;
        const dy = birdCenterY - spikeY;
        const maxDist = bird.hitboxSize / 2 + CONFIG.SPIKE_SIZE;
        const maxDistSquared = maxDist * maxDist;
        const distSquared = dx * dx + dy * dy;
        
        // If too far away, definitely no collision - skip expensive calculation
        if (distSquared > maxDistSquared) {
          return false;
        }
        
        // Close enough - perform detailed triangle collision check
        const tri = this.side === 'left'
          ? [
              { x: CONFIG.WALL_OFFSET + CONFIG.SPIKE_SIZE, y: this.y },
              { x: CONFIG.WALL_OFFSET, y: this.y - CONFIG.SPIKE_SIZE / 2 },
              { x: CONFIG.WALL_OFFSET, y: this.y + CONFIG.SPIKE_SIZE / 2 }
            ]
          : [
              { x: CONFIG.WIDTH - CONFIG.WALL_OFFSET - CONFIG.SPIKE_SIZE, y: this.y },
              { x: CONFIG.WIDTH - CONFIG.WALL_OFFSET, y: this.y - CONFIG.SPIKE_SIZE / 2 },
              { x: CONFIG.WIDTH - CONFIG.WALL_OFFSET, y: this.y + CONFIG.SPIKE_SIZE / 2 }
            ];
        return intersectsCircleTriangle(bird, tri);
      }
    }

    class Pill {
      constructor() {
        this.active = false;
        this.x = 0;
        this.y = 0;
        this.size = CONFIG.PILL_SIZE;
      }
      spawn() {
        this.active = true;
        this.x = rand(CONFIG.PILL_AREA.minX, CONFIG.PILL_AREA.maxX);
        this.y = rand(CONFIG.PILL_AREA.minY, CONFIG.PILL_AREA.maxY);
      }
      draw() {
        if (!this.active) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // If custom logo is available, draw logo instead of gradient pill
        if (state.customLogoImage && state.customLogoImage.complete) {
          ctx.drawImage(
            state.customLogoImage,
            -this.size / 2,
            -this.size / 2,
            this.size,
            this.size
          );
        } else {
          // Default gradient pill
          const grd = ctx.createRadialGradient(0, 0, 6, 0, 0, this.size / 2);
          grd.addColorStop(0, '#fff6d1');
          grd.addColorStop(0.5, '#ffd447');
          grd.addColorStop(1, '#f05a28');
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
          ctx.fill();
        }

        // Reset transform instead of restore (faster)
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      hit(bird) {
        if (!this.active) return false;
        const birdCenterX = bird.x + bird.hitboxOffsetX;
        const birdCenterY = bird.y + bird.hitboxOffsetY;
        const dx = birdCenterX - this.x;
        const dy = birdCenterY - this.y;
        const dist = Math.hypot(dx, dy);
        return dist < (bird.hitboxSize / 2 + this.size / 2);
      }
    }

    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = rand(1.6, 6.4);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 0.48;
        this.maxLife = 0.48;
      }
      update(dt) {
        this.life -= dt / 60;
        this.x += this.vx;
        this.y += this.vy + 0.15;
      }
      draw() {
        // Drawing is now handled in batch in the main loop for better performance
        // This method is kept for compatibility but not used
      }
    }

    class ScoreText {
      constructor(x, y, text) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.life = 0.4;
      }
      update(dt) {
        this.life -= dt / 60;
        this.y -= 1.3;
      }
      draw() {
        if (this.life <= 0) return;
        ctx.globalAlpha = Math.max(this.life / 0.4, 0);
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 28px Inter';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
      }
    }

    function intersectsCircleTriangle(bird, [v1, v2, v3]) {
      const center = { 
        x: bird.x + bird.hitboxOffsetX, 
        y: bird.y + bird.hitboxOffsetY 
      };
      const r = bird.hitboxSize / 2;
      
      // Check if circle center is inside triangle
      if (pointInTriangle(center, v1, v2, v3)) return true;
      
      // Check if any triangle vertex is inside circle
      const dist1 = Math.hypot(center.x - v1.x, center.y - v1.y);
      const dist2 = Math.hypot(center.x - v2.x, center.y - v2.y);
      const dist3 = Math.hypot(center.x - v3.x, center.y - v3.y);
      if (dist1 < r || dist2 < r || dist3 < r) return true;
      
      // Check if circle intersects any triangle edge
      return (
        distancePointToSegment(center, v1, v2) <= r ||
        distancePointToSegment(center, v2, v3) <= r ||
        distancePointToSegment(center, v3, v1) <= r
      );
    }

    function distancePointToSegment(p, v, w) {
      const l2 = ((w.x - v.x) ** 2) + ((w.y - v.y) ** 2);
      if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
      let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
      t = Math.max(0, Math.min(1, t));
      const proj = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
      return Math.hypot(p.x - proj.x, p.y - proj.y);
    }

    function pointInTriangle(pt, v1, v2, v3) {
      const d1 = sign(pt, v1, v2);
      const d2 = sign(pt, v2, v3);
      const d3 = sign(pt, v3, v1);
      const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
      const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
      return !(hasNeg && hasPos);
    }
    function sign(p1, p2, p3) {
      return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
    }
    function rand(min, max) { return Math.random() * (max - min) + min; }

    function resetGame() {
      state.score = 0;
      state.gameOver = false; // Reset game over flag
      // Keep customLogo, customStory, backgroundColor from editor (don't reset)
      state.spikesLeft = [];
      state.spikesRight = [];
      state.topSpikes = createRowSpikes(true);
      state.bottomSpikes = createRowSpikes(false);
      // Cache top and bottom spikes (static, don't change)
      cacheTopBottomSpikes();
      state.particles = [];
      state.scoreTexts = [];
      state.pill = new Pill();
      state.spikesLeftCount = 2;
      state.spikesRightCount = 2;
      state.lastBounceTime = 0;
      state.bird = new Bird();
      state.perfStats = {
        collisionTime: 0,
        frameCount: 0,
        totalCollisionTime: 0,
        particlesTime: 0,
        scoreTextsTime: 0,
        totalParticlesTime: 0,
        totalScoreTextsTime: 0
      };
      scoreLabel.textContent = 'Score: 0';
      spawnWallSpikes(false);
    }

    function createRowSpikes(top) {
      const spikes = [];
      const size = CONFIG.SPIKE_SIZE;
      for (let x = CONFIG.WALL_OFFSET; x < CONFIG.WIDTH - CONFIG.WALL_OFFSET; x += size) {
        spikes.push({ x, orientation: top ? 'down' : 'up' });
      }
      return spikes;
    }

    // Cache top and bottom spikes to offscreen canvas (only draw once, reuse every frame)
    function cacheTopBottomSpikes() {
      const cacheCanvas = document.createElement('canvas');
      cacheCanvas.width = CONFIG.WIDTH;
      cacheCanvas.height = CONFIG.HEIGHT;
      const cacheCtx = cacheCanvas.getContext('2d');
      
      cacheCtx.fillStyle = '#4d4d4d';
      
      // Draw top spikes
      for (let i = 0; i < state.topSpikes.length; i++) {
        const spike = state.topSpikes[i];
        cacheCtx.beginPath();
        cacheCtx.moveTo(spike.x, 0);
        cacheCtx.lineTo(spike.x + CONFIG.SPIKE_SIZE / 2, CONFIG.TOP_SPIKE_HEIGHT);
        cacheCtx.lineTo(spike.x + CONFIG.SPIKE_SIZE, 0);
        cacheCtx.closePath();
        cacheCtx.fill();
      }
      
      // Draw bottom spikes
      for (let i = 0; i < state.bottomSpikes.length; i++) {
        const spike = state.bottomSpikes[i];
        cacheCtx.beginPath();
        cacheCtx.moveTo(spike.x, CONFIG.HEIGHT);
        cacheCtx.lineTo(spike.x + CONFIG.SPIKE_SIZE / 2, CONFIG.HEIGHT - CONFIG.TOP_SPIKE_HEIGHT);
        cacheCtx.lineTo(spike.x + CONFIG.SPIKE_SIZE, CONFIG.HEIGHT);
        cacheCtx.closePath();
        cacheCtx.fill();
      }
      
      state.cachedTopBottomCanvas = cacheCanvas;
    }

    function spawnWallSpikes(shouldIncrease = true) {
      if (shouldIncrease) {
        const totalSpikes = state.spikesLeftCount + state.spikesRightCount;
        if (totalSpikes < 14) {
          const randomSide = Math.random() < 0.5 ? 'left' : 'right';
          if (randomSide === 'left' && state.spikesLeftCount < 7) {
            state.spikesLeftCount++;
          } else if (randomSide === 'right' && state.spikesRightCount < 7) {
            state.spikesRightCount++;
          } else if (state.spikesLeftCount < 7) {
            state.spikesLeftCount++;
          } else if (state.spikesRightCount < 7) {
            state.spikesRightCount++;
          }
        }
      }
      state.spikesLeft = generateSideSpikes('left', state.spikesLeftCount);
      state.spikesRight = generateSideSpikes('right', state.spikesRightCount);
    }

    function generateSideSpikes(side, count) {
      const spikes = [];
      const used = [];
      for (let i = 0; i < count; i++) {
        let y;
        let attempts = 0;
        do {
          y = rand(160, CONFIG.HEIGHT - 160);
          attempts++;
        } while (used.some(val => Math.abs(val - y) < CONFIG.SPIKE_SIZE * 1.2) && attempts < 8);
        used.push(y);
        spikes.push(new Spike(y, side));
      }
      return spikes;
    }


    function wallBounce(nextDir) {
      const bird = state.bird;
      bird.direction = nextDir;
      bird.vx = CONFIG.HORIZONTAL_SPEED * nextDir;
      bird.vy = -Math.abs(CONFIG.HORIZONTAL_SPEED);
      state.score += 1;
      scoreLabel.textContent = `Score: ${state.score}`;
      spawnParticles(bird.x, bird.y);
      spawnPill();
      setTimeout(spawnWallSpikes, 200);
    }

    function spawnParticles(x, y) {
      const count = isMobile ? CONFIG.PARTICLES.mobile : CONFIG.PARTICLES.desktop;
      for (let i = 0; i < count; i++) {
        state.particles.push(new Particle(x, y));
      }
    }

    function spawnPill() {
      if (!state.pill) state.pill = new Pill();
      state.pill.spawn();
    }

    function handleJump() {
      if (!state.bird) return;
      if (!state.bird.active) {
        state.bird.active = true;
        state.bird.vx = CONFIG.HORIZONTAL_SPEED;
        state.bird.direction = 1;
        spawnWallSpikes();
        spawnPill();
      }
      state.bird.vy = CONFIG.JUMP_FORCE;
    }

    function triggerGameOver() {
      if (!state.running) return;
      state.running = false;
      state.started = false;
      state.gameOver = true; // Add flag to prevent floatIdleBird from running
      if (state.bird) {
        state.bird.active = false;
        state.bird.vx = 0;
        state.bird.vy = 0;
      }
      
      // ✅ Send GAME_OVER to stop timer and grant rewards (like Pacman and Blocks 8x8)
      window.parent?.postMessage({ type: 'GAME_OVER', gameId: EMBEDDED_GAME_ID }, '*');
      // ✅ Send score to leaderboard with correct gameId
      window.parent?.postMessage({ 
        type: 'GAME_SCORE', 
        gameId: EMBEDDED_GAME_ID, 
        score: state.score,
        level: 1
      }, '*');
      finalScoreText.textContent = `Score: ${state.score}`;
      
      // Update logo if available from editor
      const logoImg = document.getElementById('gameOverLogo');
      if (state.customLogo && logoImg) {
        logoImg.src = state.customLogo;
        logoImg.style.display = 'block';
      } else if (logoImg) {
        logoImg.style.display = 'none';
      }
      
      // Update story if available from editor, otherwise use random promo
      if (state.customStory) {
        promoText.textContent = state.customStory;
      } else {
        promoText.textContent = PROMOS[Math.floor(Math.random() * PROMOS.length)];
      }
      
      gameOverOverlay.classList.remove('hidden');
    }

    function checkCollisions() {
      const bird = state.bird;
      if (!bird || !bird.active) return;
      
      // Đo performance: Bắt đầu đo thời gian
      const startTime = performance.now();
      
      // Optimized: Pre-calculate bird position once
      const birdCenterX = bird.x + bird.hitboxOffsetX;
      const birdCenterY = bird.y + bird.hitboxOffsetY;
      const birdHitboxRadius = bird.hitboxSize / 2;
      
      // Optimized: Use 2 separate loops, don't create new array
      // Only check spikes that are potentially in range (X and Y position check)
      for (const spike of state.spikesLeft) {
        // Quick Y-axis check before expensive hit() calculation
        const dy = Math.abs(birdCenterY - spike.y);
        if (dy < birdHitboxRadius + CONFIG.SPIKE_SIZE) {
          // Quick X-axis check: left spikes are on the left wall
          const spikeX = CONFIG.WALL_OFFSET + CONFIG.SPIKE_SIZE / 2;
          const dx = Math.abs(birdCenterX - spikeX);
          if (dx < birdHitboxRadius + CONFIG.SPIKE_SIZE) {
            if (spike.hit(bird)) {
              // Freeze bird immediately at collision position
              bird.active = false;
              bird.vx = 0;
              bird.vy = 0;
              triggerGameOver();
              return;
            }
          }
        }
      }
      for (const spike of state.spikesRight) {
        // Quick Y-axis check before expensive hit() calculation
        const dy = Math.abs(birdCenterY - spike.y);
        if (dy < birdHitboxRadius + CONFIG.SPIKE_SIZE) {
          // Quick X-axis check: right spikes are on the right wall
          const spikeX = CONFIG.WIDTH - CONFIG.WALL_OFFSET - CONFIG.SPIKE_SIZE / 2;
          const dx = Math.abs(birdCenterX - spikeX);
          if (dx < birdHitboxRadius + CONFIG.SPIKE_SIZE) {
            if (spike.hit(bird)) {
              // Freeze bird immediately at collision position
              bird.active = false;
              bird.vx = 0;
              bird.vy = 0;
              triggerGameOver();
              return;
            }
          }
        }
      }
      
      // Check collision with top spikes: simple Y position check
      // Hitbox is a horizontal line at TOP_SPIKE_HEIGHT
      if (birdCenterY - birdHitboxRadius <= 34) {
        bird.active = false;
        bird.vx = 0;
        bird.vy = 0;
        triggerGameOver();
        return;
      }
      
      // Check collision with bottom spikes: simple Y position check
      // Hitbox is a horizontal line at HEIGHT - TOP_SPIKE_HEIGHT
      if (birdCenterY + birdHitboxRadius > CONFIG.HEIGHT - CONFIG.TOP_SPIKE_HEIGHT) {
        bird.active = false;
        bird.vx = 0;
        bird.vy = 0;
        triggerGameOver();
        return;
      }
      
      if (state.pill && state.pill.hit(bird)) {
        state.score += CONFIG.PILL_POINTS;
        scoreLabel.textContent = `Score: ${state.score}`;
        state.scoreTexts.push(new ScoreText(state.pill.x, state.pill.y, '+5'));
        state.pill.active = false;
      }
      
      // Đo performance: Kết thúc và lưu kết quả
      const endTime = performance.now();
      const duration = endTime - startTime;
      state.perfStats.totalCollisionTime += duration;
    }

    let lastTime = 0;
    function loop(timestamp) {
      requestAnimationFrame(loop);
      const dt = Math.min((timestamp - lastTime) || 16.7, 32) / (1000 / 60);
      lastTime = timestamp;

      // Use custom background color from editor
      ctx.fillStyle = state.backgroundColor || '#87ceeb';
      ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

      drawWallsAndRows();
      // Only draw left and right spikes (they change, top/bottom are cached)
      for (let i = 0; i < state.spikesLeft.length; i++) {
        state.spikesLeft[i].draw();
      }
      for (let i = 0; i < state.spikesRight.length; i++) {
        state.spikesRight[i].draw();
      }

      if (state.running) {
        // Check collisions first, then update (prevents bird moving after collision)
        checkCollisions();
        // Only update if still running (collision might have stopped the game)
        if (state.running && state.bird.active) {
          state.bird.update(dt);
        }
      } else if (!state.started && !state.gameOver) {
        // Only float bird if game hasn't started AND game hasn't ended
        floatIdleBird(timestamp);
      }

      if (state.pill) state.pill.draw();
      state.bird.draw();

      // Tối ưu: Reverse loop để remove an toàn, không tạo array mới
      const particlesStartTime = performance.now();
      // Batch update particles
      for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        if (p.life <= 0) {
          state.particles.splice(i, 1);
        } else {
          p.update(dt);
        }
      }
      // Batch draw particles (optimized: single loop, minimize state changes)
      if (state.particles.length > 0) {
        ctx.save();
        ctx.fillStyle = '#fff';
        let currentAlpha = -1;
        for (let i = 0; i < state.particles.length; i++) {
          const p = state.particles[i];
          if (p.life > 0) {
            const alpha = Math.min(Math.max(p.life / p.maxLife, 0) * 1.6, 1);
            // Only set globalAlpha if it changed (reduces state changes)
            if (Math.abs(alpha - currentAlpha) > 0.01) {
              ctx.globalAlpha = alpha;
              currentAlpha = alpha;
            }
            ctx.fillRect(p.x, p.y, 5, 5);
          }
        }
        ctx.globalAlpha = 1;
        ctx.restore();
      }
      state.perfStats.particlesTime = performance.now() - particlesStartTime;
      state.perfStats.totalParticlesTime += state.perfStats.particlesTime;

      const scoreTextsStartTime = performance.now();
      for (let i = state.scoreTexts.length - 1; i >= 0; i--) {
        const t = state.scoreTexts[i];
        if (t.life <= 0) {
          state.scoreTexts.splice(i, 1);
        } else {
          t.update(dt);
          t.draw();
        }
      }
      state.perfStats.scoreTextsTime = performance.now() - scoreTextsStartTime;
      state.perfStats.totalScoreTextsTime += state.perfStats.scoreTextsTime;

      // Tăng frameCount và log performance mỗi 60 frames (~1 giây)
      if (state.running) {
        state.perfStats.frameCount++;
        if (state.perfStats.frameCount % 60 === 0) {
          const avgCollisionTime = state.perfStats.totalCollisionTime / 60;
          const avgParticlesTime = state.perfStats.totalParticlesTime / 60;
          const avgScoreTextsTime = state.perfStats.totalScoreTextsTime / 60;
          const totalSpikes = state.spikesLeft.length + state.spikesRight.length;
          console.log(`[Performance] Collision: ${avgCollisionTime.toFixed(3)}ms (${totalSpikes} spikes) | Particles: ${avgParticlesTime.toFixed(3)}ms (${state.particles.length}) | ScoreTexts: ${avgScoreTextsTime.toFixed(3)}ms (${state.scoreTexts.length})`);
          // Reset sau khi log
          state.perfStats.totalCollisionTime = 0;
          state.perfStats.totalParticlesTime = 0;
          state.perfStats.totalScoreTextsTime = 0;
          state.perfStats.frameCount = 0;
        }
      }
    }

    function floatIdleBird(time) {
      if (!state.bird) return;
      state.bird.y = CONFIG.HEIGHT / 2 + Math.sin(time / 350) * 10;
    }

    function drawWallsAndRows() {
      // Optimized: Draw cached top and bottom spikes from offscreen canvas (much faster)
      if (state.cachedTopBottomCanvas) {
        ctx.drawImage(state.cachedTopBottomCanvas, 0, 0);
      } else {
        // Fallback: Draw manually if cache not ready
        ctx.fillStyle = '#4d4d4d';
        for (let i = 0; i < state.topSpikes.length; i++) {
          const spike = state.topSpikes[i];
          ctx.beginPath();
          ctx.moveTo(spike.x, 0);
          ctx.lineTo(spike.x + CONFIG.SPIKE_SIZE / 2, CONFIG.TOP_SPIKE_HEIGHT);
          ctx.lineTo(spike.x + CONFIG.SPIKE_SIZE, 0);
          ctx.closePath();
          ctx.fill();
        }
        for (let i = 0; i < state.bottomSpikes.length; i++) {
          const spike = state.bottomSpikes[i];
          ctx.beginPath();
          ctx.moveTo(spike.x, CONFIG.HEIGHT);
          ctx.lineTo(spike.x + CONFIG.SPIKE_SIZE / 2, CONFIG.HEIGHT - CONFIG.TOP_SPIKE_HEIGHT);
          ctx.lineTo(spike.x + CONFIG.SPIKE_SIZE, CONFIG.HEIGHT);
          ctx.closePath();
          ctx.fill();
        }
      }
      
    }

    startBtn.addEventListener('click', beginGame);
    retryBtn.addEventListener('click', () => {
      gameOverOverlay.classList.add('hidden');
      beginGame();
    });

    ['pointerdown', 'touchstart'].forEach(evt => {
      canvas.addEventListener(evt, (e) => {
        e.preventDefault();
        if (!state.running) return;
        handleJump();
      }, { passive: false });
    });
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (!state.running) return;
        handleJump();
      }
    });

    function beginGame() {
      resetGame();
      state.running = true;
      state.started = true;
      startOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');
      // ✅ Send GAME_START to track play count and start timer (like Pacman and Blocks 8x8)
      window.parent?.postMessage({ type: 'GAME_START', gameId: EMBEDDED_GAME_ID }, '*');
      handleJump();
    }

    // Listen for messages from parent (template editor)
    window.addEventListener('message', function(event) {
      if (event.data && event.data.type === 'WALL_BOUNCE_BIRD_CONFIG' && event.data.payload) {
        const config = event.data.payload;
        
        // Update background color
        if (config.backgroundColor) {
          state.backgroundColor = config.backgroundColor;
        }
        
        // Update logo (load image for pill replacement)
        if (config.logoUrl) {
          state.customLogo = config.logoUrl;
          // Load logo image for pill
          const logoImg = new Image();
          logoImg.onload = () => {
            state.customLogoImage = logoImg;
          };
          logoImg.onerror = () => {
            console.error('Failed to load custom logo for pill');
            state.customLogoImage = null;
          };
          logoImg.src = config.logoUrl;
        } else {
          state.customLogo = null;
          state.customLogoImage = null;
        }
        
        // Update story
        if (config.story) {
          state.customStory = config.story;
        } else {
          state.customStory = null;
        }
      }
    });

    // ✅ FIX: Load config từ localStorage TRƯỚC khi resetGame (đảm bảo config được apply ngay trên mobile)
    if (EMBEDDED_GAME_ID && EMBEDDED_GAME_ID !== 'wall-bounce-bird') {
      const configLoaded = loadBrandConfigFromLocalStorage(EMBEDDED_GAME_ID);
      if (configLoaded) {
        // Force initial draw với loaded config
        ctx.fillStyle = state.backgroundColor || '#87ceeb';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
      }
    }

    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>


