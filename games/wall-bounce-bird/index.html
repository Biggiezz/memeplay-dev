<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Wall Bounce Bird</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #040b1a;
      color: #fff;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    canvas {
      display: block;
      width: min(100vw, 720px);
      height: auto;
      max-height: 100vh;
      margin: 0 auto;
      background: #87ceeb;
      border-radius: 28px;
      box-shadow: 0 30px 120px rgba(0,0,0,0.35);
      touch-action: none;
    }
    .hud {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: min(720px, calc(100vw - 32px));
      display: flex;
      justify-content: space-between;
      font-weight: 700;
      letter-spacing: 0.05em;
      font-size: clamp(16px, 2vw, 24px);
      text-shadow: 0 4px 14px rgba(0,0,0,0.45);
      pointer-events: none;
      z-index: 5;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 24px;
      z-index: 10;
    }
    .overlay.hidden { display: none; }
    .overlay-card {
      width: min(420px, 90vw);
      background: rgba(5,7,14,0.92);
      border: 1px solid rgba(255,196,106,0.45);
      border-radius: 20px;
      padding: 32px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      box-shadow: 0 20px 80px rgba(0,0,0,0.6);
    }
    .overlay-card h1 {
      margin: 0;
      font-size: clamp(32px, 8vw, 48px);
      letter-spacing: 0.12em;
      color: #ffd447;
    }
    .overlay-card p { margin: 0; line-height: 1.5; color: #e6ecff; }
    .overlay-card button {
      padding: 14px 22px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(120deg, #ffd447, #ff9a2f);
      color: #1d0f00;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 12px 30px rgba(255,148,55,0.35);
      transition: transform 0.2s ease;
    }
    .overlay-card button:active { transform: scale(0.96); }
    .promo-text {
      font-style: italic;
      color: #c8d6ff;
      font-size: 15px;
      opacity: 0.9;
    }
    @media (max-width: 768px) {
      .hud { top: 12px; font-size: 16px; }
      canvas { width: calc(100vw - 16px); }
      .overlay-card { padding: 24px; }
    }
  </style>
</head>
<body>
  <div class="hud" id="hud" aria-live="polite">
    <span id="scoreLabel">Score: 0</span>
    <span id="bestLabel">Best: 0</span>
  </div>
  <canvas id="game" width="720" height="1000"></canvas>

  <div class="overlay" id="startOverlay">
    <div class="overlay-card">
      <h1>WALL BOUNCE</h1>
      <p>Tap anywhere to launch the bird, then keep bouncing between walls, dodge spikes, and grab energy pills for bonus points.</p>
      <button id="startBtn">Tap to Start</button>
    </div>
  </div>

  <div class="overlay hidden" id="gameOverOverlay">
    <div class="overlay-card">
      <h1>GAME OVER</h1>
      <p id="finalScoreText">Score: 0</p>
      <p class="promo-text" id="promoText"></p>
      <button id="retryBtn">Play Again</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { desynchronized: true });
    const scoreLabel = document.getElementById('scoreLabel');
    const bestLabel = document.getElementById('bestLabel');
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const finalScoreText = document.getElementById('finalScoreText');
    const promoText = document.getElementById('promoText');
    const startBtn = document.getElementById('startBtn');
    const retryBtn = document.getElementById('retryBtn');

    const PROMOS = [
      "From wild idea to global market – it all starts at Four Meme.",
      "Where memecoins are more than a joke – they're a blockchain movement.",
      "No code, no dev skills – just your meme and a little BNB.",
      "Four Meme turns spontaneous ideas into viral tokens on BNB Chain in minutes.",
      "With just a few clicks, you can create your own memecoin and instantly list it on PancakeSwap."
    ];

    const CONFIG = {
      WIDTH: 720,
      HEIGHT: 1000,
      GRAVITY: 0.6,
      JUMP_FORCE: -10,
      HORIZONTAL_SPEED: 6,
      WALL_OFFSET: 60,
      BIRD_SIZE: 50,
      SPIKE_SIZE: 40,
      TOP_SPIKE_HEIGHT: 30,
      PILL_SIZE: 56,
      PILL_POINTS: 5,
      PARTICLES: { desktop: 8, mobile: 2 },
      PILL_AREA: { minX: 150, maxX: 570, minY: 200, maxY: 600 }
    };

    const state = {
      running: false,
      started: false,
      score: 0,
      best: Number(localStorage.getItem('wallBounceBest') || '0'),
      bird: null,
      spikesLeft: [],
      spikesRight: [],
      topSpikes: [],
      bottomSpikes: [],
      pill: null,
      particles: [],
      scoreTexts: [],
      lastBounceTime: 0,
      difficultyStart: 0,
      maxSpikes: 3
    };

    const isMobile = /Mobi|Android/i.test(navigator.userAgent);

    class Bird {
      constructor() {
        this.x = CONFIG.WIDTH / 2;
        this.y = CONFIG.HEIGHT / 2;
        this.vx = 0;
        this.vy = 0;
        this.size = CONFIG.BIRD_SIZE;
        this.active = false;
        this.direction = 1;
      }
      update(dt) {
        if (!this.active) return;
        this.vy += CONFIG.GRAVITY * dt;
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        const half = this.size / 2;
        if (this.y - half < CONFIG.TOP_SPIKE_HEIGHT) {
          this.y = CONFIG.TOP_SPIKE_HEIGHT + half;
          triggerGameOver();
          return;
        }
        if (this.y + half > CONFIG.HEIGHT - CONFIG.TOP_SPIKE_HEIGHT) {
          this.y = CONFIG.HEIGHT - CONFIG.TOP_SPIKE_HEIGHT - half;
          triggerGameOver();
          return;
        }

        if (this.x - half <= CONFIG.WALL_OFFSET) {
          this.x = CONFIG.WALL_OFFSET + half;
          wallBounce(1);
        } else if (this.x + half >= CONFIG.WIDTH - CONFIG.WALL_OFFSET) {
          this.x = CONFIG.WIDTH - CONFIG.WALL_OFFSET - half;
          wallBounce(-1);
        }
      }
      draw() {
        const half = this.size / 2;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.direction, 1);

        ctx.fillStyle = '#d93232';
        ctx.beginPath();
        ctx.roundRect(-half, -half, this.size, this.size, 18);
        ctx.fill();

        ctx.fillStyle = '#f5a623';
        ctx.beginPath();
        ctx.moveTo(half - 10, -10);
        ctx.lineTo(half + 15, -2);
        ctx.lineTo(half - 10, 6);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#ffd447';
        ctx.beginPath();
        ctx.moveTo(-half + 8, -half + 6);
        ctx.lineTo(-half + 20, -half - 8);
        ctx.lineTo(-half + 32, -half + 10);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(half - 18, -10, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(half - 15, -10, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    class Spike {
      constructor(y, side) {
        this.y = y;
        this.side = side;
      }
      draw() {
        ctx.fillStyle = '#737373';
        ctx.beginPath();
        if (this.side === 'left') {
          ctx.moveTo(CONFIG.WALL_OFFSET, this.y);
          ctx.lineTo(CONFIG.WALL_OFFSET + CONFIG.SPIKE_SIZE, this.y - CONFIG.SPIKE_SIZE / 2);
          ctx.lineTo(CONFIG.WALL_OFFSET + CONFIG.SPIKE_SIZE, this.y + CONFIG.SPIKE_SIZE / 2);
        } else {
          ctx.moveTo(CONFIG.WIDTH - CONFIG.WALL_OFFSET, this.y);
          ctx.lineTo(CONFIG.WIDTH - CONFIG.WALL_OFFSET - CONFIG.SPIKE_SIZE, this.y - CONFIG.SPIKE_SIZE / 2);
          ctx.lineTo(CONFIG.WIDTH - CONFIG.WALL_OFFSET - CONFIG.SPIKE_SIZE, this.y + CONFIG.SPIKE_SIZE / 2);
        }
        ctx.closePath();
        ctx.fill();
      }
      hit(bird) {
        const tri = this.side === 'left'
          ? [
              { x: CONFIG.WALL_OFFSET, y: this.y },
              { x: CONFIG.WALL_OFFSET + CONFIG.SPIKE_SIZE, y: this.y - CONFIG.SPIKE_SIZE / 2 },
              { x: CONFIG.WALL_OFFSET + CONFIG.SPIKE_SIZE, y: this.y + CONFIG.SPIKE_SIZE / 2 }
            ]
          : [
              { x: CONFIG.WIDTH - CONFIG.WALL_OFFSET, y: this.y },
              { x: CONFIG.WIDTH - CONFIG.WALL_OFFSET - CONFIG.SPIKE_SIZE, y: this.y - CONFIG.SPIKE_SIZE / 2 },
              { x: CONFIG.WIDTH - CONFIG.WALL_OFFSET - CONFIG.SPIKE_SIZE, y: this.y + CONFIG.SPIKE_SIZE / 2 }
            ];
        return intersectsCircleTriangle(bird, tri);
      }
    }

    class Pill {
      constructor() {
        this.active = false;
        this.x = 0;
        this.y = 0;
        this.size = CONFIG.PILL_SIZE;
      }
      spawn() {
        this.active = true;
        this.x = rand(CONFIG.PILL_AREA.minX, CONFIG.PILL_AREA.maxX);
        this.y = rand(CONFIG.PILL_AREA.minY, CONFIG.PILL_AREA.maxY);
      }
      draw() {
        if (!this.active) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        const grd = ctx.createRadialGradient(0, 0, 6, 0, 0, this.size / 2);
        grd.addColorStop(0, '#fff6d1');
        grd.addColorStop(0.5, '#ffd447');
        grd.addColorStop(1, '#f05a28');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      hit(bird) {
        if (!this.active) return false;
        const dx = bird.x - this.x;
        const dy = bird.y - this.y;
        const dist = Math.hypot(dx, dy);
        return dist < (bird.size / 2 + this.size / 2 - 6);
      }
    }

    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = rand(1, 4);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 0.3;
        this.maxLife = 0.3;
      }
      update(dt) {
        this.life -= dt / 60;
        this.x += this.vx;
        this.y += this.vy + 0.15;
      }
      draw() {
        if (this.life <= 0) return;
        ctx.globalAlpha = Math.max(this.life / this.maxLife, 0);
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x, this.y, 3, 3);
        ctx.globalAlpha = 1;
      }
    }

    class ScoreText {
      constructor(x, y, text) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.life = 0.4;
      }
      update(dt) {
        this.life -= dt / 60;
        this.y -= 1.3;
      }
      draw() {
        if (this.life <= 0) return;
        ctx.globalAlpha = Math.max(this.life / 0.4, 0);
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 28px Inter';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
      }
    }

    function intersectsCircleTriangle(bird, [v1, v2, v3]) {
      const center = { x: bird.x, y: bird.y };
      const r = bird.size / 2 - 4;
      if (pointInTriangle(center, v1, v2, v3)) return true;
      return (
        distancePointToSegment(center, v1, v2) < r ||
        distancePointToSegment(center, v2, v3) < r ||
        distancePointToSegment(center, v3, v1) < r
      );
    }

    function distancePointToSegment(p, v, w) {
      const l2 = ((w.x - v.x) ** 2) + ((w.y - v.y) ** 2);
      if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
      let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
      t = Math.max(0, Math.min(1, t));
      const proj = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
      return Math.hypot(p.x - proj.x, p.y - proj.y);
    }

    function pointInTriangle(pt, v1, v2, v3) {
      const d1 = sign(pt, v1, v2);
      const d2 = sign(pt, v2, v3);
      const d3 = sign(pt, v3, v1);
      const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
      const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
      return !(hasNeg && hasPos);
    }
    function sign(p1, p2, p3) {
      return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
    }
    function rand(min, max) { return Math.random() * (max - min) + min; }

    function resetGame() {
      state.score = 0;
      state.spikesLeft = [];
      state.spikesRight = [];
      state.topSpikes = createRowSpikes(true);
      state.bottomSpikes = createRowSpikes(false);
      state.particles = [];
      state.scoreTexts = [];
      state.pill = new Pill();
      state.difficultyStart = performance.now();
      state.maxSpikes = 3;
      state.lastBounceTime = 0;
      state.bird = new Bird();
      scoreLabel.textContent = 'Score: 0';
      bestLabel.textContent = `Best: ${Math.max(state.best, 0)}`;
    }

    function createRowSpikes(top) {
      const spikes = [];
      const size = CONFIG.SPIKE_SIZE;
      for (let x = CONFIG.WALL_OFFSET; x < CONFIG.WIDTH - CONFIG.WALL_OFFSET; x += size) {
        spikes.push({ x, orientation: top ? 'down' : 'up' });
      }
      return spikes;
    }

    function spawnWallSpikes() {
      state.spikesLeft = generateSideSpikes('left');
      state.spikesRight = generateSideSpikes('right');
    }

    function generateSideSpikes(side) {
      const spikes = [];
      const count = Math.min(7, Math.floor(rand(2, state.maxSpikes + 1)));
      const used = [];
      for (let i = 0; i < count; i++) {
        let y;
        let attempts = 0;
        do {
          y = rand(160, CONFIG.HEIGHT - 160);
          attempts++;
        } while (used.some(val => Math.abs(val - y) < CONFIG.SPIKE_SIZE * 1.2) && attempts < 8);
        used.push(y);
        spikes.push(new Spike(y, side));
      }
      return spikes;
    }

    function wallBounce(nextDir) {
      const bird = state.bird;
      bird.direction = nextDir;
      bird.vx = CONFIG.HORIZONTAL_SPEED * nextDir;
      bird.vy = -Math.abs(CONFIG.HORIZONTAL_SPEED);
      state.score += 1;
      scoreLabel.textContent = `Score: ${state.score}`;
      bestLabel.textContent = `Best: ${Math.max(state.best, state.score)}`;
      spawnParticles(bird.x, bird.y);
      spawnPill();
      setTimeout(spawnWallSpikes, 200);
    }

    function spawnParticles(x, y) {
      const count = isMobile ? CONFIG.PARTICLES.mobile : CONFIG.PARTICLES.desktop;
      for (let i = 0; i < count; i++) {
        state.particles.push(new Particle(x, y));
      }
    }

    function spawnPill() {
      if (!state.pill) state.pill = new Pill();
      state.pill.spawn();
    }

    function handleJump() {
      if (!state.bird) return;
      if (!state.bird.active) {
        state.bird.active = true;
        state.bird.vx = CONFIG.HORIZONTAL_SPEED;
        state.bird.direction = 1;
        spawnWallSpikes();
        spawnPill();
      }
      state.bird.vy = CONFIG.JUMP_FORCE;
    }

    function triggerGameOver() {
      if (!state.running) return;
      state.running = false;
      state.started = false;
      window.parent?.postMessage({ type: 'GAME_SCORE', gameId: 'wall-bounce-bird', score: state.score }, '*');
      finalScoreText.textContent = `Score: ${state.score}`;
      promoText.textContent = PROMOS[Math.floor(Math.random() * PROMOS.length)];
      gameOverOverlay.classList.remove('hidden');
      if (state.score > state.best) {
        state.best = state.score;
        localStorage.setItem('wallBounceBest', String(state.best));
      }
      bestLabel.textContent = `Best: ${state.best}`;
    }

    function checkCollisions() {
      const bird = state.bird;
      if (!bird || !bird.active) return;
      const sideSpikes = [...state.spikesLeft, ...state.spikesRight];
      for (const spike of sideSpikes) {
        if (spike.hit(bird)) {
          triggerGameOver();
          return;
        }
      }
      if (state.pill && state.pill.hit(bird)) {
        state.score += CONFIG.PILL_POINTS;
        scoreLabel.textContent = `Score: ${state.score}`;
        bestLabel.textContent = `Best: ${Math.max(state.best, state.score)}`;
        state.scoreTexts.push(new ScoreText(state.pill.x, state.pill.y, '+5'));
        state.pill.active = false;
      }
    }

    function updateDifficulty(now) {
      const elapsed = (now - state.difficultyStart) / 1000;
      if (elapsed <= 3) return;
      const extra = Math.floor((elapsed - 3) / 5);
      state.maxSpikes = Math.min(7, 3 + extra);
    }

    let lastTime = 0;
    function loop(timestamp) {
      requestAnimationFrame(loop);
      const dt = Math.min((timestamp - lastTime) || 16.7, 32) / (1000 / 60);
      lastTime = timestamp;

      ctx.fillStyle = '#87ceeb';
      ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

      drawWallsAndRows();
      state.spikesLeft.forEach(spike => spike.draw());
      state.spikesRight.forEach(spike => spike.draw());

      if (state.running) {
        state.bird.update(dt);
        updateDifficulty(timestamp);
        checkCollisions();
      } else if (!state.started) {
        floatIdleBird(timestamp);
      }

      if (state.pill) state.pill.draw();
      state.bird.draw();

      state.particles = state.particles.filter(p => p.life > 0);
      state.particles.forEach(p => { p.update(dt); p.draw(); });

      state.scoreTexts = state.scoreTexts.filter(t => t.life > 0);
      state.scoreTexts.forEach(t => { t.update(dt); t.draw(); });
    }

    function floatIdleBird(time) {
      if (!state.bird) return;
      state.bird.y = CONFIG.HEIGHT / 2 + Math.sin(time / 350) * 10;
    }

    function drawWallsAndRows() {
      ctx.fillStyle = '#0f1c2f';
      ctx.fillRect(0, 0, CONFIG.WALL_OFFSET, CONFIG.HEIGHT);
      ctx.fillRect(CONFIG.WIDTH - CONFIG.WALL_OFFSET, 0, CONFIG.WALL_OFFSET, CONFIG.HEIGHT);

      ctx.fillStyle = '#4d4d4d';
      state.topSpikes.forEach(spike => {
        ctx.beginPath();
        ctx.moveTo(spike.x, CONFIG.TOP_SPIKE_HEIGHT);
        ctx.lineTo(spike.x + CONFIG.SPIKE_SIZE / 2, 0);
        ctx.lineTo(spike.x + CONFIG.SPIKE_SIZE, CONFIG.TOP_SPIKE_HEIGHT);
        ctx.closePath();
        ctx.fill();
      });
      state.bottomSpikes.forEach(spike => {
        ctx.beginPath();
        ctx.moveTo(spike.x, CONFIG.HEIGHT - CONFIG.TOP_SPIKE_HEIGHT);
        ctx.lineTo(spike.x + CONFIG.SPIKE_SIZE / 2, CONFIG.HEIGHT);
        ctx.lineTo(spike.x + CONFIG.SPIKE_SIZE, CONFIG.HEIGHT - CONFIG.TOP_SPIKE_HEIGHT);
        ctx.closePath();
        ctx.fill();
      });
    }

    startBtn.addEventListener('click', beginGame);
    retryBtn.addEventListener('click', () => {
      gameOverOverlay.classList.add('hidden');
      beginGame();
    });

    ['pointerdown', 'touchstart'].forEach(evt => {
      canvas.addEventListener(evt, (e) => {
        e.preventDefault();
        if (!state.running) return;
        handleJump();
      }, { passive: false });
    });
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (!state.running) return;
        handleJump();
      }
    });

    function beginGame() {
      resetGame();
      state.running = true;
      state.started = true;
      startOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');
      window.parent?.postMessage({ type: 'GAME_START', gameId: 'wall-bounce-bird' }, '*');
      handleJump();
    }

    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>


