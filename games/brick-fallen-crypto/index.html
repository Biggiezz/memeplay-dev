<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Brick - Fallen Crypto</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      background: #0a0a0a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      touch-action: none;
    }
    #gameCanvas {
      display: block;
      max-width: 100vw;
      max-height: 100vh;
      background: #000;
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-crisp-edges;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      will-change: transform;
      transform: translateZ(0);
      backface-visibility: hidden;
      touch-action: none;
    }
    .touch-zone {
      position: fixed;
      bottom: 0;
      width: 50%;
      height: 100%;
      z-index: 50;
      opacity: 0;
      touch-action: none;
    }
    .touch-zone.left {
      left: 0;
    }
    .touch-zone.right {
      right: 0;
    }
    .start-screen, .level-screen, .game-over-screen {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #ffd700;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      color: white;
      z-index: 200;
      display: none;
    }
    .start-screen.show, .level-screen.show, .game-over-screen.show {
      display: block;
      animation: popIn 0.3s ease-out;
    }
    .screen-title {
      font-size: 48px;
      color: #ffd700;
      margin-bottom: 20px;
      text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
    }
    .screen-subtitle {
      font-size: 24px;
      margin-bottom: 30px;
      line-height: 1.6;
    }
    .screen-btn {
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      color: #000;
      border: none;
      border-radius: 10px;
      padding: 15px 40px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s;
      font-family: 'Courier New', monospace;
    }
    .screen-btn:hover {
      transform: scale(1.05);
    }
    .screen-btn:active {
      transform: scale(0.95);
    }
    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    @media (max-width: 768px) {
      .control-btn { width: 100px; height: 100px; font-size: 40px; }
      .screen-title { font-size: 36px; }
      .screen-subtitle { font-size: 20px; }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div class="touch-zone left" id="touchLeft"></div>
  <div class="touch-zone right" id="touchRight"></div>

  <div class="start-screen show" id="startScreen">
    <div class="screen-title">BRICK</div>
    <div class="screen-subtitle">
      Fallen Crypto<br>
      <small style="font-size: 18px; opacity: 0.8;">
        Break the logos of failed projects
      </small>
    </div>
    <button class="screen-btn" id="startBtn">START GAME</button>
  </div>

  <div class="level-screen" id="levelScreen">
    <div class="screen-title" id="levelTitle">LEVEL 1</div>
    <div class="screen-subtitle" id="levelSubtitle">FTX</div>
    <button class="screen-btn" id="levelStartBtn">START</button>
  </div>

  <div class="game-over-screen" id="gameOverScreen">
    <div class="screen-title">GAME OVER</div>
    <div class="screen-subtitle">
      Level: <span id="finalLevel">1</span><br>
      Score: <span id="finalScore">0</span><br>
      Bricks: <span id="finalBricks">0</span>
    </div>
    <button class="screen-btn" id="restartBtn">PLAY AGAIN</button>
  </div>

  <script>
    // ==========================================
    // MOBILE DETECTION
    // ==========================================
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const speedMultiplier = isMobile ? 2.1 : 1.0; // +110% on mobile (70% + 40%)
    
    console.log('ðŸ“± Device:', isMobile ? 'Mobile' : 'Desktop', '| Speed:', speedMultiplier + 'x');

    // ==========================================
    // GAME CONFIGURATION
    // ==========================================
    const CONFIG = {
      WIDTH: 720,
      HEIGHT: 1000,
      PADDLE_WIDTH: 120,
      PADDLE_HEIGHT: 20,
      PADDLE_Y: 920,
      PADDLE_SPEED: 8,
      BALL_SIZE: 32, // x4 size (was 8)
      get BALL_SPEED_BASE() { return 4 * speedMultiplier; },
      BRICK_PADDING: 1, // Tight spacing
      LEVEL_TIME: 30000, // 30 seconds per level
      MAX_LEVEL: 20,
      MAX_BALLS: 15, // Tá»‘i Ä‘a 15 viÃªn bi
      POWERUP_SIZE: 24,
      POWERUP_FALL_SPEED: 3,
      // Brick progression
      LEVEL1_BRICKS: 30, // 5 rows x 6 cols
      BRICKS_PER_LEVEL: 6 // +6 bricks each level
    };

    // Failed crypto projects
    const CRYPTO_LOGOS = [
      { name: 'FTX', rows: 8, cols: 16 },
      { name: 'LUNA', rows: 8, cols: 16 },
      { name: 'BITCONNECT', rows: 8, cols: 20 },
      { name: 'MT.GOX', rows: 8, cols: 16 },
      { name: 'CELSIUS', rows: 8, cols: 18 },
      { name: 'VOYAGER', rows: 8, cols: 18 },
      { name: 'THREE ARROWS', rows: 9, cols: 20 },
      { name: 'BLOCKFI', rows: 8, cols: 18 },
      { name: 'TERRA', rows: 8, cols: 14 },
      { name: 'SAFEMOON', rows: 8, cols: 18 },
      { name: 'SQUID GAME', rows: 9, cols: 20 },
      { name: 'ONECOIN', rows: 8, cols: 18 },
      { name: 'QUADRIGA', rows: 9, cols: 20 },
      { name: 'THODEX', rows: 8, cols: 16 },
      { name: 'AFRICRYPT', rows: 9, cols: 20 },
      { name: 'TITANIUM', rows: 9, cols: 20 },
      { name: 'CENTRA', rows: 8, cols: 16 },
      { name: 'PLUSTOKEN', rows: 9, cols: 20 },
      { name: 'BITCLUB', rows: 8, cols: 18 },
      { name: 'PONZICOIN', rows: 9, cols: 20 }
    ];

    // ==========================================
    // CANVAS SETUP
    // ==========================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { 
      alpha: false, 
      desynchronized: true 
    });
    ctx.imageSmoothingEnabled = false;

    canvas.width = CONFIG.WIDTH;
    canvas.height = CONFIG.HEIGHT;

    // ==========================================
    // GAME STATE
    // ==========================================
    let gameState = {
      isRunning: false,
      level: 1,
      score: 0,
      bricksDestroyed: 0,
      levelStartTime: 0,
      timeRemaining: 30,
      currentLogo: 'FTX'
    };

    // ==========================================
    // PADDLE
    // ==========================================
    const paddle = {
      x: CONFIG.WIDTH / 2 - CONFIG.PADDLE_WIDTH / 2,
      y: CONFIG.PADDLE_Y,
      width: CONFIG.PADDLE_WIDTH,
      height: CONFIG.PADDLE_HEIGHT,
      vx: 0,
      color: '#00ff00'
    };

    // ==========================================
    // BALLS
    // ==========================================
    const balls = [];

    class Ball {
      constructor(x, y, randomDirection = false) {
        this.x = x;
        this.y = y;
        this.size = CONFIG.BALL_SIZE;
        
        if (randomDirection) {
          // Random angle between 45Â° and 135Â° (upward)
          const angle = (Math.random() * 90 + 45) * Math.PI / 180;
          this.vx = Math.cos(angle) * CONFIG.BALL_SPEED_BASE;
          this.vy = -Math.abs(Math.sin(angle) * CONFIG.BALL_SPEED_BASE);
        } else {
          this.vx = (Math.random() - 0.5) * 2;
          this.vy = -CONFIG.BALL_SPEED_BASE;
        }
        
        this.active = true;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;

        // Wall collision (circular hitbox)
        if (this.x - this.size / 2 <= 0) {
          this.vx = Math.abs(this.vx);
          this.x = this.size / 2;
        }
        if (this.x + this.size / 2 >= CONFIG.WIDTH) {
          this.vx = -Math.abs(this.vx);
          this.x = CONFIG.WIDTH - this.size / 2;
        }

        // Ceiling collision
        if (this.y - this.size / 2 <= 0) {
          this.vy = Math.abs(this.vy);
          this.y = this.size / 2;
        }

        // Paddle collision (circular ball vs rectangle paddle)
        const ballBottom = this.y + this.size / 2;
        const ballTop = this.y - this.size / 2;
        const ballLeft = this.x - this.size / 2;
        const ballRight = this.x + this.size / 2;
        
        if (ballBottom >= paddle.y &&
            ballTop <= paddle.y + paddle.height &&
            ballRight >= paddle.x &&
            ballLeft <= paddle.x + paddle.width) {
          // Bounce off paddle
          this.vy = -Math.abs(this.vy);
          this.y = paddle.y - this.size / 2;
          
          // Add spin based on hit position
          const paddleCenter = paddle.x + paddle.width / 2;
          const hitOffset = (this.x - paddleCenter) / (paddle.width / 2);
          this.vx += hitOffset * 2;
        }

        // Ball falls off bottom = GAME OVER (mark inactive)
        if (this.y - this.size / 2 > CONFIG.HEIGHT) {
          this.active = false;
        }
      }

      draw() {
        // Draw circular ball
        ctx.fillStyle = '#ff00ff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Hitbox (cyan circle)
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    // ==========================================
    // POWERUPS
    // ==========================================
    const powerups = [];

    class Powerup {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'x2' or 'x3'
        this.size = CONFIG.POWERUP_SIZE;
        this.vy = CONFIG.POWERUP_FALL_SPEED;
        this.collected = false;
        this.rotation = 0;
      }

      update(deltaTime) {
        this.y += this.vy * deltaTime;
        this.rotation += 0.1 * deltaTime;

        // Check paddle collision
        if (this.y + this.size / 2 >= paddle.y &&
            this.y - this.size / 2 <= paddle.y + paddle.height &&
            this.x + this.size / 2 >= paddle.x &&
            this.x - this.size / 2 <= paddle.x + paddle.width) {
          this.collected = true;
          
          // Multiply current balls
          const multiplier = this.type === 'x3' ? 3 : 2;
          const currentBalls = balls.filter(b => b.active);
          const ballsToAdd = Math.min(
            currentBalls.length * (multiplier - 1),
            CONFIG.MAX_BALLS - balls.length
          );
          
          for (let i = 0; i < ballsToAdd; i++) {
            const sourceBall = currentBalls[i % currentBalls.length];
            const newBall = new Ball(sourceBall.x, sourceBall.y, true);
            newBall.vx = sourceBall.vx + (Math.random() - 0.5) * 2;
            newBall.vy = sourceBall.vy + (Math.random() - 0.5);
            balls.push(newBall);
          }
        }

        // Remove if off screen
        if (this.y > CONFIG.HEIGHT) {
          this.collected = true;
        }
      }

      draw() {
        if (this.collected) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        // Glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.type === 'x3' ? '#ff0000' : '#00ff00';

        // Diamond shape
        ctx.fillStyle = this.type === 'x3' ? '#ff0000' : '#00ff00';
        ctx.beginPath();
        ctx.moveTo(0, -this.size / 2);
        ctx.lineTo(this.size / 2, 0);
        ctx.lineTo(0, this.size / 2);
        ctx.lineTo(-this.size / 2, 0);
        ctx.closePath();
        ctx.fill();

        // Label
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.type.toUpperCase(), 0, 0);

        ctx.restore();
      }
    }

    // ==========================================
    // BRICKS
    // ==========================================
    const bricks = [];

    class Brick {
      constructor(x, y, width, height, color) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.color = color;
        this.alive = true;
      }

      checkCollision(ball) {
        if (!this.alive) return false;

        const radius = ball.size / 2;
        const ballLeft = ball.x - radius;
        const ballRight = ball.x + radius;
        const ballTop = ball.y - radius;
        const ballBottom = ball.y + radius;

        if (ballRight >= this.x &&
            ballLeft <= this.x + this.width &&
            ballBottom >= this.y &&
            ballTop <= this.y + this.height) {
          
          // Determine collision side
          const overlapLeft = ballRight - this.x;
          const overlapRight = (this.x + this.width) - ballLeft;
          const overlapTop = ballBottom - this.y;
          const overlapBottom = (this.y + this.height) - ballTop;

          const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

          if (minOverlap === overlapLeft || minOverlap === overlapRight) {
            ball.vx = -ball.vx;
          } else {
            ball.vy = -ball.vy;
          }

          this.alive = false;
          gameState.score += 10;
          gameState.bricksDestroyed++;
          return true;
        }
        return false;
      }

      draw() {
        if (!this.alive) return;

        // Brick body
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);

        // Brick highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(this.x + 1, this.y + 1, this.width - 2, 2);

        // Brick border
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
      }
    }

    // ==========================================
    // LEVEL GENERATION
    // ==========================================
    function generateLevel(level) {
      bricks.length = 0;
      
      // Calculate total bricks: 30 + (level-1) * 6
      const totalBricks = CONFIG.LEVEL1_BRICKS + (level - 1) * CONFIG.BRICKS_PER_LEVEL;
      
      // Find best rows/cols for rectangle (prefer square)
      let rows = Math.floor(Math.sqrt(totalBricks));
      let cols = Math.ceil(totalBricks / rows);
      
      // Adjust to fit exact count
      while (rows * cols < totalBricks) {
        cols++;
      }
      
      // Calculate brick size to fit screen
      const availableWidth = CONFIG.WIDTH - 40; // 20px margin each side
      const availableHeight = 400; // Top area for bricks
      
      let brickWidth = Math.floor((availableWidth - (cols + 1) * CONFIG.BRICK_PADDING) / cols);
      let brickHeight = Math.floor((availableHeight - (rows + 1) * CONFIG.BRICK_PADDING) / rows);
      
      // Thu nhá» gáº¡ch xuá»‘ng 25% (giáº£m 75%)
      brickWidth = Math.floor(brickWidth * 0.25);
      brickHeight = Math.floor(brickHeight * 0.25);
      
      // Center the brick field
      const totalWidth = cols * brickWidth + (cols + 1) * CONFIG.BRICK_PADDING;
      const startX = (CONFIG.WIDTH - totalWidth) / 2;
      const startY = 80;

      // Create solid rectangle of bricks (no pattern, all filled)
      let brickCount = 0;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          if (brickCount >= totalBricks) break;
          
          const x = startX + col * (brickWidth + CONFIG.BRICK_PADDING) + CONFIG.BRICK_PADDING;
          const y = startY + row * (brickHeight + CONFIG.BRICK_PADDING) + CONFIG.BRICK_PADDING;
          const color = getBrickColor(row, rows);
          
          bricks.push(new Brick(x, y, brickWidth, brickHeight, color));
          brickCount++;
        }
        if (brickCount >= totalBricks) break;
      }
      
      // Get crypto name for display
      const logoIndex = (level - 1) % CRYPTO_LOGOS.length;
      gameState.currentLogo = CRYPTO_LOGOS[logoIndex].name;
    }

    function getBrickColor(row, totalRows) {
      const colors = ['#ff0000', '#ff4400', '#ff8800', '#ffcc00', '#ffff00', '#88ff00'];
      const index = Math.floor((row / totalRows) * colors.length);
      return colors[Math.min(index, colors.length - 1)];
    }

    // ==========================================
    // CONTROLS
    // ==========================================
    let leftPressed = false;
    let rightPressed = false;

    const touchLeft = document.getElementById('touchLeft');
    const touchRight = document.getElementById('touchRight');

    // Touch zones (left/right half of screen)
    touchLeft.addEventListener('touchstart', (e) => {
      e.preventDefault();
      leftPressed = true;
    });
    touchLeft.addEventListener('touchend', (e) => {
      e.preventDefault();
      leftPressed = false;
    });
    touchLeft.addEventListener('mousedown', () => leftPressed = true);
    touchLeft.addEventListener('mouseup', () => leftPressed = false);

    touchRight.addEventListener('touchstart', (e) => {
      e.preventDefault();
      rightPressed = true;
    });
    touchRight.addEventListener('touchend', (e) => {
      e.preventDefault();
      rightPressed = false;
    });
    touchRight.addEventListener('mousedown', () => rightPressed = true);
    touchRight.addEventListener('mouseup', () => rightPressed = false);

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = true;
      if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = true;
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = false;
      if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = false;
    });

    // ==========================================
    // GAME LOOP
    // ==========================================
    let lastTime = 0;

    function gameLoop(currentTime) {
      requestAnimationFrame(gameLoop);
      
      if (!gameState.isRunning) return;
      
      const deltaTime = Math.min((currentTime - lastTime) / 16.67, 2);
      lastTime = currentTime;

      update(deltaTime, currentTime);
      render();
    }

    function update(deltaTime, currentTime) {
      // Update paddle
      paddle.vx = 0;
      if (leftPressed) paddle.vx = -CONFIG.PADDLE_SPEED;
      if (rightPressed) paddle.vx = CONFIG.PADDLE_SPEED;
      
      paddle.x += paddle.vx * deltaTime;
      paddle.x = Math.max(0, Math.min(CONFIG.WIDTH - paddle.width, paddle.x));

      // Update balls
      balls.forEach(ball => {
        if (ball.active) {
          ball.update();

          // Check brick collisions (max 2 bricks per ball per frame)
          let bricksHit = 0;
          for (let brick of bricks) {
            if (brick.alive && bricksHit < 2) {
              if (brick.checkCollision(ball)) {
                bricksHit++;
                
                // Random powerup drop (15% chance x2, 5% chance x3)
                const rand = Math.random();
                if (rand < 0.05) {
                  powerups.push(new Powerup(brick.x + brick.width / 2, brick.y + brick.height / 2, 'x3'));
                } else if (rand < 0.20) {
                  powerups.push(new Powerup(brick.x + brick.width / 2, brick.y + brick.height / 2, 'x2'));
                }
              }
            }
          }
        }
      });

      // Update powerups
      powerups.forEach(powerup => {
        if (!powerup.collected) {
          powerup.update(deltaTime);
        }
      });

      // Remove collected powerups
      for (let i = powerups.length - 1; i >= 0; i--) {
        if (powerups[i].collected) {
          powerups.splice(i, 1);
        }
      }

      // Remove inactive balls
      for (let i = balls.length - 1; i >= 0; i--) {
        if (!balls[i].active) {
          balls.splice(i, 1);
        }
      }

      // No balls left - GAME OVER (ball fell off paddle)
      if (balls.length === 0) {
        endGame();
        return;
      }

      // Check level complete
      const aliveBricks = bricks.filter(b => b.alive).length;
      if (aliveBricks === 0) {
        nextLevel();
        return;
      }

      // Update timer
      const elapsed = currentTime - gameState.levelStartTime;
      gameState.timeRemaining = Math.max(0, CONFIG.LEVEL_TIME - elapsed) / 1000;

      // Time's up - game over
      if (gameState.timeRemaining <= 0) {
        endGame();
      }
    }

    function render() {
      // Clear canvas
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

      // Draw stars background
      ctx.fillStyle = 'white';
      for (let i = 0; i < 100; i++) {
        const x = (i * 73) % CONFIG.WIDTH;
        const y = (i * 97) % CONFIG.HEIGHT;
        ctx.fillRect(x, y, 2, 2);
      }

      // Draw bricks
      bricks.forEach(brick => brick.draw());

      // Draw powerups
      powerups.forEach(powerup => powerup.draw());

      // Draw balls
      balls.forEach(ball => {
        if (ball.active) ball.draw();
      });

      // Draw paddle
      ctx.fillStyle = paddle.color;
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
      
      // Paddle highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.fillRect(paddle.x + 2, paddle.y + 2, paddle.width - 4, 4);
      
      // Paddle hitbox (cyan)
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 2;
      ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);

      // Draw UI
      ctx.fillStyle = 'white';
      ctx.font = '24px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(`L${gameState.level}`, 10, 30);
      ctx.fillText(`${Math.ceil(gameState.timeRemaining)}s`, 10, 60);
      
      ctx.textAlign = 'right';
      ctx.fillText(`${gameState.score}`, CONFIG.WIDTH - 10, 30);
      
      // Draw level name
      ctx.textAlign = 'center';
      ctx.font = '20px Courier New';
      ctx.fillStyle = '#ff0000';
      ctx.fillText(gameState.currentLogo, CONFIG.WIDTH / 2, 30);
    }

    // ==========================================
    // GAME FLOW
    // ==========================================
    function startGame() {
      window.parent.postMessage({ 
        type: 'GAME_START', 
        gameId: 'brick-fallen-crypto' 
      }, '*');

      gameState = {
        isRunning: true,
        level: 1,
        score: 0,
        bricksDestroyed: 0,
        levelStartTime: performance.now(),
        timeRemaining: 30
      };

      paddle.x = CONFIG.WIDTH / 2 - CONFIG.PADDLE_WIDTH / 2;
      balls.length = 0;
      powerups.length = 0;
      
      generateLevel(1);
      spawnBall(true); // Random direction for first ball

      document.getElementById('startScreen').classList.remove('show');
      lastTime = performance.now();
    }

    function nextLevel() {
      if (gameState.level >= CONFIG.MAX_LEVEL) {
        // Won all 20 levels!
        endGame(true);
        return;
      }

      gameState.level++;
      gameState.levelStartTime = performance.now();
      gameState.timeRemaining = 30;
      
      // Show level screen
      gameState.isRunning = false;
      const logoIndex = (gameState.level - 1) % CRYPTO_LOGOS.length;
      document.getElementById('levelTitle').textContent = `LEVEL ${gameState.level}`;
      document.getElementById('levelSubtitle').textContent = CRYPTO_LOGOS[logoIndex].name;
      document.getElementById('levelScreen').classList.add('show');
    }

    function startLevel() {
      document.getElementById('levelScreen').classList.remove('show');
      generateLevel(gameState.level);
      balls.length = 0;
      powerups.length = 0;
      spawnBall(true); // Random direction for first ball
      gameState.isRunning = true;
      gameState.levelStartTime = performance.now();
    }

    function spawnBall(isFirstBall = false) {
      // Limit to max 15 balls
      if (balls.length >= CONFIG.MAX_BALLS) return;
      
      const ball = new Ball(
        paddle.x + paddle.width / 2,
        paddle.y - 20,
        isFirstBall // Random direction for first ball
      );
      // Tá»‘c Ä‘á»™ bi KHÃ”NG tÄƒng theo level (giá»¯ nguyÃªn lv1)
      // No speed boost!
      balls.push(ball);
    }

    function endGame(won = false) {
      gameState.isRunning = false;

      window.parent.postMessage({ 
        type: 'GAME_SCORE', 
        gameId: 'brick-fallen-crypto',
        score: gameState.score 
      }, '*');

      document.getElementById('finalLevel').textContent = gameState.level;
      document.getElementById('finalScore').textContent = gameState.score;
      document.getElementById('finalBricks').textContent = gameState.bricksDestroyed;
      
      if (won) {
        document.querySelector('.game-over-screen .screen-title').textContent = 'YOU WON!';
      } else {
        document.querySelector('.game-over-screen .screen-title').textContent = 'GAME OVER';
      }
      
      document.getElementById('gameOverScreen').classList.add('show');
    }

    function restartGame() {
      document.getElementById('gameOverScreen').classList.remove('show');
      startGame();
    }

    // ==========================================
    // EVENT LISTENERS
    // ==========================================
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('levelStartBtn').addEventListener('click', startLevel);
    document.getElementById('restartBtn').addEventListener('click', restartGame);

    // ==========================================
    // START GAME LOOP
    // ==========================================
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
